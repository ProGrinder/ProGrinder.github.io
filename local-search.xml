<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>算法竞赛进阶指南-12.激光炸弹</title>
    <link href="/2023/01/12/Algorithm/Comp/20230112-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-012-%E6%BF%80%E5%85%89%E7%82%B8%E5%BC%B9/"/>
    <url>/2023/01/12/Algorithm/Comp/20230112-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-012-%E6%BF%80%E5%85%89%E7%82%B8%E5%BC%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="题目链接"><a class="markdownIt-Anchor" href="#题目链接"></a> 题目链接</h3><p><a href="https://www.acwing.com/problem/content/101/">算法竞赛进阶指南-12.激光炸弹</a></p><p>cin &gt;&gt; n &gt;&gt; r;</p><p>题目意思就是有n个目标，炸弹范围是r * r</p><p>接下来输入n行目标的坐标x, y 和其价值w，</p><p>要求输出一个炸弹范围最多能包含多少总价值的目标。</p><h3 id="method-前缀和"><a class="markdownIt-Anchor" href="#method-前缀和"></a> Method : 前缀和</h3><p>显然是二维的前缀和问题。</p><p>这道题比较难的点:</p><ol><li>坐标的偏移处理, <code>s[++ x][++ y] += w</code></li><li>内存限制很严格, 必须在原数组上做前缀和覆盖，不能另外申请数组</li><li>数据点严格, 不加这两句过不了最后两个点，<code>r = min(r, N - 1); x_max = y_max = r;</code></li></ol><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;const int N &#x3D; 5e3 + 7;int n, r;int x_max, y_max;&#x2F;&#x2F;  int w[N][N];int s[N][N];int main() &#123;    cin &gt;&gt; n &gt;&gt; r;    r &#x3D; min(r, N - 1);    x_max &#x3D; y_max &#x3D; r;    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++) &#123;        int x, y, curw;        scanf(&quot;%d %d %d&quot;, &amp;x, &amp;y, &amp;curw);        s[++ x][++ y] +&#x3D; curw;        x_max &#x3D; max(x_max, x);        y_max &#x3D; max(y_max, y);    &#125;    &#x2F;&#x2F; 预处理前缀和    for (int i &#x3D; 1; i &lt;&#x3D; x_max; i ++) &#123;        for (int j &#x3D; 1; j &lt;&#x3D; y_max; j ++) &#123;            s[i][j] &#x3D; s[i][j - 1] + s[i - 1][j] - s[i - 1][j - 1] + s[i][j];        &#125;    &#125;    int res &#x3D; 0;    &#x2F;&#x2F; 以右下坐标为原点统计    &#x2F;&#x2F; 右下点(x2, y2) : (i, j)   左上点(x1, y1) : (i - r + 1, j - r + 1)    for (int i &#x3D; r; i &lt;&#x3D; x_max; i ++) &#123;        for (int j &#x3D; r; j &lt;&#x3D; y_max; j ++) &#123;            int tar &#x3D; s[i][j] - s[i][j - r] - s[i - r][j] + s[i - r][j - r];            res &#x3D; max(res, tar);        &#125;    &#125;    &#x2F;&#x2F; 以左上坐标为原点统计    &#x2F;&#x2F; for (int i &#x3D; 1; i &lt;&#x3D; x_max - r + 1; i ++) &#123;    &#x2F;&#x2F;     for (int j &#x3D; 1; j &lt;&#x3D; y_max - r + 1; j ++) &#123;    &#x2F;&#x2F;         int tar &#x3D; s[i + r - 1][j + r - 1] - s[i + r - 1][j - 1] - s[i - 1][j + r - 1] + s[i - 1][j - 1];    &#x2F;&#x2F;         res &#x3D; max(res, tar);    &#x2F;&#x2F;     &#125;    &#x2F;&#x2F; &#125;    cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;</code></pre><h4 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h4><ul><li><p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>∗</mo><msub><mi>y</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(x_{max} * y_{max})}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> 。</p></li><li><p>空间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo>∗</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(N * N)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span>。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法竞赛进阶指南</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法竞赛进阶指南-11.分形之城</title>
    <link href="/2023/01/11/Algorithm/Comp/20230111-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-011-%E5%88%86%E5%BD%A2%E4%B9%8B%E5%9F%8E/"/>
    <url>/2023/01/11/Algorithm/Comp/20230111-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-011-%E5%88%86%E5%BD%A2%E4%B9%8B%E5%9F%8E/</url>
    
    <content type="html"><![CDATA[<h3 id="题目链接"><a class="markdownIt-Anchor" href="#题目链接"></a> 题目链接</h3><p><a href="https://www.acwing.com/problem/content/91/">算法竞赛进阶指南-1.a^b</a></p><h3 id="method-位运算-二进制拆分"><a class="markdownIt-Anchor" href="#method-位运算-二进制拆分"></a> Method : 位运算-二进制拆分</h3><p>基础位运算，本题是快速幂的模板题。</p><p>注意两点:</p><ol><li>有取模运算时不要用自乘<code>*=</code>， 否则会影响计算顺序</li><li>return 时也要取模， 防止极端例子:<code>n = 0</code>且<code>p = 1</code></li></ol><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;LL a, b, p;LL fast_pow(LL x, LL n) &#123;    LL res &#x3D; 1LL;    while (n) &#123;        if (n &amp; 1) &#123;            res &#x3D; res * x % p;        &#125;        x &#x3D; x * x % p;        n &#x3D; n &gt;&gt; 1;    &#125;    return res % p;&#125;int main() &#123;    cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;    cout &lt;&lt; fast_pow(a, b) &lt;&lt; endl;    return 0;&#125;</code></pre><h4 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h4><ul><li><p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(log_2n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>， 其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span>为对n进行二进制拆分的时间复杂度。</p></li><li><p>空间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法竞赛进阶指南</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法竞赛进阶指南-10.约数之和</title>
    <link href="/2023/01/10/Algorithm/Comp/20230110-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-010-%E7%BA%A6%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2023/01/10/Algorithm/Comp/20230110-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-010-%E7%BA%A6%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="题目链接"><a class="markdownIt-Anchor" href="#题目链接"></a> 题目链接</h3><p><a href="https://www.acwing.com/problem/content/99/">算法竞赛进阶指南-10.约数之和</a></p><h3 id="method"><a class="markdownIt-Anchor" href="#method"></a> Method :</h3><p>可以参考算法基础课的模板题: <a href="https://www.acwing.com/problem/content/872/">约数之和</a></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;unordered_map&gt;#include &lt;iostream&gt;using namespace std;typedef long long LL;const int MOD &#x3D; 9901;int a, b;unordered_map&lt;int, int&gt; primes;LL fast_pow(LL a, LL b) &#123;    LL res &#x3D; 1LL;    while (b) &#123;        if (b &amp; 1) &#123;            res &#x3D; (LL)res * a % MOD;        &#125;        a &#x3D; (LL)a * a % MOD;        b &#x3D; b &gt;&gt; 1;    &#125;    return res % MOD;&#125;int sum(int p, int k) &#123;    if (k &#x3D;&#x3D; 1) return 1;    if (k % 2 &#x3D;&#x3D; 0) &#123;        return (LL)(fast_pow(p, k&#x2F; 2) + 1) * sum(p, k &#x2F; 2) % MOD;    &#125;    else &#123;        return (LL)(fast_pow(p, k - 1) + sum(p, k - 1)) % MOD;    &#125;&#125;int main() &#123;    cin &gt;&gt; a &gt;&gt; b;    for (int i &#x3D; 2; i &lt;&#x3D; a &#x2F; i; i ++) &#123;        while (a % i &#x3D;&#x3D; 0) &#123;            a &#x2F;&#x3D; i;            primes[i] ++;        &#125;    &#125;    if (a &gt; 1) primes[a] ++;    LL res &#x3D; 1;    for (auto&amp; prime : primes) &#123;        int p &#x3D; prime.first, k &#x3D; prime.second * b;        res &#x3D; res * sum(p, k + 1) % MOD;    &#125;    if (a &#x3D;&#x3D; 0) res &#x3D; 0;    cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;</code></pre><h4 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h4><ul><li><p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(log_2n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>， 其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span>为对n进行二进制拆分的时间复杂度。</p></li><li><p>空间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法竞赛进阶指南</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法竞赛进阶指南-9.奇怪的汉诺塔</title>
    <link href="/2023/01/09/Algorithm/Comp/20230109-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-009-%E5%A5%87%E6%80%AA%E7%9A%84%E6%B1%89%E8%AF%BA%E5%A1%94/"/>
    <url>/2023/01/09/Algorithm/Comp/20230109-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-009-%E5%A5%87%E6%80%AA%E7%9A%84%E6%B1%89%E8%AF%BA%E5%A1%94/</url>
    
    <content type="html"><![CDATA[<h3 id="题目链接"><a class="markdownIt-Anchor" href="#题目链接"></a> 题目链接</h3><p><a href="https://www.acwing.com/problem/content/98/">算法竞赛进阶指南-9.奇怪的汉诺塔</a></p><h3 id="method-dp-递推"><a class="markdownIt-Anchor" href="#method-dp-递推"></a> Method : DP + 递推</h3><p>首先要明白，每多一个塔，搬运次数必定减少：比如n个盘，n个塔，只需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2(n - 1) + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>次。</p><p>因此，关键在于怎么把4塔问题转化为3塔问题:</p><p>4塔: A   B   C   D</p><p>先把i个盘子放到B塔，然后关注剩下n - i个盘子放到A C D塔，怎么放搬运次数最少=&gt;这样转为3塔问题。</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>∗</mo><mn>2</mn><mo>+</mo><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{f[i] = min (f[i], f[j] * 2 + d[i - j])}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N &#x3D; 12 + 7;int d[N];  &#x2F;&#x2F; 三塔int f[N];  &#x2F;&#x2F; 四塔int main() &#123;        d[1] &#x3D; 1;    for (int i &#x3D; 2; i &lt;&#x3D; 12; i ++) &#123;        d[i] &#x3D; d[i -1] * 2 + 1;    &#125;        memset(f, 0x3f, sizeof f);    f[1] &#x3D; 1;    for (int i &#x3D; 2; i &lt;&#x3D; 12; i ++) &#123;        for (int j &#x3D; 0; j &lt; i; j ++) &#123;            f[i] &#x3D; min(f[i], f[j] * 2 + d[i - j]); &#x2F;&#x2F;依赖3塔min        &#125;    &#125;         for (int i &#x3D; 1; i &lt;&#x3D; 12; i ++) &#123;        printf(&quot;%d\n&quot;, f[i]);    &#125;        return 0;&#125;&#96;</code></pre><h4 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h4><ul><li><p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(n^2)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>， 其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>的DP双重循环。</p></li><li><p>空间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>。</p></li></ul><h3 id="ps"><a class="markdownIt-Anchor" href="#ps"></a> PS</h3><p>推广到5塔，首先是要求出4塔的最小搬运次数，然后再转化为3塔。依次类推求n塔。</p><p>5塔问题转化为4塔问题，4塔问题转化为3塔问题…</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N &#x3D; 12 + 7;int d[N];  &#x2F;&#x2F; 三塔int f[N];  &#x2F;&#x2F; 四塔int g[N];  &#x2F;&#x2F; 五塔int main() &#123;        d[1] &#x3D; 1;    for (int i &#x3D; 2; i &lt;&#x3D; 12; i ++) &#123;        d[i] &#x3D; d[i -1] * 2 + 1;    &#125;        memset(f, 0x3f, sizeof f);    f[1] &#x3D; 1;    for (int i &#x3D; 2; i &lt;&#x3D; 12; i ++) &#123;        for (int j &#x3D; 0; j &lt; i; j ++) &#123;            f[i] &#x3D; min(f[i], f[j] * 2 + d[i - j]); &#x2F;&#x2F;依赖3塔min        &#125;    &#125;        memset(g, 0x3f, sizeof g);    g[1] &#x3D; 1;        for (int i &#x3D; 2; i &lt;&#x3D; 12; i ++) &#123;        for (int j &#x3D; 0; j &lt; i; j ++) &#123;            g[i] &#x3D; min(g[i], g[j] * 2 + f[i - j]); &#x2F;&#x2F;依赖4塔min        &#125;    &#125;        for (int i &#x3D; 1; i &lt;&#x3D; 12; i ++) &#123;        printf(&quot;%d\n&quot;, e[i]);    &#125;        return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法竞赛进阶指南</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法竞赛进阶指南-8.费解的开关</title>
    <link href="/2023/01/08/Algorithm/Comp/20230108-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-008-%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3/"/>
    <url>/2023/01/08/Algorithm/Comp/20230108-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-008-%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h3 id="题目链接"><a class="markdownIt-Anchor" href="#题目链接"></a> 题目链接</h3><p><a href="https://www.acwing.com/problem/content/95/">算法竞赛进阶指南-8.费解的开关</a></p><h3 id="method1-位运算枚举递推"><a class="markdownIt-Anchor" href="#method1-位运算枚举递推"></a> Method1 : 位运算+枚举+递推</h3><ul><li>对第一行所有灯按不按的所有情况的枚举<ul><li>以保证第一行为全1为目的，用第一行的当前状态确定第二行的按法，接下来每行依次类推</li><li>当最后一行没法全1，说明不满足</li></ul></li></ul><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N &#x3D; 5 + 7;const int INF &#x3D; 0x3f3f3f3f;const int dir[5][2] &#x3D; &#123;&#123;0, 0&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;&#125;;char graph[N][N];&#x2F;&#x2F; 开关void turn(int x, int y) &#123;     for (auto d : dir) &#123;        int xn &#x3D; x + d[0];        int yn &#x3D; y + d[1];        if (0 &lt;&#x3D; xn &amp;&amp; xn &lt; 5 &amp;&amp; 0 &lt;&#x3D; yn &amp;&amp; yn &lt; 5) &#123;            graph[xn][yn] ^&#x3D; 1; &#x2F;&#x2F; 异或配对        &#125;    &#125;&#125;int main() &#123;    int m;     cin &gt;&gt; m;    while (m --) &#123;        for (int i &#x3D; 0; i &lt; 5; i ++) &#123;            scanf(&quot;%s&quot;, graph[i]);        &#125;                &#x2F;&#x2F;枚举        int res &#x3D; INF;        for (int k &#x3D; 0; k &lt; 1 &lt;&lt; 5; k ++) &#123;            char backup[N][N];            memcpy(backup, graph, sizeof graph);                        int cnt &#x3D; 0;            for (int j &#x3D; 0; j &lt; 5; j ++) &#123;                if (k &gt;&gt; j &amp; 1) &#123;                    turn(0, j);                    cnt ++;                &#125;            &#125;                        &#x2F;&#x2F; 根据第一行递推            for (int i &#x3D; 0; i &lt; 4; i ++) &#123;                for (int j &#x3D; 0; j &lt; 5; j ++) &#123;                    if (graph[i][j] &#x3D;&#x3D; &#39;0&#39;) &#123;                        turn(i + 1, j);                        cnt ++;                    &#125;                   &#125;            &#125;                        bool flag &#x3D; true;            for (int j &#x3D; 0; j &lt; 5; j ++) &#123;                if (graph[4][j] &#x3D;&#x3D; &#39;0&#39;) &#123;                    flag &#x3D; false;                    break;                &#125;            &#125;                        if(flag) res &#x3D; min(res, cnt);            memcpy(graph, backup, sizeof backup);        &#125;                if (res &lt;&#x3D; 6) cout &lt;&lt; res &lt;&lt; endl;        else cout &lt;&lt; -1 &lt;&lt; endl;    &#125;        return 0;&#125;</code></pre><h4 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h4><ul><li><p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>∗</mo><mn>32</mn><mo>∗</mo><mo stretchy="false">(</mo><mn>25</mn><mo>∗</mo><mn>5</mn><mo>+</mo><mn>5</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(m * 32 * (25 * 5 + 5))}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">5</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span>， 其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>为m次询问，32为第一行的枚举，25 为棋盘, *5为按开关的dir[5]个方向， +5为判断最后一行， 还要额外加上两次memcpy的时间复杂度（O(5 * 5)）。</p></li><li><p>空间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>。</p></li></ul><h3 id="method2-广度优先遍历-递归"><a class="markdownIt-Anchor" href="#method2-广度优先遍历-递归"></a> Method2 : 广度优先遍历-递归</h3><p>我的最初想法 ： 把图转为25位的数来做，利用 i * n + j，确定当前位数，然后判dfs判断6步以内能否出现25个1， 但这样也要注意上下左右的变法</p><h4 id="复杂度分析-2"><a class="markdownIt-Anchor" href="#复杂度分析-2"></a> 复杂度分析</h4>]]></content>
    
    
    <categories>
      
      <category>算法竞赛进阶指南</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>递归</tag>
      
      <tag>递推</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法竞赛进阶指南-7.递归实现排列型枚举</title>
    <link href="/2023/01/07/Algorithm/Comp/20230107-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-007-%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%88%97%E5%9E%8B%E6%9E%9A%E4%B8%BE/"/>
    <url>/2023/01/07/Algorithm/Comp/20230107-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-007-%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%88%97%E5%9E%8B%E6%9E%9A%E4%B8%BE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>排列的有序性用无序的for循环实现(并且需要visited数组辅助)</p><p>组合的无序性用有序的01选择实现</p></blockquote><h3 id="题目链接"><a class="markdownIt-Anchor" href="#题目链接"></a> 题目链接</h3><p><a href="https://www.acwing.com/problem/content/96/">算法竞赛进阶指南-7.递归实现排列型枚举</a></p><p>把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>∼</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">{1∼n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">n</span></span></span></span></span> 这 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span></span>个整数排成一行后随机打乱顺序，输出所有可能的次序 =&gt; n个数的全排列，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>A</mi><mi>n</mi><mi>n</mi></msubsup></mrow><annotation encoding="application/x-tex">{A_n^n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93033em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>同一行相邻两个数用一个空格隔开</p><p>对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面</p><h3 id="method-递归"><a class="markdownIt-Anchor" href="#method-递归"></a> Method : 递归</h3><p>要记住用一个全局数组就能输出所有的排列情况。</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const int N &#x3D; 10;int n;vector&lt;int&gt; choosen;bool visited[N] &#x3D; &#123;0&#125;;void dfs(int depth) &#123;    if (depth &#x3D;&#x3D; n + 1) &#123;        for (int i &#x3D; 0; i &lt; choosen.size(); i ++) &#123;            printf(&quot;%d &quot;, choosen[i]);        &#125;        cout &lt;&lt; endl;        return;    &#125;        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++) &#123;        if (!visited[i]) &#123;            visited[i] &#x3D; true;            choosen.emplace_back(i);            dfs(depth + 1);            &#x2F;&#x2F; 回溯            choosen.pop_back();            visited[i] &#x3D; false;        &#125;    &#125;&#125;int main() &#123;    cin &gt;&gt; n;    dfs(1);    return 0;&#125;</code></pre><h4 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h4><ul><li><p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(n!)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span></span>， 由于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>e</mi><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">vistied[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>数组，每次递归的循环执行次数会减1。并且很明显<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>A</mi><mi>n</mi><mi>n</mi></msubsup></mrow><annotation encoding="application/x-tex">A_{n}^{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93033em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>在数学上是相通的。</p></li><li><p>空间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(N)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span>, choosen数组。</p></li></ul><h3 id="拓展-求a_nm"><a class="markdownIt-Anchor" href="#拓展-求a_nm"></a> 拓展 求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>A</mi><mi>n</mi><mi>m</mi></msubsup></mrow><annotation encoding="application/x-tex">{A_n^m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93033em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></h3><h3 id="method1-递归"><a class="markdownIt-Anchor" href="#method1-递归"></a> Method1 : 递归</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const int N &#x3D; 10;int n, m;vector&lt;int&gt; choosen;bool visited[N] &#x3D; &#123;0&#125;;void dfs(int depth, int select) &#123;    &#x2F;&#x2F; 剪枝    if (select &gt; m || n + 1 - depth &lt; m - select) &#123;        return;    &#125;        &#x2F;&#x2F; 递归边界    if (select &#x3D;&#x3D; m) &#123;        for (int i &#x3D; 0; i &lt; choosen.size(); i ++) &#123;            printf(&quot;%d &quot;, choosen[i]);        &#125;        cout &lt;&lt; endl;             return;    &#125;    if (depth &#x3D;&#x3D; n + 1) return;        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++) &#123;        if (!visited[i]) &#123;            visited[i] &#x3D; true;            choosen.emplace_back(i);            dfs(depth + 1, select + 1);            &#x2F;&#x2F; 回溯            choosen.pop_back();            visited[i] &#x3D; false;        &#125;    &#125;&#125;int main() &#123;    cin &gt;&gt; n &gt;&gt; m;    dfs(1, 0);    return 0;&#125;</code></pre><h4 id="复杂度分析-2"><a class="markdownIt-Anchor" href="#复杂度分析-2"></a> 复杂度分析</h4><h3 id="method2-a_nm-c_nm-a_mm"><a class="markdownIt-Anchor" href="#method2-a_nm-c_nm-a_mm"></a> Method2 : <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>A</mi><mi>n</mi><mi>m</mi></msubsup></mrow><annotation encoding="application/x-tex">{A_n^m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93033em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span> = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mi>m</mi></msubsup></mrow><annotation encoding="application/x-tex">{C_n^m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93033em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span> * <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>A</mi><mi>m</mi><mi>m</mi></msubsup></mrow><annotation encoding="application/x-tex">{A_m^m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93033em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></h3><p>利用公式定义：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>A</mi><mi>n</mi><mi>m</mi></msubsup></mrow><annotation encoding="application/x-tex">{A_n^m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93033em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span> = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mi>m</mi></msubsup></mrow><annotation encoding="application/x-tex">{C_n^m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93033em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span> * <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>A</mi><mi>m</mi><mi>m</mi></msubsup></mrow><annotation encoding="application/x-tex">{A_m^m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93033em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>那么可以拆解成两个bfs，嵌套来做:</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const int N &#x3D; 10;int n, m;vector&lt;int&gt; proposal;vector&lt;int&gt; choosen;bool visited[N] &#x3D; &#123;0&#125;;&#x2F;&#x2F; Ammvoid dfs2 (int depth) &#123;    if (depth &#x3D;&#x3D; m + 1) &#123;        for (int i &#x3D; 0; i &lt; choosen.size(); i ++) &#123;            printf(&quot;%d &quot;, choosen[i]);        &#125;        cout &lt;&lt; endl;        return;    &#125;        for (int i &#x3D; 0; i &lt; proposal.size(); i ++) &#123;        if (!visited[proposal[i]]) &#123;            visited[proposal[i]] &#x3D; true;            choosen.emplace_back(proposal[i]);            dfs2(depth + 1);            &#x2F;&#x2F; 回溯            choosen.pop_back();            visited[proposal[i]] &#x3D; false;        &#125;    &#125;&#125;&#x2F;&#x2F; Cnmvoid dfs1(int depth, int select) &#123;    &#x2F;&#x2F; 剪枝    if (select &gt; m || n + 1 - depth &lt; m - select) &#123;        return;    &#125;        &#x2F;&#x2F; 递归边界    if (select &#x3D;&#x3D; m) &#123;        dfs2(1);          return;    &#125;    if (depth &#x3D;&#x3D; n + 1) return;        proposal.emplace_back(depth);    dfs1(depth + 1, select + 1);    &#x2F;&#x2F; 回溯    proposal.pop_back();    dfs1(depth + 1, select);&#125;int main() &#123;    cin &gt;&gt; n &gt;&gt; m;    dfs1(1, 0);    cout &lt;&lt; cnt;    return 0;&#125;</code></pre><h4 id="复杂度分析-3"><a class="markdownIt-Anchor" href="#复杂度分析-3"></a> 复杂度分析</h4><p>注意Method1和Method2的输出字典序顺序不同。</p>]]></content>
    
    
    <categories>
      
      <category>算法竞赛进阶指南</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法竞赛进阶指南-6.递归实现组合型枚举</title>
    <link href="/2023/01/06/Algorithm/Comp/20230106-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-006-%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E7%BB%84%E5%90%88%E5%9E%8B%E6%9E%9A%E4%B8%BE/"/>
    <url>/2023/01/06/Algorithm/Comp/20230106-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-006-%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E7%BB%84%E5%90%88%E5%9E%8B%E6%9E%9A%E4%B8%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="题目链接"><a class="markdownIt-Anchor" href="#题目链接"></a> 题目链接</h3><p><a href="https://www.acwing.com/problem/content/95/">算法竞赛进阶指南-6.递归实现组合型枚举</a></p><p>从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>∼</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">{1∼n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">n</span></span></span></span></span> 这 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span></span> 个整数中随机选出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span></span></span> 个，输出所有可能的选择方案 =&gt;  即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mi>m</mi><mi>n</mi></msubsup></mrow><annotation encoding="application/x-tex">{C_{m}^{n}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93033em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>同一行内的数升序排列，相邻两个数用一个空格隔开</p><p>对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面</p><h3 id="method-递归"><a class="markdownIt-Anchor" href="#method-递归"></a> Method : 递归</h3><p>本题相较上一个题目，多一个(select == m)的条件。</p><p>其次，可以使用剪枝去优化时空复杂度，<code>n + 1 - depth &lt; m - select</code> 是表示剩下的数量 &lt; 要选的数量。</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int n, m;vector&lt;int&gt; choosen;void dfs(int depth, int select) &#123;    &#x2F;&#x2F; 剪枝    if (select &gt; m || n + 1 - depth &lt; m - select) &#123;        return;    &#125;        &#x2F;&#x2F; 递归边界    if (select &#x3D;&#x3D; m) &#123;          for (int i &#x3D; 0; i &lt; choosen.size(); i ++) &#123;           printf(&quot;%d &quot;, choosen[i]);        &#125;        cout &lt;&lt; endl;        return;    &#125;    if (depth &#x3D;&#x3D; n + 1) return;            choosen.emplace_back(depth);    dfs(depth + 1, select + 1);    &#x2F;&#x2F; 回溯    choosen.pop_back();    dfs(depth + 1, select);&#125;int main() &#123;    cin &gt;&gt; n &gt;&gt; m;    dfs(1, 0);    return 0;&#125;</code></pre><h4 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h4><ul><li><p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(mlog_2n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>， 其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span>为递归函数栈的深度。 但由于剪枝，实际时间复杂度会小于该理论时间复杂度。</p></li><li><p>空间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(m)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></span>,数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>h</mi><mi>o</mi><mi>o</mi><mi>s</mi><mi>e</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">{choosen}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span></span></span></span></span>的空间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span></span></span>，另外递归函数栈会花费额外常数级空间。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法竞赛进阶指南</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法竞赛进阶指南-5.递归实现指数型枚举</title>
    <link href="/2023/01/05/Algorithm/Comp/20230105-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-005-%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8C%87%E6%95%B0%E5%9E%8B%E6%9E%9A%E4%B8%BE/"/>
    <url>/2023/01/05/Algorithm/Comp/20230105-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-005-%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8C%87%E6%95%B0%E5%9E%8B%E6%9E%9A%E4%B8%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="题目链接"><a class="markdownIt-Anchor" href="#题目链接"></a> 题目链接</h3><p><a href="https://www.acwing.com/problem/content/94/">算法竞赛进阶指南-5.递归实现指数型枚举</a></p><p>从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>∼</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1∼n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>这 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个整数中随机选取任意多个，输出所有可能的选择方案。</p><p>同一行内的数必须升序排列，相邻两个数用恰好1个空格隔开</p><h3 id="method-递归"><a class="markdownIt-Anchor" href="#method-递归"></a> Method : 递归</h3><p>你的疑惑是什么？</p><p>只用一个数组能输出多种结果么？ =&gt; 可以</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int n;vector&lt;int&gt; choosen;void dfs(int depth) &#123;    &#x2F;&#x2F; 递归边界,输出结果    if (depth &#x3D;&#x3D; n + 1) &#123;        for (int i &#x3D; 0; i &lt; choosen.size(); i ++) &#123;            printf(&quot;%d &quot;, choosen[i]);        &#125;        cout &lt;&lt; endl;        return;    &#125;        &#x2F;&#x2F; 构造选或不选的递归二叉树    choosen.emplace_back(depth);    dfs(depth + 1);    &#x2F;&#x2F; 回溯    choosen.pop_back();    dfs(depth + 1);&#125;int main() &#123;    cin &gt;&gt; n;    dfs(1);     return 0;&#125;</code></pre><h4 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h4><ul><li><p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(nlog_2n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>， 其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span>为递归函数栈的深度，外层<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>为打印数组的循环次数。</p></li><li><p>空间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>， 数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>h</mi><mi>o</mi><mi>o</mi><mi>s</mi><mi>e</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">{choosen}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span></span></span></span></span>的空间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span></span>，另外递归函数栈会花费额外常数级空间。</p></li></ul><h3 id="method-递归-位运算"><a class="markdownIt-Anchor" href="#method-递归-位运算"></a> Method : 递归 + 位运算</h3><p>使用位运算可以把choosen数组优化</p>]]></content>
    
    
    <categories>
      
      <category>算法竞赛进阶指南</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>位运算</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法竞赛进阶指南-4.起床困难综合症</title>
    <link href="/2023/01/04/Algorithm/Comp/20230104-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-004-%E8%B5%B7%E5%BA%8A%E5%9B%B0%E9%9A%BE%E7%BB%BC%E5%90%88%E7%97%87/"/>
    <url>/2023/01/04/Algorithm/Comp/20230104-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-004-%E8%B5%B7%E5%BA%8A%E5%9B%B0%E9%9A%BE%E7%BB%BC%E5%90%88%E7%97%87/</url>
    
    <content type="html"><![CDATA[<h3 id="题目链接"><a class="markdownIt-Anchor" href="#题目链接"></a> 题目链接</h3><p><a href="https://www.acwing.com/problem/content/1000/">算法竞赛进阶指南-4.起床困难综合症</a></p><h3 id="method-位运算-贪心"><a class="markdownIt-Anchor" href="#method-位运算-贪心"></a> Method : 位运算-贪心</h3><p>首先，很容易想到暴力的做法：枚举每一个m，进行n次操作，然后记录最大值:</p><pre class="language-c++" data-language="c++"><code class="language-c++">for (int i &#x3D; 1; i &lt;&#x3D; m; i ++) &#123;    for (int j &#x3D; 1; j &lt;&#x3D; n; j ++) &#123;        if (op[j] &#x3D;&#x3D; &quot;XOR&quot;) &#123;            i &#x3D; i ^ t[j];        &#125;        else if (...) &#123;            &#x2F;&#x2F; ...        &#125;    &#125;    if (i &gt; max_i) &#x2F;&#x2F; ...&#125;</code></pre><p>但是这样时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，是不可取的。</p><hr /><p>而不难发现<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>N</mi><mi>D</mi><mo separator="true">,</mo><mi>X</mi><mi>O</mi><mi>R</mi><mo separator="true">,</mo><mi>O</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">{AND,XOR, OR}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span></span>这三个操作，参与位运算时，各个位之间是独立无关的。<br />因此，为了保证res取最大值，可以从高位到低位考虑，输入的x的每一位填0还是1，并且要尽量保证操作完后的数的高位是1(贪心)。</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;bitset&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;const int M &#x3D; 31;int n , m ;int main() &#123;    bitset&lt;M&gt; zero , one ;    zero.reset(); &#x2F;&#x2F; 一个初始化每一位都是0    one.set();    &#x2F;&#x2F; 一个初始化每一位都是1    cin &gt;&gt; n &gt;&gt; m ;        while(n --) &#123;        string x ;        int y ;        cin &gt;&gt; x &gt;&gt; y ;                if (x &#x3D;&#x3D; &quot;AND&quot;) zero &amp;&#x3D; y , one &amp;&#x3D; y ;        else if (x &#x3D;&#x3D; &quot;OR&quot;) zero |&#x3D; y , one |&#x3D; y ;        else if (x &#x3D;&#x3D; &quot;XOR&quot;) zero ^&#x3D; y , one ^&#x3D; y ;    &#125;        int ans &#x3D; 0; int val &#x3D; 0;    for(int i &#x3D; M ; i &gt;&#x3D; 0 ; i --) &#123;        if(zero[i] &#x3D;&#x3D; 1) &#123;            ans +&#x3D; (1 &lt;&lt; i);          &#125;        else if(one[i] &#x3D;&#x3D; 1 &amp;&amp; val + (1 &lt;&lt; i) &lt;&#x3D; m) &#123;            val +&#x3D; (1 &lt;&lt; i);            ans +&#x3D; (1 &lt;&lt; i);         &#125;    &#125;        cout &lt;&lt; ans &lt;&lt; endl;        return 0;&#125;</code></pre><h4 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h4><ul><li><p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(nlog_2m)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></span>， 其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>m</mi></mrow><annotation encoding="application/x-tex">log_2m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">m</span></span></span></span>为对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>逐位判断的时间复杂度，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>次操作。</p></li><li><p>空间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法竞赛进阶指南</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法竞赛进阶指南-3.最短Hamilton路径</title>
    <link href="/2023/01/03/Algorithm/Comp/20230103-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-003-%E6%9C%80%E7%9F%ADHamilton%E8%B7%AF%E5%BE%84/"/>
    <url>/2023/01/03/Algorithm/Comp/20230103-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-003-%E6%9C%80%E7%9F%ADHamilton%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h3 id="题目链接"><a class="markdownIt-Anchor" href="#题目链接"></a> 题目链接</h3><p><a href="https://www.acwing.com/problem/content/93/">算法竞赛进阶指南-3.最短Hamilton路径</a></p><p>汉密尔顿路径是一道旅行商问题，已被证明是NP-Hard问题，无法在多项式级别的复杂度求出。</p><p>如果用暴力来做，首先要枚举所有路径，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mi mathvariant="normal">，</mi><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">{0，n - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span></span>  相当于求n个点的全排列，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span></span></span></span>，<br />然后枚举完之后要遍历一次，求整体的路径长度， 即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo>∗</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(n! * n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>，这个时间复杂度太高了。</p><h3 id="method-状态压缩dp"><a class="markdownIt-Anchor" href="#method-状态压缩dp"></a> Method : 状态压缩DP</h3><blockquote><p>不难发现状态是比较多的，但对于每一个节点，都只关心0(未访问)和1(已访问)这两种状态。</p><p>因此可以考虑用一个N位2进制数来表示状态集合，用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><msup><mn>2</mn><mi>N</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 2 ^N - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>之间的一个十进制数形式表示DP状态的其中一维。</p></blockquote><p><strong>状态表示</strong> ：所有从0走到j，走过的所有点的情况是i的所有路径， 求min。</p><p><strong>状态划分</strong> ：枚举上一个状态，即0-&gt;·····–&gt;k–&gt;j中k的所有可能情况。</p><p><strong>状态转移</strong>：枚举走到j点前的一个状态=&gt;[<code>i - (1 &lt;&lt; j)</code>能把 <code>i</code>的第 <code>j</code>位 置为<code>0</code>]</p><p>上一个状态中的所处的位置，可能是 <code>i - (1 &lt;&lt; j)</code>中任意一个是1的数位k,从k到j需要花费<code>g[k][j]</code></p><p>因此 <code>f[i][j] = min(f[i][j], f[i - (1 &lt;&lt; j)][k] + g[k][j])</code></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 20;const int M &#x3D; 1 &lt;&lt; N; &#x2F;&#x2F; int一共32位&#x2F;&#x2F;无向图int g[N][N];&#x2F;&#x2F;状态int f[M][N];int n;int main() &#123;    cin &gt;&gt; n;        for (int i &#x3D; 0; i &lt; n; i ++) &#123;        for (int j &#x3D; 0; j &lt; n; j ++) &#123;            scanf(&quot;%d&quot;, &amp;g[i][j]);        &#125;    &#125;        &#x2F;&#x2F; 起点0 &#x3D;&gt; 二进制表示: 00...01    memset(f, 0x3f, sizeof f);    f[1][0] &#x3D; 0;        for (int i &#x3D; 0; i &lt; 1 &lt;&lt; n; i ++) &#123;        for (int j &#x3D; 0; j &lt; n; j ++) &#123;            &#x2F;&#x2F; 如果i的第j位是1，说明j点可达            if (i &gt;&gt; j &amp; 1) &#123;                &#x2F;&#x2F; 枚举走到j点前的一个状态,以k为终点的最短距离                for (int k &#x3D; 0; k &lt; n; k ++) &#123;                    &#x2F;&#x2F; i - (1 &lt;&lt; j)为走到j点的前一个状态,k是前一个状态中的可达点                    if (i - (1 &lt;&lt; j) &gt;&gt; k &amp; 1) &#123;                        f[i][j] &#x3D; min(f[i][j], f[i - (1 &lt;&lt; j)][k] + g[k][j]);                    &#125;                &#125;                            &#125;        &#125;    &#125;        cout &lt;&lt; f[(1 &lt;&lt; n) - 1][n - 1] &lt;&lt; endl;    return 0;&#125;</code></pre><h4 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h4><ul><li><p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>∗</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(2^n * n^2)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>为二进制状态压缩(i层循环)，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">{n^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>为枚举j层和枚举k层的两重循环。</p></li><li><p>空间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(n^2)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>，用于存储图<code>g[N][N]</code>。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法竞赛进阶指南</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法竞赛进阶指南-2.64位整数乘法</title>
    <link href="/2023/01/02/Algorithm/Comp/20230102-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-002-64%E4%BD%8D%E6%95%B4%E6%95%B0%E4%B9%98%E6%B3%95/"/>
    <url>/2023/01/02/Algorithm/Comp/20230102-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-002-64%E4%BD%8D%E6%95%B4%E6%95%B0%E4%B9%98%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="题目链接"><a class="markdownIt-Anchor" href="#题目链接"></a> 题目链接</h3><p><a href="https://www.acwing.com/problem/content/92/">算法竞赛进阶指南-2.64位整数乘法</a></p><h3 id="method-位运算-二进制拆分"><a class="markdownIt-Anchor" href="#method-位运算-二进制拆分"></a> Method : 位运算-二进制拆分</h3><p>基础位运算，类似于快速幂，用了倍增的思想:</p><blockquote><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∗</mo><mn>1</mn><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">{a * 1 = a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">a</span></span></span></span></span>;</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∗</mo><mn>2</mn><mo>=</mo><mn>2</mn><mi>a</mi></mrow><annotation encoding="application/x-tex">{a * 2 = 2a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">2</span><span class="mord mathdefault">a</span></span></span></span></span>;</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∗</mo><mn>4</mn><mo>=</mo><mn>4</mn><mi>a</mi></mrow><annotation encoding="application/x-tex">{a * 4 = 4a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">4</span><span class="mord mathdefault">a</span></span></span></span></span>;</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∗</mo><mn>8</mn><mo>=</mo><mn>8</mn><mi>a</mi></mrow><annotation encoding="application/x-tex">{a * 8 = 8a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">8</span><span class="mord mathdefault">a</span></span></span></span></span>;<br />…</p><p>对于任意一个b，都可以把b拆成一个2进制数表达</p><p>如：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9</mn><mo>=</mo><mo stretchy="false">(</mo><mn>1001</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mo>=</mo><mn>1</mn><mo>∗</mo><mn>8</mn><mo>+</mo><mn>0</mn><mo>∗</mo><mn>4</mn><mo>+</mo><mn>0</mn><mo>∗</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo>∗</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">{9 = (1001)_2 = 1 * 8 + 0 * 4 + 0 * 2 + 1 * 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">9</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span></span></p></blockquote><p>注意两点:</p><ol><li>有取模运算时不要用自加<code>+=</code>， 否则会影响计算顺序</li><li>return 时也要取模， 防止极端例子:<code>b = 0</code>且<code>p = 1</code></li></ol><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef unsigned long long LL;LL a, b, p;LL int64_mul(LL a, LL b) &#123;    LL res &#x3D; 0LL;    while (b) &#123;        if (b &amp; 1) &#123;            res &#x3D; (res + a) % p;        &#125;        a &#x3D; (a + a) % p;        b &#x3D; b &gt;&gt; 1;    &#125;    return res % p;&#125;int main() &#123;    cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;    cout &lt;&lt; int64_mul(a, b) &lt;&lt; endl;    return 0;&#125;</code></pre><h4 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h4><ul><li><p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(log_2b)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></span>， 其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>b</mi></mrow><annotation encoding="application/x-tex">log_2b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">b</span></span></span></span>为对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>进行二进制拆分的时间复杂度。</p></li><li><p>空间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法竞赛进阶指南</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法竞赛进阶指南-1.a^b</title>
    <link href="/2023/01/01/Algorithm/Comp/20230101-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-001-a%5Eb/"/>
    <url>/2023/01/01/Algorithm/Comp/20230101-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-001-a%5Eb/</url>
    
    <content type="html"><![CDATA[<h3 id="题目链接"><a class="markdownIt-Anchor" href="#题目链接"></a> 题目链接</h3><p><a href="https://www.acwing.com/problem/content/91/">算法竞赛进阶指南-1.a^b</a></p><h3 id="method-位运算-二进制拆分"><a class="markdownIt-Anchor" href="#method-位运算-二进制拆分"></a> Method : 位运算-二进制拆分</h3><p>基础位运算，本题是快速幂的模板题。</p><p>注意两点:</p><ol><li>有取模运算时不要用自乘<code>*=</code>， 否则会影响计算顺序</li><li>return 时也要取模， 防止极端例子:<code>n = 0</code>且<code>p = 1</code></li></ol><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;LL a, b, p;LL fast_pow(LL x, LL n) &#123;    LL res &#x3D; 1LL;    while (n) &#123;        if (n &amp; 1) &#123;            res &#x3D; res * x % p;        &#125;        x &#x3D; x * x % p;        n &#x3D; n &gt;&gt; 1;    &#125;    return res % p;&#125;int main() &#123;    cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;    cout &lt;&lt; fast_pow(a, b) &lt;&lt; endl;    return 0;&#125;</code></pre><h4 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h4><ul><li><p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(log_2n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>， 其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span>为对n进行二进制拆分的时间复杂度。</p></li><li><p>空间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法竞赛进阶指南</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>H2RBox</title>
    <link href="/2022/11/21/AI-Learning/20221121-H2RBox/"/>
    <url>/2022/11/21/AI-Learning/20221121-H2RBox/</url>
    
    <content type="html"><![CDATA[<h1 id="h2rbox"><a class="markdownIt-Anchor" href="#h2rbox"></a> H2RBox</h1><h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2><p><strong>论文题目</strong> ：HORIZONTAL BOX ANNOTATION IS ALL YOU NEED FOR ORIENTED OBJECT DETECTION</p><p><strong>论文地址</strong> ：<a href="https://arxiv.org/abs/2210.06742">https://arxiv.org/abs/2210.06742</a></p><p><strong>论文出处</strong> ：arxiv 2022.10</p><p><strong>代码实现</strong> ：<a href="https://github.com/yangxue0827/h2rbox-mmrotate">https://github.com/yangxue0827/h2rbox-mmrotate</a></p><h2 id="idea"><a class="markdownIt-Anchor" href="#idea"></a> Idea</h2><p>现在很多目标检测数据集的annotation都是基于水平边界框的注释，但是水平框数据集不能直接用于旋转检测器的训练，这就导致现成的数据集和不断增长的旋转目标检测需求之间存在gap。因此作者提出了一种HBox-to-RBox style method(H2RBox)，使用水平框进行弱监督学习，并且采用无监督学习辅助修正尺度和空间上的一致性，来预测对象角度。</p><p>SKU110K  (零售场景数据集， 2019) = &gt; SKU110K-R  (2020)<br />DIOR  (航空数据集 2020)  =&gt;  DIOR-R  (2022)</p><p>这两个数据集一开始是水平框标注的，然后后面为了做旋转目标检测而特地使用旋转框重新标注。</p><h2 id="detail"><a class="markdownIt-Anchor" href="#detail"></a> Detail</h2><p>作者实验发现，通过一些用水平框弱监督的实例分割模型(BoxInst,  BoxLevelSet)，可以轻松获得分割掩码Mask，然后通过掩码的最小外接性，可以轻松获得最终的旋转框。作者称这种方法为HBox-Mask-RBox style methods.</p><p><img src="/img/article/2022/11/21/2.png" alt="" /></p><p>可以看到这个model也是一个二阶段的任务，而且第一阶段是实例分割，</p><p>如果直接引入实例分割，会带来以下问题:</p><ol><li>分割质量很可能对背景噪声敏感</li><li>在对象拥挤等复杂场景中，会严重影响后续RBox的检测步骤.</li><li>实例分割的计算成本往往更高，导致整个检测过程耗时更长。</li></ol><p>基于以上几点，作者提出了一种HBox-to-RBox style method(H2RBox)。想要跳过实例分割这个步骤，来构造一个HBox-to-RBox paradigm.</p><p><img src="/img/article/2022/11/21/3.png" alt="" /></p><p>具体来说:</p><ol><li><p>首先经过WS分支中的FCOS网络，得到预测的RBox<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>w</mi><mo separator="true">,</mo><mi>h</mi><mo separator="true">,</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, y ,w, h, \theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span></p></li><li><p>然后把输入的水平图像旋转一个随机角度，经过SS分支，然后同样回归得到子网络(FCOS)预测的RBox</p></li></ol><p>然后开始计算LOSS</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mrow><mi>c</mi><mi>l</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">{L_{cls}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>:  FCOS网络中的分类Loss</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mrow><mi>c</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">{L_{cn}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>:   FCOS网络中的center-ness loss，通过将class score与center-ness相乘后作为最终该预测框的score，从而降低了那些远离object中心点的预测框的权重，并进行NMS,去掉一些远离object的低质量检测框。</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mrow><mi>r</mi><mi>e</mi><mi>g</mi></mrow></msub></mrow><annotation encoding="application/x-tex">L_{reg}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>:  使用H2RBox的外接矩形与GT的HBox进行Loss计算.</p><blockquote><p>作者认为在理想情况下，WS分支的RBox的外接矩形和GT的HBox是高度重叠的。</p></blockquote><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mrow><mi>s</mi><mi>s</mi></mrow></msub><mo>:</mo></mrow><annotation encoding="application/x-tex">L_{ss}:</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span></span></span>   WS分支的RBox * Rotation Matrix后，与SS分支的RBox进行Loss计算。</p><blockquote><p>这个就是作者说的通过学习两个分支，不同视图的RBox的一致性(包括尺度和空间)，以消除undesired cases.</p></blockquote><p>测试阶段只涉及WS分支.</p><p>label re-assignment strategies  (label at location <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>∗</mo><mo separator="true">,</mo><mi>y</mi><mo>∗</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x*, y*)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">∗</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">∗</span><span class="mclose">)</span></span></span></span> in SS branch 旋转映射回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> in WS branch的策略)</p><p>简单贴一下Loss</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mrow><mi>c</mi><mi>l</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">{L_{cls}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>:  SoftMax Loss    <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mrow><mi>c</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">{L_{cn}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> :  Center-ness loss   <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mrow><mi>r</mi><mi>e</mi><mi>g</mi></mrow></msub></mrow><annotation encoding="application/x-tex">L_{reg}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>: Cross entropy Loss</p><p><img src="/img/article/2022/11/21/9.png" alt="" /></p><p><img src="/img/article/2022/11/21/10.png" alt="" /></p><p><img src="/img/article/2022/11/21/11.png" alt="" /></p><h2 id="result"><a class="markdownIt-Anchor" href="#result"></a> Result</h2><p>下面两张图对比，说明了但WS的效果不好，这也是为什么作者要引入SS分支。</p><p><img src="/img/article/2022/11/21/5.png" alt="" /></p><p><img src="/img/article/2022/11/21/6.png" alt="" /></p><p>下面是DOTA-v1.0数据集上的性能对比:</p><p><img src="/img/article/2022/11/21/7.png" alt="" /></p><p>下面是DIOR-R数据集上的性能对比:</p><p><img src="/img/article/2022/11/21/8.png" alt="" /></p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>不难发现，因为作者的这个方法原创性比较大，没有一个好的baseline，因此效果整体上来说不是很好。</p><p>作者的想法很好：怎么样把水平框数据集利用到旋转目标检测上来, more data, more powerful。</p><p>但我要研究的重点不是这个方面，因此可能帮助不是很大。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
      <tag>目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RBox</title>
    <link href="/2022/11/14/AI-Learning/20221114-RBox/"/>
    <url>/2022/11/14/AI-Learning/20221114-RBox/</url>
    
    <content type="html"><![CDATA[<h1 id="rbox"><a class="markdownIt-Anchor" href="#rbox"></a> RBox</h1><h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2><p><strong>论文题目</strong> ：Few Could Be Better Than All: Feature Sampling and Grouping for Scene Text Detection</p><p><strong>论文地址</strong> ：<a href="https://arxiv.org/abs/2203.15221v2">https://arxiv.org/abs/2203.15221v2</a></p><p><strong>论文出处</strong> ：2022’CVPR</p><p><strong>代码实现</strong> ：Not released.</p><h2 id="idea"><a class="markdownIt-Anchor" href="#idea"></a> Idea</h2><p>作者认为没有必要对所有像素的relationship进行特征学习。因为前景目标只占场景图像中的几个小而窄的区域。作者首先采样并收集与前景高度相关的特征，然后使用Tansformer建模来分析采样特征之间的关系，使得前景特征能被正确的分组。并且这样做可以免去anchor generation、NMS等后处理。</p><p><img src="/img/article/2022/11/14/2.png" alt="" /></p><h2 id="detail"><a class="markdownIt-Anchor" href="#detail"></a> Detail</h2><p><img src="/img/article/2022/11/14/3.png" alt="" /></p><p>首先通过一个Backbone network(Backbone: ResNet50 + neck: FPN)，得到多尺度特征图，然后送入MultiSale Text Extrator中，对多尺度特征逐层的进行以下两个步骤:a) 预测提取代表性的文本(前景)区域; b) 在前景区域进行像素级的预测置信度得分confidence scores，选取Top-N个点作为与前景高度相关的特征。然后送入Tansformer模块[具体进行位置编码(Position Embedding)，然后送到Transfromer Block)]进行关系建模=&gt;特征分组，让每一组对应一个实例。最后送入预测head回归出检测框，并进行分类。</p><h3 id="backbone"><a class="markdownIt-Anchor" href="#backbone"></a> Backbone</h3><p><img src="/img/article/2022/11/14/6.png" alt="" /></p><p>主要选取的是P2-P4 (1/4、1/8、1/16)进行特征采样。</p><h3 id="multi-scale-text-extractor"><a class="markdownIt-Anchor" href="#multi-scale-text-extractor"></a> Multi-Scale Text Extractor</h3><p><strong>CoordConv Layer</strong></p><p><img src="/img/article/2022/11/14/4.png" alt="" /></p><p>将每个特征图与两个额外的归一化坐标(x, y)通道连接起来，以引入位置信息。</p><p><strong>Constrained Deformable Pooling</strong></p><p><img src="/img/article/2022/11/14/7.png" alt="" /></p><p>作者设计了一种独特的下采样方式，即在下采样时增加了一个可学习的尺度参数用于约束预测的偏差，保证不近邻的特征区域不会相互影响，即只合成较小范围内的文本区域的特征。</p><p><strong>Scoring Net</strong></p><p>用sigmoid激活函数来二分类，以生成前景文本区域的置信度得分confidence scores。然后对这些score排序选择每个尺度下前TopN个点，送入Transformer。</p><h3 id="feature-grouping"><a class="markdownIt-Anchor" href="#feature-grouping"></a> Feature Grouping</h3><p>作者在论文中没有具体说是如何利用Tansformer做到给特征进行分组的。</p><h2 id="result"><a class="markdownIt-Anchor" href="#result"></a> Result</h2><p>截了一个在DOTA数据集上的实验对比:</p><p><img src="/img/article/2022/11/14/5.png" alt="" /></p><p><img src="/img/article/2022/11/14/8.png" alt="" /></p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>看着简单，但是还有有几个点是值得注意的：</p><ol><li><p>首先，作者仅仅只是把Transformer用于对特征点之间的关系建模上, (只用于一个子任务)这是很值得注意的。根据我以往读过的Tansformer目标检测相关的论文，之前要么就是把Swin Transfomer作为一个backbone，处理出特征图，然后送入后续head进行处理; 要么就是一整个网络用Tansformer结构.</p></li><li><p>只在预测出来的前景区域做Transformer，可以大幅度减少Transfomer因为大量参数带来的计算量。减少了背景噪声带来的影响，从而提高的检测精度.</p></li><li><p>整个网络结构避免掉了anchor,可以无需通过复杂的后处理(anchor generation，NMS等)而准确获得bbox。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
      <tag>Transformer</tag>
      
      <tag>目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QueryDet</title>
    <link href="/2022/10/31/AI-Learning/20221031-QueryDet/"/>
    <url>/2022/10/31/AI-Learning/20221031-QueryDet/</url>
    
    <content type="html"><![CDATA[<h1 id="querydet"><a class="markdownIt-Anchor" href="#querydet"></a> QueryDet</h1><h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2><p><strong>论文题目</strong> ：QueryDet</p><p><strong>论文地址</strong> ：<a href="https://arxiv.org/pdf/2103.09136.pdf">https://arxiv.org/pdf/2103.09136.pdf</a></p><p><strong>论文出处</strong> ：2022’CVPR oral</p><p><strong>代码实现</strong> ：<a href="https://github.com/ChenhongyiYang/QueryDet-PyTorch">https://github.com/ChenhongyiYang/QueryDet-PyTorch</a></p><h2 id="idea"><a class="markdownIt-Anchor" href="#idea"></a> Idea</h2><p>针对小目标检测，作者提出了QueryDet，设计了级联稀疏查询(CSQ)机制，它可以有效利用高分辨率特征，同时高可以降低所有基于特征金字塔的目标检测器的计算成本，保证快速的推理速度，从而提高对小目标的检测性能。</p><p><img src="/img/article/2022/10/31/2.png" alt="" /></p><h2 id="detail"><a class="markdownIt-Anchor" href="#detail"></a> Detail</h2><h3 id="question-in-small-objection"><a class="markdownIt-Anchor" href="#question-in-small-objection"></a> Question in small objection</h3><p>小目标检测中出现性能衰减主要由三个因素所导致：</p><ol><li><p>由于下采样操作导致引导小目标的特征消失，或被background中的噪声污染。</p></li><li><p>低分辨率特征对应的感受野无法与小目标的尺度相匹配。</p></li><li><p>小目标较小的偏差就会导致IoU上较大的扰动，导致小目标检测先天难于大目标。</p></li></ol><p>针对这些问题，作者认为：</p><ol><li><p>low-level特征层上的计算中，有很大部分是冗余的。</p></li><li><p>FPN结构中，即使低分辨率（high-level）的特征层无法精确的检测出小目标，但也能以较高的置信度来粗略判断出小目标是否存在以及对应的区域。</p></li></ol><p><img src="/img/article/2022/10/31/3.png" alt="" /></p><p>图1是普通的retinanet，图二retinanet+P2,计算的参数量明显增加了很多，图三QueryDet(CSQ)</p><p>做法：</p><p><img src="/img/article/2022/10/31/4.png" alt="" /></p><p>引入更高分辨率特征图（P2）进行计算，</p><p>Head设计上：并行于分类和回归头，添加了一个查询头（query head）。query head会输出的热力图(heat map)，表示位置<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>r</mi><mi>i</mi><mi>d</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">grid(i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>含有小目标的概率。</p><h3 id="cascade-sparse-query-csq"><a class="markdownIt-Anchor" href="#cascade-sparse-query-csq"></a> Cascade Sparse Query (CSQ)</h3><p>在训练过程中，每一层预定义阈值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">{s_l}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>设置为该层最小的anchor尺寸（anchor-based）/最小的回归范围（anchor-free），尺寸小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">{s_l}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>的ground truth，在该层会被视为小目标(small ground truth)。</p><p>query操作：然后对query head输出的heatmap做一个binary mask：计算small ground truth中心位置与head map上每个位置之间的距离来编码，距离小于sl的位置设为1，否则为0. 那么在下一层中heat map 中对应映射mask为0的位置，就不会进行概率的预测了。(这样就可以少计算很多冗余的anchor的Loss,从而减少计算量)</p><blockquote><p>每层损失采用不同加权系数（P2-P7在[1, 2.6]线性增加）来求得总损失，使模型同时从所有层学习。因为添加的更高分辨率特征（P2）使训练样本的分布发生了显著变化。P2上的训练样本总数甚至大于P3~P7的训练样本总和，如果不降低其权重，训练将由小目标主导。</p></blockquote><p>在测试/推理过程中，因为没有ground truth作为参照了，因此在做query的binary mask操作时，直接设定了一个阈值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">{\sigma}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span></span></span></span></span>。当query head输出heat map，其位置<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>r</mi><mi>i</mi><mi>d</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">grid(i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>的预测概率分数&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">{\sigma}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span></span></span></span></span>时,mask设置为1，否则为0. 查询后的Query value feature，做稀疏卷积spconv来减少计算量。</p><h2 id="result"><a class="markdownIt-Anchor" href="#result"></a> Result</h2><p>实验中设置阈值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi><mo>=</mo><mn>0.15</mn></mrow><annotation encoding="application/x-tex">{\sigma}=0.15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">1</span><span class="mord">5</span></span></span></span></p><p><img src="/img/article/2022/10/31/5.png" alt="" /></p><p><img src="/img/article/2022/10/31/6.png" alt="" /></p><p>总体上来说，设计得是比较简单，并且这种设计对于检测遥感图像也值得借鉴。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
      <tag>目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Focal and Global Distillation</title>
    <link href="/2022/10/24/AI-Learning/20221024-Focal%20and%20Global%20Dlistillation/"/>
    <url>/2022/10/24/AI-Learning/20221024-Focal%20and%20Global%20Dlistillation/</url>
    
    <content type="html"><![CDATA[<h1 id="focal-and-global-knowledge-distillation"><a class="markdownIt-Anchor" href="#focal-and-global-knowledge-distillation"></a> Focal and Global Knowledge Distillation</h1><h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2><p><strong>论文题目</strong> ：Focal and Global Knowledge Distillation for Detectors</p><p><strong>论文地址</strong> ：<a href="https://arxiv.org/pdf/2111.11837.pdf">https://arxiv.org/pdf/2111.11837.pdf</a></p><p><strong>论文出处</strong> ：2022’CVPR</p><p><strong>代码实现</strong> ：<a href="https://github.com/yzd-v/FGD">https://github.com/yzd-v/FGD</a></p><h2 id="idea"><a class="markdownIt-Anchor" href="#idea"></a> Idea</h2><p>在目标检测中，Teacher和Student的特征在不同的区域由很大的差异，特别是在前景和背景上。如果同等的提取它们，特征图之间的不均匀差异将对提取产生负面影响。因此作者提出了焦点和全局蒸馏FGD，所有损失函数仅根据特征计算，因此可以适用于各种检测器。</p><p><img src="/img/article/2022/10/24/5.png" alt="" /></p><p>焦点蒸馏份力前景和背景，迫使学生关注教师的关键像素和通道，全局蒸馏重建了不同像素之间的关系，并由教师传递给学生以补偿焦点蒸馏丢失的全局信息。</p><h2 id="detail"><a class="markdownIt-Anchor" href="#detail"></a> Detail</h2><h3 id="feature-distllation"><a class="markdownIt-Anchor" href="#feature-distllation"></a> Feature Distllation</h3><p>参考文章1：<a href="https://arxiv.org/pdf/1412.6550.pdf">[2015’ICLR]-FitNets:Hints For Thin Deep Nets</a></p><p>参考文章2：<a href="https://arxiv.org/pdf/1904.01866.pdf">[2019’ICCV]-A Comprehensive Overhaul of Feature Distillation</a></p><p>Logits Distllation引入了一个模型压缩框架(Teacher-Student)，该框架通过将深度网络(Teacher)的集合压缩为具有相似深度的学生(Student)网络。但是高性能的Teacher输出的Soft Target与Ground Truth并没有显著差异，这就会限制蒸馏效果。</p><p>为了更好的利用Teacher网络中包含的信息，可以使用Feature Distllation。</p><h4 id="hint-layerguided-layer"><a class="markdownIt-Anchor" href="#hint-layerguided-layer"></a> hint layer&amp;guided layer</h4><p>选择Student的一个中间层(这层称为guided layer)，去学习Teacher的一个中间层(称为hint layer)的output，也就是guided layer需要正确预测hint layer的输出。</p><p><img src="/img/article/2022/10/24/2.png" alt="" /></p><p>hint layer 高宽和通道数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>N</mi><mrow><mi>h</mi><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>N</mi><mrow><mi>h</mi><mn>2</mn></mrow></msub><mo separator="true">,</mo><msub><mi>O</mi><mi>h</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(N_{h1}, N_{h2}, O_h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>guided layer 高宽和通道数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>N</mi><mrow><mi>g</mi><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>N</mi><mrow><mi>g</mi><mn>2</mn></mrow></msub><mo separator="true">,</mo><msub><mi>O</mi><mi>g</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(N_{g1}, N_{g2}, O_g)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><h4 id="regressor"><a class="markdownIt-Anchor" href="#regressor"></a> regressor</h4><p>考虑到Teacher通常比Student更高更宽，所选的hint layer可能比guided layer具有更多输出，因此给guided layer添加一个regressor，使guided经过regressor后其输出与hint layer的大小一致。(自适应宽高)</p><p><img src="/img/article/2022/10/24/3.png" alt="实际上只有加粗的是hint layer和guided layer" /></p><p><strong>全连接</strong></p><p>regressor的weight矩阵参数：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>W</mi><mi>r</mi></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>N</mi><mrow><mi>h</mi><mn>1</mn></mrow></msub><mo>∗</mo><msub><mi>N</mi><mrow><mi>g</mi><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>N</mi><mrow><mi>h</mi><mn>2</mn></mrow></msub><mo>∗</mo><msub><mi>N</mi><mrow><mi>g</mi><mn>2</mn></mrow></msub><mo separator="true">,</mo><msub><mi>O</mi><mi>h</mi></msub><mo>∗</mo><msub><mi>O</mi><mi>g</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">W_r = (N_{h1} * N_{g1}, N_{h2} * N_{g2}, O_h * O_g)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p><strong>反卷积</strong></p><p>regressor的kernel大小确定：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>N</mi><mrow><mi>g</mi><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>k</mi><mn>1</mn></msub><mo>+</mo><mn>1</mn><mo>=</mo><msub><mi>N</mi><mrow><mi>h</mi><mn>1</mn></mrow></msub><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>p</mi><mi>a</mi><mi>d</mi><mi>d</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>d</mi><mi>e</mi><mo>=</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N_{g1} - k_1 + 1 = N_{h1}, (padding = 0, stride = 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> ，<br />用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>O</mi><mi>h</mi></msub></mrow><annotation encoding="application/x-tex">{O_h}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>个大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>k</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>k</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>O</mi><mi>g</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(k_1, k_2, O_g)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的kernel对guided layer做反卷积。</p><p>regressor的weight矩阵参数：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>W</mi><mi>r</mi></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>k</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>k</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>O</mi><mi>h</mi></msub><mo>∗</mo><msub><mi>O</mi><mi>g</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">W_r = (k_1, k_2, O_h * O_g)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><blockquote><p>关于特征蒸馏的位置选取，FitNets是使用的是<strong>任意中间层的末端</strong>输出作为蒸馏点。</p></blockquote><h4 id="training-scheme"><a class="markdownIt-Anchor" href="#training-scheme"></a> Training Scheme</h4><p><img src="/img/article/2022/10/24/2.png" alt="" /></p><p>特征蒸馏提取的损失可以被定义为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mrow><mi>f</mi><mi>e</mi><mi>a</mi></mrow></msub><mo>=</mo><mi>d</mi><mo stretchy="false">(</mo><msub><mi>T</mi><mi>t</mi></msub><mo stretchy="false">(</mo><msub><mi>F</mi><mi>t</mi></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>T</mi><mi>s</mi></msub><mo stretchy="false">(</mo><msub><mi>F</mi><mi>s</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L_{fea} = d(T_t(F_t), T_s(F_s))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><p>Teacher transform : 对Teacher的hint layer层输出做变换。</p><p>Student transform : 对Student的guided layer层输出做变换。</p><p>Distillation feature position：改变特征蒸馏的位置选取。</p><p>比如在激活函数前进行蒸馏:</p><p><img src="/img/article/2022/10/24/4.png" alt="" /></p><p>Distance function：衡量特征提取的损失函数通常采用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mn>2</mn></msub><mi>D</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">L_2 Distance</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span></span></span></span>。</p><p>以上是Feature Distllation的提出及归纳，因为guided layer和hint layer的维度不一致和特征图的差异性，并且引入了特征提取的损失，后续在此上有很多文章可做。</p><h3 id="focal-and-global-distillation"><a class="markdownIt-Anchor" href="#focal-and-global-distillation"></a> Focal and Global Distillation</h3><p><img src="/img/article/2022/10/24/6.png" alt="" /></p><p>把特征蒸馏损失按CWH维度拓展:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mrow><mi>f</mi><mi>e</mi><mi>a</mi></mrow></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mi>C</mi><mi>H</mi><mi>W</mi></mrow></mfrac><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>C</mi></munderover><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>H</mi></munderover><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>W</mi></munderover><mo stretchy="false">(</mo><msubsup><mi>F</mi><mrow><mi>k</mi><mo separator="true">,</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow><mi>T</mi></msubsup><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><msubsup><mi>F</mi><mrow><mi>k</mi><mo separator="true">,</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow><mi>S</mi></msubsup><mo stretchy="false">)</mo><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">L_{fea} = \frac{1}{CHW}\sum_{k=1}^{C}\sum_{i=1}^{H}\sum_{j=1}^{W}(F_{k,i,j}^T-f(F_{k,i,j}^S))^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.2421130000000007em;vertical-align:-1.4137769999999998em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000006em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">W</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4137769999999998em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.891331em;"><span style="top:-2.4530000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.274439em;vertical-align:-0.383108em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.891331em;"><span style="top:-2.4530000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><h4 id="focal-distillation"><a class="markdownIt-Anchor" href="#focal-distillation"></a> Focal Distillation</h4><p>这里所谓的Focal，是让Distillation更多注意gt的bboxes。</p><h5 id="binary-mask"><a class="markdownIt-Anchor" href="#binary-mask"></a> Binary Mask</h5><p>首先设置一个Binary Mask来分离背景和前景。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>i</mi><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>r</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>O</mi><mi>r</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>w</mi><mi>i</mi><mi>s</mi><mi>e</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">M_{i,j}=\left\{\begin{matrix}1 &amp;if(i,j)\in r\\0 &amp;Ortherwise\end{matrix}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>表示ground-truth的bboxes，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>是特征图中的横纵坐标，如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span>映射回原图落在ground-truth中，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">M_{i,j}=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，否则为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>.</p><h5 id="scale-mask"><a class="markdownIt-Anchor" href="#scale-mask"></a> Scale Mask</h5><p>然后为了平衡前景和背景的损失，使其被平等对待，设置一个Scale Mask：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mn>1</mn><mrow><msub><mi>H</mi><mi>r</mi></msub><msub><mi>W</mi><mi>r</mi></msub></mrow></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>i</mi><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>r</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mn>1</mn><msub><mi>N</mi><mrow><mi>b</mi><mi>g</mi></mrow></msub></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>O</mi><mi>r</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>w</mi><mi>i</mi><mi>s</mi><mi>e</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">S_{i,j}=\left\{\begin{matrix}\frac{1}{H_rW_r}  &amp;if(i,j)\in r\\\frac{1}{N_{bg}} &amp;Ortherwise\end{matrix}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5916979999999996em;"><span style="top:-3.74659em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.08125em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.4563820000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.10903em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29011428571428566em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5480799999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0916979999999996em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5916979999999996em;"><span style="top:-3.74659em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span><span style="top:-2.4563820000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0916979999999996em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>N</mi><mrow><mi>b</mi><mi>g</mi></mrow></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>H</mi></munderover><munder><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow></munder><mi>W</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msub><mi>M</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N_{bg}=\sum_{i=1}^{H}\sum_{j=1}{W}(1 - M_{i,j})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.2421130000000002em;vertical-align:-1.413777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8723309999999997em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.413777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>可以看出来其实就是面积比的倒数作为权重。</p><p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>W</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">W_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>H</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">H_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示ground-truth的宽高。(如果有像素被多个gt bboxes重叠，选择最小的框来计算S)</p><h5 id="attention-mask"><a class="markdownIt-Anchor" href="#attention-mask"></a> Attention Mask</h5><p>借鉴了<a href="">2017’ICLR:pay more attention to attention</a>该文章提出了注意力蒸馏。</p><p>然后把像素和通道分离，做Attention Mask =&gt; 分别为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>A</mi><mi>S</mi></msup><mi mathvariant="normal">和</mi><msup><mi>A</mi><mi>C</mi></msup></mrow><annotation encoding="application/x-tex">A^S和A^C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">和</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span></span></span></span></span></span></span></span></p><p>这就是提出的问题图中的spatial attention map和channel attention map。</p><p>先求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>F</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">{F_T}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>F</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">{F_S}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>输出的绝对值的平均值</p><p><img src="/img/article/2022/10/24/7.png" alt="" /></p><p><img src="/img/article/2022/10/24/8.png" alt="" /></p><h5 id="focal-distillation-loss"><a class="markdownIt-Anchor" href="#focal-distillation-loss"></a> Focal Distillation loss</h5><p><img src="/img/article/2022/10/24/9.png" alt="" /></p><p>前半部分是前景，后半部分是背景。</p><p><img src="/img/article/2022/10/24/10.png" alt="" /></p><p>用L2 loss衡量特征图蒸馏损失,用L1 loss衡量注意力蒸馏损失。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mrow><mi>f</mi><mi>o</mi><mi>c</mi><mi>a</mi><mi>l</mi></mrow></msub><mo>=</mo><msub><mi>L</mi><mrow><mi>f</mi><mi>e</mi><mi>a</mi></mrow></msub><mo>+</mo><msub><mi>L</mi><mrow><mi>a</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">L_{focal} = L_{fea} + L_{at}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>可以认为焦点蒸馏 = 特征蒸馏 + 注意力蒸馏</p><h4 id="global-distillation"><a class="markdownIt-Anchor" href="#global-distillation"></a> Global Distillation</h4><p>把GCNet提出的GC-Block(Global Context Block)模块，应用到知识蒸馏当中。</p><p>GC Block可以理解为一个适用于求目标检测任务的图像attention map的模块。</p><p><img src="/img/article/2022/10/24/11.png" alt="" /></p><p><img src="/img/article/2022/10/24/12.png" alt="" /></p><h5 id="overall-loss"><a class="markdownIt-Anchor" href="#overall-loss"></a> Overall loss</h5><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo>=</mo><msub><mi>L</mi><mrow><mi>o</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub><mo>+</mo><msub><mi>L</mi><mrow><mi>f</mi><mi>o</mi><mi>c</mi><mi>a</mi><mi>l</mi></mrow></msub><mo>+</mo><msub><mi>L</mi><mrow><mi>g</mi><mi>l</mi><mi>o</mi><mi>b</mi><mi>a</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">L = L_{original} + L_{focal} + L_{global}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p><h3 id="result"><a class="markdownIt-Anchor" href="#result"></a> Result</h3><p><img src="/img/article/2022/10/24/13.png" alt="" /></p><p><img src="/img/article/2022/10/24/14.png" alt="" /></p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>可以看到在最新的研究中，又把特征图蒸馏、注意力蒸馏按空间角度划分了像素，通道。</p><p>GC Block是一个很好的模块，用于提取目标检测任务中的attention map。</p><p>所以说总的来看，Feature Distllation的可以改进和切入的角度有很多。</p><p>而且我认为，作者的这个思路肯定不是一蹴而就的，而是在做实验的过程中不断调整的。</p><blockquote><p>todo: 一定要读一下GC Net。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
      <tag>目标检测</tag>
      
      <tag>知识蒸馏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Difficulty in Oriented Object Detection</title>
    <link href="/2022/10/17/Difficulty%20in%20Oriented%20Object%20Detection/"/>
    <url>/2022/10/17/Difficulty%20in%20Oriented%20Object%20Detection/</url>
    
    <content type="html"><![CDATA[<h1 id="difficulty-in-oriented-object-detection"><a class="markdownIt-Anchor" href="#difficulty-in-oriented-object-detection"></a> Difficulty in Oriented Object Detection</h1><p>标签由复杂的规则计算，这对于网络来说很难学习，可以这么说这些方法引入了而额外的参数，但无法被RPN采用。</p><p>先把类分好，再做一个摘要的诵读。</p><p>需要维护的地方:</p><p>EndNote</p><p>ipad PDF</p><p>文件夹</p><p>每篇论文-你需要做的事：</p><p>填写表格年份</p><p>reference下标引用</p><p>关注一下作者是不是4位</p><p>发送到ipad阅读摘要和一些重要部分，归纳其用什么方案解决了什么问题</p><p>检测器detecor 归类，然后放到对应文件夹</p><h2 id="oriented-object-detection"><a class="markdownIt-Anchor" href="#oriented-object-detection"></a> Oriented Object Detection</h2><h3 id="anchor-based"><a class="markdownIt-Anchor" href="#anchor-based"></a> Anchor-based</h3><p>Backbone : 几乎都是基于ResNet，极少的基于ResNet的改进版本ResNext</p><p>Neck : FPN</p><h4 id="one-stage"><a class="markdownIt-Anchor" href="#one-stage"></a> One Stage</h4><p>CFC-Net<sup id="fnref:14" class="footnote-ref"><a href="#fn:14" rel="footnote"><span class="hint--top hint--rounded" aria-label="CFC-Net: A Critical Feature Capturing Network for Arbitrary-Oriented Object Detection in Remote Sensing Images[√]">[14]</span></a></sup></p><p>R3Det<sup id="fnref:15" class="footnote-ref"><a href="#fn:15" rel="footnote"><span class="hint--top hint--rounded" aria-label="R3Det: Refined Single-Stage Detector with Feature Refinement for Rotating Object[√]">[15]</span></a></sup></p><p>SAR<sup id="fnref:19" class="footnote-ref"><a href="#fn:19" rel="footnote"><span class="hint--top hint--rounded" aria-label="SAR: Single-Stage Anchor-Free Rotating Object Detection[√]">[19]</span></a></sup></p><p>BBAVectors<sup id="fnref:22" class="footnote-ref"><a href="#fn:22" rel="footnote"><span class="hint--top hint--rounded" aria-label="Oriented Object Detection in Aerial Images with Box Boundary-Aware Vectors[√]">[22]</span></a></sup></p><p>EAutoDet<sup id="fnref:34" class="footnote-ref"><a href="#fn:34" rel="footnote"><span class="hint--top hint--rounded" aria-label="EAutoDet: Efficient Architecture Search for Object Detection[√]">[34]</span></a></sup></p><p>RIDet<sup id="fnref:37" class="footnote-ref"><a href="#fn:37" rel="footnote"><span class="hint--top hint--rounded" aria-label="Optimization for Arbitrary-Oriented Object Detection via Representation Invariance Loss[√]">[37]</span></a></sup></p><h4 id="two-stage"><a class="markdownIt-Anchor" href="#two-stage"></a> Two Stage</h4><p>FR-O(DOTA)<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="DOTA: A Large-Scale Dataset for Object Detection in Aerial Images[√]">[1]</span></a></sup></p><p>ICN<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="Towards Multi-class Object Detection in Unconstrained Remote Sensing Imagery[x]">[6]</span></a></sup></p><p>RoI Transformer<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="Learning RoI Transformer for Oriented Object Detection in Aerial Images[√]">[7]</span></a></sup></p><p>R2CNN<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="R2^22CNN: Rotational Region CNN for Orientation Robust Scene Text Detection[x]">[3]</span></a></sup></p><p>RRPN<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="Arbitrary-Oriented Scene Text Detection via Rotation Proposals[√]">[4]</span></a></sup>  =&gt;  The implement of skewIoU computation</p><p>SCRDet<sup id="fnref:11" class="footnote-ref"><a href="#fn:11" rel="footnote"><span class="hint--top hint--rounded" aria-label="SCRDet: Towards More Robust Detection for Small, Cluttered and Rotated Objects[√]">[11]</span></a></sup></p><p>Gliding Vertex<sup id="fnref:16" class="footnote-ref"><a href="#fn:16" rel="footnote"><span class="hint--top hint--rounded" aria-label="Gliding vertex on the horizontal bounding box for multi-oriented object detection[√]">[16]</span></a></sup></p><p>CSL<sup id="fnref:24" class="footnote-ref"><a href="#fn:24" rel="footnote"><span class="hint--top hint--rounded" aria-label="On the Arbitrary-Oriented Object Detection: Classification based Approaches Revisited[√]">[24]</span></a></sup></p><p>OPLD<sup id="fnref:27" class="footnote-ref"><a href="#fn:27" rel="footnote"><span class="hint--top hint--rounded" aria-label="Learning Point-Guided Localization for Detection in Remote Sensing Images[√]">[27]</span></a></sup></p><p>CLT-Det<sup id="fnref:36" class="footnote-ref"><a href="#fn:36" rel="footnote"><span class="hint--top hint--rounded" aria-label="CLT-Det: Correlation Learning Based on Transformer for Detecting Dense Objects in Remote Sensing Images[√]">[36]</span></a></sup>[在FPN中用了Transformer]</p><p>text  detection相关?</p><h3 id="anchor-free"><a class="markdownIt-Anchor" href="#anchor-free"></a> Anchor-free</h3><p>Backbone : 比较多的是基于CenterNet的Hourglass，也有基于Reppoints的ResNet和基于YOLO的DarkNet53</p><p>Axis Learning<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="Axis Learning for Orientated Objects Detection in Aerial Images[x]">[5]</span></a></sup></p><p>ACE<sup id="fnref:9" class="footnote-ref"><a href="#fn:9" rel="footnote"><span class="hint--top hint--rounded" aria-label="ACE: Anchor-Free Corner Evolution for Real-Time Arbitrarily-Oriented Object Detection[x]">[9]</span></a></sup></p><p>P-RSDet<sup id="fnref:10" class="footnote-ref"><a href="#fn:10" rel="footnote"><span class="hint--top hint--rounded" aria-label="Arbitrary-Oriented Object Detection in Remote Sensing Images Based on Polar Coordinates[x]">[10]</span></a></sup></p><p>O2-DNet<sup id="fnref:12" class="footnote-ref"><a href="#fn:12" rel="footnote"><span class="hint--top hint--rounded" aria-label="Oriented Objects as pairs of Middle Lines[x]">[12]</span></a></sup></p><p>DRN<sup id="fnref:13" class="footnote-ref"><a href="#fn:13" rel="footnote"><span class="hint--top hint--rounded" aria-label="Dynamic Refinement Network for Oriented and Densely Packed Object Detection[√]">[13]</span></a></sup></p><p>用oriented bbox重新标注了SKU110K，得到了<code>SKU110K-R</code></p><p>提出了DRN，由两个新组件组成：</p><ol><li>特征选择模块(FSM): 可以根据物体的形状和方向自适应调整感受野，有效缓解了感受野和物体之间的错位</li><li>动态补偿头(DPH):  提出了两种Dynamic Refine Head，可以动态调整边界<ol><li>DRH-C    classfication分支头</li><li>DRH-R    regression分支头</li></ol></li></ol><p>TricubeNet<sup id="fnref:20" class="footnote-ref"><a href="#fn:20" rel="footnote"><span class="hint--top hint--rounded" aria-label="TricubeNet: 2D Kernel-Based Object Representation for Weakly-Occluded[×]">[20]</span></a></sup></p><p>Mask-OBB<sup id="fnref:21" class="footnote-ref"><a href="#fn:21" rel="footnote"><span class="hint--top hint--rounded" aria-label="Mask OBB: A Semantic Attention-Based Mask Oriented Bounding Box Representation for Multi-Category Object Detection in Aerial Images[√]">[21]</span></a></sup></p><p>PRDet<sup id="fnref:28" class="footnote-ref"><a href="#fn:28" rel="footnote"><span class="hint--top hint--rounded" aria-label="Polar Ray: A Single-stage Angle-free Detector for Oriented Object Detection in Aerial Images[√]">[28]</span></a></sup></p><p>PolarDet<sup id="fnref:30" class="footnote-ref"><a href="#fn:30" rel="footnote"><span class="hint--top hint--rounded" aria-label="PolarDet: a fast, more precise detector for rotated target in aerial images[×]">[30]</span></a></sup></p><p>Beyond Bounding-Box(CFA)<sup id="fnref:31" class="footnote-ref"><a href="#fn:31" rel="footnote"><span class="hint--top hint--rounded" aria-label="Beyond Bounding-Box: Convex-hull Feature Adaptation for Oriented and Densely Packed Object Detection[√]">[31]</span></a></sup></p><p>GGHL<sup id="fnref:33" class="footnote-ref"><a href="#fn:33" rel="footnote"><span class="hint--top hint--rounded" aria-label="A General Gaussian Heatmap Label Assignment for Arbitrary-Oriented Object Detection[√]">[33]</span></a></sup></p><p>Oriented Reppoint<sup id="fnref:38" class="footnote-ref"><a href="#fn:38" rel="footnote"><span class="hint--top hint--rounded" aria-label="Oriented RepPoints for Aerial Object Detection[√]">[38]</span></a></sup></p><p>CenterOBB<sup id="fnref:40" class="footnote-ref"><a href="#fn:40" rel="footnote"><span class="hint--top hint--rounded" aria-label="Arbitrarily Oriented Dense Object Detection Based on Center Point Network in Remote Sensing Images[√]">[40]</span></a></sup></p><p>FSDet<sup id="fnref:41" class="footnote-ref"><a href="#fn:41" rel="footnote"><span class="hint--top hint--rounded" aria-label="Object Detection for Aerial Images With Feature Enhancement and Soft Label Assignment[√]">[41]</span></a></sup></p><p>FR-Est<sup id="fnref:43" class="footnote-ref"><a href="#fn:43" rel="footnote"><span class="hint--top hint--rounded" aria-label="Point-Based Estimator for Arbitrary-Oriented Object Detection in Aerial Images[×]">[43]</span></a></sup></p><h3 id="lightwieght"><a class="markdownIt-Anchor" href="#lightwieght"></a> Lightwieght</h3><p>Backbone:  基于MobileNet，基于ShuffleNet、基于EfficientNet</p><p>LO-Det<sup id="fnref:17" class="footnote-ref"><a href="#fn:17" rel="footnote"><span class="hint--top hint--rounded" aria-label="LO-Det: Lightweight Oriented Object Detection in Remote Sensing Images[√]">[17]</span></a></sup></p><p><strong>轻量型</strong>卷积神经网络，在嵌入式设备上快速运行。</p><p>CSA-DPF模块降低了模型复杂度并提高了精度，DSC模块使得OBB的形状更准确并减轻了边界问题</p><p>Backbone的浅层输出特征图通常具有低级语义特征和高分辨率，深层输出特征图富含高级抽象语义特征和低分辨率，明智的approach是整合这两种上下文特征，使其优势互补。<br />mobileNetv2和shuffleNet都是为分类而设计的，因此只需要最后一层输出特征，因此这些轻量网络通常浅层输入特征图比较少。</p><h3 id="seg"><a class="markdownIt-Anchor" href="#seg"></a> Seg</h3><p>ICN <sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="Towards Multi-class Object Detection in Unconstrained Remote Sensing Imagery[x]">[6]</span></a></sup>单纯的迁移 =&gt; (2017ECCV)ICNet for Real-Time Semantic Segmentation on High-Resolution Imagest图像级联网络</p><p>EFN<sup id="fnref:18" class="footnote-ref"><a href="#fn:18" rel="footnote"><span class="hint--top hint--rounded" aria-label="EFN: Field-Based Object Detection for Aerial Images[√]">[18]</span></a></sup></p><h3 id="vit"><a class="markdownIt-Anchor" href="#vit"></a> ViT</h3><p>RSP<sup id="fnref:39" class="footnote-ref"><a href="#fn:39" rel="footnote"><span class="hint--top hint--rounded" aria-label="An Empirical Study of Remote Sensing Pretraining[×]">[39]</span></a></sup></p><p>AO2-DETR<sup id="fnref:47" class="footnote-ref"><a href="#fn:47" rel="footnote"><span class="hint--top hint--rounded" aria-label="AO2-DETR: Arbitrary-Oriented Object Detection Transformer[√]">[47]</span></a></sup></p><p>RBox<sup id="fnref:49" class="footnote-ref"><a href="#fn:49" rel="footnote"><span class="hint--top hint--rounded" aria-label="Few Could Be Better Than All: Feature Sampling and Grouping for Scene Text Detection[√]">[49]</span></a></sup></p><p>O2-DETR<sup id="fnref:50" class="footnote-ref"><a href="#fn:50" rel="footnote"><span class="hint--top hint--rounded" aria-label="Oriented Object Detection with Transformer[√]">[50]</span></a></sup></p><h3 id="else"><a class="markdownIt-Anchor" href="#else"></a> Else</h3><h4 id="lossiou"><a class="markdownIt-Anchor" href="#lossiou"></a> Loss&amp;IoU</h4><p>适用于哪一类的cls reg one stage two stage</p><p>PIoU Loss<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="PIoU Loss: Towards Accurate Oriented Object Detection in Complex Environments[x]">[2]</span></a></sup></p><p>ProbIoU<sup id="fnref:8" class="footnote-ref"><a href="#fn:8" rel="footnote"><span class="hint--top hint--rounded" aria-label="Gaussian Bounding Boxes and Probabilistic Intersection-over-Union for Object Detection[x]">[8]</span></a></sup></p><p>SIoU<sup id="fnref:29" class="footnote-ref"><a href="#fn:29" rel="footnote"><span class="hint--top hint--rounded" aria-label="Constrained-SIoU: A Metric for Horizontal Candidates in Multi-Oriented Object Detection[√]]">[29]</span></a></sup></p><h4 id="trick"><a class="markdownIt-Anchor" href="#trick"></a> Trick</h4><p>像一些回归问题转分类问题的文章 算作trick，还有自适应等策略</p><p>CSL<sup id="fnref:24" class="footnote-ref"><a href="#fn:24" rel="footnote"><span class="hint--top hint--rounded" aria-label="On the Arbitrary-Oriented Object Detection: Classification based Approaches Revisited[√]">[24]</span></a></sup></p><p>DCL<sup id="fnref:35" class="footnote-ref"><a href="#fn:35" rel="footnote"><span class="hint--top hint--rounded" aria-label="Dense Label Encoding for Boundary Discontinuity Free Rotation Detection[√]">[35]</span></a></sup></p><p>SASM<sup id="fnref:46" class="footnote-ref"><a href="#fn:46" rel="footnote"><span class="hint--top hint--rounded" aria-label="Shape-Adaptive Selection and Measurement for Oriented Object Detection[√]">[46]</span></a></sup></p><h3 id="dataset"><a class="markdownIt-Anchor" href="#dataset"></a> DataSet</h3><p>DOTA-V1.0</p><p>Bridge、SoccerBallField、RoundAbout 、HeliCopter这4个就是特别明显的，因为数量较少而出现长尾效应的类别。</p><p>HRSC2016</p><p>UCAS-AOD</p><p>DIOR              光学遥感影像大规模数据集</p><p>RSOD             数据集</p><p>ICDAR2015   场景文本数据集</p><p>SKU110K-R    密集零售物体场景</p><h2 id="difficulty-and-solution"><a class="markdownIt-Anchor" href="#difficulty-and-solution"></a> Difficulty and Solution</h2><h3 id="public-issues"><a class="markdownIt-Anchor" href="#public-issues"></a> Public Issues</h3><ol><li>航空图像的尺寸太大，使得常规目标检测网络显存爆炸；图像幅面宽，视场大，目标类型丰富，使得背景复杂，尺度变化大。</li></ol><blockquote><p>对密集小目标，通常的做法都是对原始的高分辨率图像进行裁剪分块再进行检测，但是这种方法效率很低，而且裁剪的图像块中的前景目标占比率可能很低</p></blockquote><ol start="2"><li>目标尺寸小，并且目标<strong>分布稀疏且不均匀</strong>，极其不均衡的前景-背景分布使得检测效率低下；</li><li><strong>密集目标</strong>存在遮挡或拥堵的情况，从而导致使得检测困难；</li><li>数据集中<strong>类别不均衡</strong>，如行人、车辆等目标类居多，而桥等目标类稀少，容易出现长尾效应；</li></ol><blockquote><p>类别之间数量不平衡的现象，这一块很多人提到，但几乎没人去解决这个问题</p><p>这里有一篇<strong>ACML 2022</strong>:<a href="https://zhuanlan.zhihu.com/p/579153319">https://zhuanlan.zhihu.com/p/579153319</a> 可以解决或缓解，代码即将开源</p></blockquote><ol start="5"><li>卫星遥感图像是从空中俯拍的，因此<strong>图像俯瞰角度不固定</strong>，方向多变，使得检测难度大。</li></ol><h3 id="specific-issues"><a class="markdownIt-Anchor" href="#specific-issues"></a> Specific Issues</h3><ol><li><p>角度参数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">{\theta}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span></span>，对于<strong>高纵横比的物体</strong>，较小的角度偏差将导致较大的误差<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="PIoU Loss: Towards Accurate Oriented Object Detection in Complex Environments[x]">[2]</span></a></sup></p><p><img src="/img/article/2022/12/01/10.png" alt="" /></p></li></ol><blockquote><ul><li>PIOU<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="PIoU Loss: Towards Accurate Oriented Object Detection in Complex Environments[x]">[2]</span></a></sup>采用逐像素形式定义Loss损失</li><li>ProbIoU<sup id="fnref:8" class="footnote-ref"><a href="#fn:8" rel="footnote"><span class="hint--top hint--rounded" aria-label="Gaussian Bounding Boxes and Probabilistic Intersection-over-Union for Object Detection[x]">[8]</span></a></sup>提出一种比HBB和OBB更加能够贴合目标轮廓的表示形式，高斯边界框</li><li>APE<sup id="fnref:23" class="footnote-ref"><a href="#fn:23" rel="footnote"><span class="hint--top hint--rounded" aria-label="Adaptive Period Embedding for Representing Oriented Objects in Aerial Images[√]">[23]</span></a></sup>提出一种LIIoU(长度无关IoU)</li><li>SIoU<sup id="fnref:29" class="footnote-ref"><a href="#fn:29" rel="footnote"><span class="hint--top hint--rounded" aria-label="Constrained-SIoU: A Metric for Horizontal Candidates in Multi-Oriented Object Detection[√]]">[29]</span></a></sup>采用了一种Splicing(拼接)IoU来提供水平框和多方向对象之间重叠的一种更好的度量，在单阶段和两阶段都有积极的效果</li><li>SASM<sup id="fnref:46" class="footnote-ref"><a href="#fn:46" rel="footnote"><span class="hint--top hint--rounded" aria-label="Shape-Adaptive Selection and Measurement for Oriented Object Detection[√]">[46]</span></a></sup>借鉴了ATSS，提出了一种形状自适应的正负样本分配策略</li></ul></blockquote><ol start="2"><li>基于Anchor-based的方法，如果采用<strong>rotated anchor</strong>先验，<ul><li>需要相当多数量的rotated anchor(因为原本horizonal anchor有scale, ratio, 现在额外有angle)，计算非常耗时</li><li>rotated anchor很难和GT框实现良好的空间对齐，需要额外设计对齐模块</li><li>会产生大量且低质量的负样本加入到Loss计算，不利于网络的收敛</li><li>rotated anchor不能确保位分类和回归提供足够好的语义信息</li></ul></li></ol><blockquote><p>⭐️基于<strong>Anchor-free</strong>(改变了检测方式，但<strong>没有绕开边界问题</strong>)</p><ul><li><p>Axis Learning<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="Axis Learning for Orientated Objects Detection in Aerial Images[x]">[5]</span></a></sup>提出anchor-free的方法，通过预测物体的轴(头部尾部两点)来检测物体</p></li><li><p>ACE<sup id="fnref:9" class="footnote-ref"><a href="#fn:9" rel="footnote"><span class="hint--top hint--rounded" aria-label="ACE: Anchor-Free Corner Evolution for Real-Time Arbitrarily-Oriented Object Detection[x]">[9]</span></a></sup>将轴对齐的边界框演化为定向四边形</p></li><li><p>P-RSDet<sup id="fnref:10" class="footnote-ref"><a href="#fn:10" rel="footnote"><span class="hint--top hint--rounded" aria-label="Arbitrary-Oriented Object Detection in Remote Sensing Images Based on Polar Coordinates[x]">[10]</span></a></sup>引入极坐标建模，回归一个极半径和两个极角</p></li><li><p>O2-DNet<sup id="fnref:12" class="footnote-ref"><a href="#fn:12" rel="footnote"><span class="hint--top hint--rounded" aria-label="Oriented Objects as pairs of Middle Lines[x]">[12]</span></a></sup>提出了一种one-stage,  anchor-free , NMS-free的方法,通过预测对象内部的一对中间线来定位对象来检测oriented object.</p></li><li><p>TricubeNet<sup id="fnref:20" class="footnote-ref"><a href="#fn:20" rel="footnote"><span class="hint--top hint--rounded" aria-label="TricubeNet: 2D Kernel-Based Object Representation for Weakly-Occluded[×]">[20]</span></a></sup>将对象表示成2DTricubeKernel，通过生成heatmap来定位，从而生成边界框</p></li><li><p>Mask-OBB<sup id="fnref:21" class="footnote-ref"><a href="#fn:21" rel="footnote"><span class="hint--top hint--rounded" aria-label="Mask OBB: A Semantic Attention-Based Mask Oriented Bounding Box Representation for Multi-Category Object Detection in Aerial Images[√]">[21]</span></a></sup>将OBB视为像素级分类问题，使用预测的Mask来生成边界框。</p></li><li><p>PRDet<sup id="fnref:28" class="footnote-ref"><a href="#fn:28" rel="footnote"><span class="hint--top hint--rounded" aria-label="Polar Ray: A Single-stage Angle-free Detector for Oriented Object Detection in Aerial Images[√]">[28]</span></a></sup>使用n条极射线来表示旋转框，这种方法还是只能减轻边界问题，没有解决:</p></li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>l</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>l</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>l</mi><mn>3</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>l</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{(x_0,y_0, l_1, l_2, l_3...l_n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>=</mo><msub><mi>x</mi><mn>0</mn></msub><mo>+</mo><msub><mi>l</mi><mi>n</mi></msub><mo>∗</mo><mi>c</mi><mi>o</mi><mi>s</mi><msub><mi>θ</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">{x_n = x_0 + l_n*cos\theta_n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mi>n</mi></msub><mo>=</mo><msub><mi>y</mi><mn>0</mn></msub><mo>+</mo><msub><mi>l</mi><mi>n</mi></msub><mo>∗</mo><mi>s</mi><mi>i</mi><mi>n</mi><msub><mi>θ</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">{y_n = y_0 + l_n*sin\theta_n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>θ</mi><mi>n</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">Δ</mi><mi>θ</mi></mrow><annotation encoding="application/x-tex">{\theta_n = (n - 1)\Delta \theta}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">Δ</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span></span>、 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>θ</mi><mo>=</mo><mfrac><mrow><mn>2</mn><mi>π</mi></mrow><mi>N</mi></mfrac></mrow><annotation encoding="application/x-tex">{\Delta \theta = \frac{2\pi}{N}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mord">Δ</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><img src="/img/article/2022/12/01/26.png" alt="" /></p><ul><li>PolarDet<sup id="fnref:30" class="footnote-ref"><a href="#fn:30" rel="footnote"><span class="hint--top hint--rounded" aria-label="PolarDet: a fast, more precise detector for rotated target in aerial images[×]">[30]</span></a></sup>使用极坐标表示，但参数太多了，不值得借鉴<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><msub><mi>θ</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>θ</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>θ</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>θ</mi><mn>4</mn></msub><mo separator="true">,</mo><msub><mi>r</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>r</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>r</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>r</mi><mn>3</mn></msub><mo separator="true">,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{(x,y,\theta_1,\theta_2,\theta_3,\theta_4,r_1,r_2,r_3,r_3,s)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span></span></li><li>GGHL<sup id="fnref:33" class="footnote-ref"><a href="#fn:33" rel="footnote"><span class="hint--top hint--rounded" aria-label="A General Gaussian Heatmap Label Assignment for Arbitrary-Oriented Object Detection[√]">[33]</span></a></sup>提出了一种Anchor-free的标签自适应分配策略(OLA)，基于二维高斯heatmap来确定proposal</li><li>Beyound BoundingBox<sup id="fnref:31" class="footnote-ref"><a href="#fn:31" rel="footnote"><span class="hint--top hint--rounded" aria-label="Beyond Bounding-Box: Convex-hull Feature Adaptation for Oriented and Densely Packed Object Detection[√]">[31]</span></a></sup>和Oriented Reppoint<sup id="fnref:38" class="footnote-ref"><a href="#fn:38" rel="footnote"><span class="hint--top hint--rounded" aria-label="Oriented RepPoints for Aerial Object Detection[√]">[38]</span></a></sup>使用点集表示，通过Jarvis March算法，找到包围所有采样点的外接多边形</li></ul><p><img src="/img/article/2022/12/01/42.png" alt="" /></p><ul><li>CenterOBB<sup id="fnref:40" class="footnote-ref"><a href="#fn:40" rel="footnote"><span class="hint--top hint--rounded" aria-label="Arbitrarily Oriented Dense Object Detection Based on Center Point Network in Remote Sensing Images[√]">[40]</span></a></sup>提出了一个one stage anchor free的中心点网络</li></ul><p>⭐️基于<strong>Vision Tansformer</strong></p><ul><li>AO2-DETR<sup id="fnref:47" class="footnote-ref"><a href="#fn:47" rel="footnote"><span class="hint--top hint--rounded" aria-label="AO2-DETR: Arbitrary-Oriented Object Detection Transformer[√]">[47]</span></a></sup>将ResNet最后输出层输入Tansformer Block，使用Tansformer来实现自适应感受野,并提出了proposal生成机制，自适应proposal修正模块和旋转感知匹配损失来准确定位对象。</li><li>RBbox<sup id="fnref:49" class="footnote-ref"><a href="#fn:49" rel="footnote"><span class="hint--top hint--rounded" aria-label="Few Could Be Better Than All: Feature Sampling and Grouping for Scene Text Detection[√]">[49]</span></a></sup>使用Tansformer建模来分析采样特征之间的关系，使得前景特征能被正确的分组。并且这样做可以免去anchor generation、NMS等后处理。</li><li>O2-DETR<sup id="fnref:50" class="footnote-ref"><a href="#fn:50" rel="footnote"><span class="hint--top hint--rounded" aria-label="Oriented Object Detection with Transformer[√]">[50]</span></a></sup>完全基于Tansformer的baseline来搭建网络模型</li></ul><p>⭐️基于<strong>Seg</strong>，利用语义分割来实现其它形状的边界检测</p><ul><li>EFN<sup id="fnref:18" class="footnote-ref"><a href="#fn:18" rel="footnote"><span class="hint--top hint--rounded" aria-label="EFN: Field-Based Object Detection for Aerial Images[√]">[18]</span></a></sup>利用语义分割基于二维高斯分布捕获椭圆边界<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{(x_0, y_0, a, b, \theta)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span></span></li></ul><p>⭐️采用<strong>horizonal anchor</strong>先验</p><ul><li>RoI Transformer<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="Towards Multi-class Object Detection in Unconstrained Remote Sensing Imagery[x]">[6]</span></a></sup>将RPN输出的水平锚框通过RoILearnerHRoI转换为旋转锚框RRoI</li></ul><p>这个方法影响了后续许多anchor-base的方法，几乎都是预设水平anchor，然后使用额外的模块来回归成旋转anchor，再进行对齐</p></blockquote><p>主流的旋转目标表征方式分为两种：旋转矩形（OBB）和四边形（QBB）。这两种表征方式都存在边界越界问题和周期性问题</p><ol start="3"><li><p>OBB(旋转框标注，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi><mo>−</mo><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">{\theta-based}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span></span></span></span></span>)：角度参数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">{\theta}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span></span>)的<strong>周期性</strong>带来的<strong>损失的不连续性</strong>和<strong>回归的不一致性</strong><br />缓解旋转目标标注方式在网络训练时产生的边界问题，<strong>由于学习的目标参数具有周期性，在周期变化的边界处会导致损失值突增，因此增大网络的学习难度</strong></p><p>以180度回归的长边定义法中的θ为例，θ ∈[-90,90)；正常训练情况下，网络预测的θ值为88，目标真实θ值为89，网络学习到的角度距离为1，真实情况下的两者差值为1；边界情况下，网络预测的θ值为89，目标真实θ值为-90，网络学习到的角度距离为179，真实情况下的两者差值为1.</p><p><img src="/img/article/2022/12/01/19.png" alt="" /></p></li></ol><blockquote><p>⭐️<strong>从旋转目标定义方式入手</strong>: <strong>定义方式中不含具有周期变化性的参数，却又能表示周期旋转的目标物体</strong>，根本上杜绝边界问题的产生。</p><ul><li>Gliding Vertex<sup id="fnref:16" class="footnote-ref"><a href="#fn:16" rel="footnote"><span class="hint--top hint--rounded" aria-label="Gliding vertex on the horizontal bounding box for multi-oriented object detection[√]">[16]</span></a></sup>采用一种八参数的旋转框标注方式:</li></ul><p><img src="/img/article/2022/12/01/20.png" alt="" /></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>w</mi><mo separator="true">,</mo><mi>h</mi><mo separator="true">,</mo><msub><mi>α</mi><mn>1</mn></msub><mo>=</mo><mfrac><msub><mi>s</mi><mn>1</mn></msub><mi>w</mi></mfrac><mo separator="true">,</mo><msub><mi>α</mi><mn>2</mn></msub><mo>=</mo><mfrac><msub><mi>s</mi><mn>2</mn></msub><mi>h</mi></mfrac><mo separator="true">,</mo><msub><mi>α</mi><mn>3</mn></msub><mo>=</mo><mfrac><msub><mi>s</mi><mn>3</mn></msub><mi>w</mi></mfrac><mo separator="true">,</mo><msub><mi>α</mi><mn>4</mn></msub><mo>=</mo><mfrac><msub><mi>s</mi><mn>4</mn></msub><mi>h</mi></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{(x, y, w, h, \alpha_1=\frac{s_1}{w},\alpha_2=\frac{s_2}{h},\alpha_3=\frac{s_3}{w},\alpha_4=\frac{s_4}{h})}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.7935599999999998em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">h</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">h</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></span></span></p><ul><li>LO-Det<sup id="fnref:17" class="footnote-ref"><a href="#fn:17" rel="footnote"><span class="hint--top hint--rounded" aria-label="LO-Det: Lightweight Oriented Object Detection in Remote Sensing Images[√]">[17]</span></a></sup>提出DSC模块，在Gliding Vertex的基础上，额外用对角线约束来控制OBB的形状:</li></ul><p><img src="/img/article/2022/12/01/21.png" alt="" /></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>w</mi><mo separator="true">,</mo><mi>h</mi><mo separator="true">,</mo><msub><mi>α</mi><mn>1</mn></msub><mo>=</mo><mfrac><msub><mi>s</mi><mn>1</mn></msub><mi>w</mi></mfrac><mo separator="true">,</mo><msub><mi>α</mi><mn>2</mn></msub><mo>=</mo><mfrac><msub><mi>s</mi><mn>2</mn></msub><mi>h</mi></mfrac><mo separator="true">,</mo><msub><mi>α</mi><mn>3</mn></msub><mo>=</mo><mfrac><msub><mi>s</mi><mn>3</mn></msub><mi>w</mi></mfrac><mo separator="true">,</mo><msub><mi>α</mi><mn>4</mn></msub><mo>=</mo><mfrac><msub><mi>s</mi><mn>4</mn></msub><mi>h</mi></mfrac><mo separator="true">,</mo><msub><mi>β</mi><mn>1</mn></msub><mo>=</mo><mfrac><msub><mi>s</mi><mn>13</mn></msub><mi>w</mi></mfrac><mo separator="true">,</mo><msub><mi>β</mi><mn>2</mn></msub><mo>=</mo><mfrac><msub><mi>s</mi><mn>24</mn></msub><mi>h</mi></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{(x, y, w, h, \alpha_1=\frac{s_1}{w},\alpha_2=\frac{s_2}{h},\alpha_3=\frac{s_3}{w},\alpha_4=\frac{s_4}{h},\beta_1=\frac{s_{13}}{w},\beta_2=\frac{s_{24}}{h})}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.7935599999999998em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">h</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">h</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">h</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></span></span></p><ul><li>SAR<sup id="fnref:19" class="footnote-ref"><a href="#fn:19" rel="footnote"><span class="hint--top hint--rounded" aria-label="SAR: Single-Stage Anchor-Free Rotating Object Detection[√]">[19]</span></a></sup>为旋转框设计了一种圆形切割水平矩形框CCH的全新表示，旋转和水平框的参数解耦:<br />后三个参数通过分析几何计算获得，计算时由于数据类型转换，会有浮点数精度损失</li></ul><p><img src="/img/article/2022/12/01/22.png" alt="" /></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo separator="true">,</mo><mi>t</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>α</mi><mo separator="true">,</mo><mi>β</mi><mo separator="true">,</mo><mi>γ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{(l,r,t,b, \alpha, \beta, \gamma)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="mclose">)</span></span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>β</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">{\beta = 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span></span></span>表示取夹角为锐角的矩形， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>γ</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">{\gamma = 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span></span></span>表示取面积更大的矩形，这样就能确定唯一矩形</p><ul><li>BBAVectors<sup id="fnref:22" class="footnote-ref"><a href="#fn:22" rel="footnote"><span class="hint--top hint--rounded" aria-label="Oriented Object Detection in Aerial Images with Box Boundary-Aware Vectors[√]">[22]</span></a></sup>使用了类似FCOS的表达方式，额外使用外接矩形的w,h引入角度信息:</li></ul><p><img src="/img/article/2022/12/01/23.png" alt="" /></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>t</mi><mo separator="true">,</mo><mi>r</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>l</mi><mo separator="true">,</mo><msub><mi>w</mi><mi>e</mi></msub><mo separator="true">,</mo><msub><mi>h</mi><mi>e</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{(t, r, b, l, w_e, h_e)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></span></p><ul><li>APE<sup id="fnref:23" class="footnote-ref"><a href="#fn:23" rel="footnote"><span class="hint--top hint--rounded" aria-label="Adaptive Period Embedding for Representing Oriented Objects in Aerial Images[√]">[23]</span></a></sup> 使用了两个不同周期的参数u1和u2来表示参数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">{\theta}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span></span>，因此随着形状变化，矢量是连续的:</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>w</mi><mo separator="true">,</mo><mi>h</mi><mo separator="true">,</mo><msub><mi>u</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>u</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>u</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mi>c</mi><mi>o</mi><mi>s</mi><mn>4</mn><mi>θ</mi><mo separator="true">,</mo><mi>s</mi><mi>i</mi><mi>n</mi><mn>4</mn><mi>θ</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>u</mi><mn>2</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mi>c</mi><mi>o</mi><mi>s</mi><mn>2</mn><mi>θ</mi><mo separator="true">,</mo><mi>s</mi><mi>i</mi><mi>n</mi><mn>2</mn><mi>θ</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mfrac><mrow><mi>w</mi><mo>−</mo><mi>h</mi></mrow><mrow><mi>λ</mi><mi>h</mi></mrow></mfrac><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{(x, y, w, h, u_1, u_2), u_1 = (cos4\theta, sin4\theta), u_2 = (cos2\theta, sin2\theta) * min(\frac{w-h}{\lambda h}, 1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="mord mathdefault">h</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></span></p><ul><li></li></ul><p>⭐️<strong>从损失函数入手</strong>：<strong>赋予损失函数和角度同样的周期性(边界约束)</strong>，使得边界处θ之间差值可以很大，但loss变化实际很小</p><ul><li><p>SCRDet<sup id="fnref:11" class="footnote-ref"><a href="#fn:11" rel="footnote"><span class="hint--top hint--rounded" aria-label="SCRDet: Towards More Robust Detection for Small, Cluttered and Rotated Objects[√]">[11]</span></a></sup>提出了IoU-smooth L1 Loss</p></li><li><p>RSDet<sup id="fnref:24" class="footnote-ref"><a href="#fn:24" rel="footnote"><span class="hint--top hint--rounded" aria-label="On the Arbitrary-Oriented Object Detection: Classification based Approaches Revisited[√]">[24]</span></a></sup>提出了5参数适用的Loss :<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>l</mi><mrow><mi>m</mi><mi>r</mi></mrow><mrow><mn>5</mn><mi>p</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">{l^{5p}_{mr}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.061108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span><span class="mord mathdefault mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></p></li></ul><p><img src="/img/article/2022/12/01/62.png" alt="" /></p><ul><li>RIDet<sup id="fnref:37" class="footnote-ref"><a href="#fn:37" rel="footnote"><span class="hint--top hint--rounded" aria-label="Optimization for Arbitrary-Oriented Object Detection via Representation Invariance Loss[√]">[37]</span></a></sup> 提出将角度的偏离映射为类似IoU的一种度量来摆脱周期性问题</li></ul><p><img src="/img/article/2022/12/01/43.png" alt="" /></p><p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mn>1</mn><mo>=</mo><mfrac><msub><mi>h</mi><mn>1</mn></msub><mrow><mi>s</mi><mi>i</mi><mi>n</mi><mi>θ</mi></mrow></mfrac><mo separator="true">,</mo><mi>l</mi><mn>1</mn><mo>=</mo><mfrac><msub><mi>h</mi><mn>2</mn></msub><mrow><mi>t</mi><mi>a</mi><mi>n</mi><mi>θ</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">{l1 = \frac{h_1}{sin\theta}, l1 = \frac{h_2}{tan\theta}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2412079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8962079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8962079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span> 计算面积<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub><mo>=</mo><msub><mi>l</mi><mn>1</mn></msub><mo>∗</mo><msub><mi>h</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>S</mi><mn>1</mn><mo>=</mo><mo stretchy="false">(</mo><msub><mi>l</mi><mn>1</mn></msub><mo>+</mo><msub><mi>l</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>∗</mo><mi>h</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">{S_0 = l_1 * h_2,  S1 = (l_1 + l_2) * h2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">h</span><span class="mord">2</span></span></span></span></span></p><p>然后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>θ</mi></msub><mo>=</mo><mfrac><msub><mi>S</mi><mn>0</mn></msub><mrow><mi>S</mi><mn>1</mn></mrow></mfrac><mo>−</mo><mn>0.5</mn><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><mi>α</mi><mo>∗</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>θ</mi></mrow></mfrac><mo>−</mo><mn>0.5</mn></mrow><annotation encoding="application/x-tex">{L_\theta = \frac{S_0}{S1} - 0.5 = \frac{1}{1 + \alpha*cos\theta} - 0.5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2917619999999999em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8884309999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.05764em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.0037em;">α</span><span class="mbin mtight">∗</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span></span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>h</mi><mn>1</mn><mi mathvariant="normal">/</mi><mi>h</mi><mn>2</mn><mo separator="true">,</mo><mi>h</mi><mn>2</mn><mi mathvariant="normal">/</mi><mi>h</mi><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{\alpha = min(h1/h2, h2/h1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault">h</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mord">2</span><span class="mord">/</span><span class="mord mathdefault">h</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p><p>⭐️<strong>把θ由回归问题转为分类问题</strong>:  改变Encoder-Decoder方式,把连续的θ直接离散化，避开边界情况</p><ul><li>CSL<sup id="fnref:24" class="footnote-ref"><a href="#fn:24" rel="footnote"><span class="hint--top hint--rounded" aria-label="On the Arbitrary-Oriented Object Detection: Classification based Approaches Revisited[√]">[24]</span></a></sup>把角度预测任务由回归问题转换为分类问题，比如一度归为一类，更换不同的窗口函数。</li></ul><p>通过引入周期性解决了角度周期性的问题，即使得89和-90两个度数变成是近邻的。</p><p>转换的过程中是会有精度的损失的，比如在一度一类的情况下<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>ω</mi><mo>=</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{(ω=1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>，我们无法预测出0.5度这种结果。</p><blockquote><p>注意:这里还有<a href="https://zhuanlan.zhihu.com/p/111493759">窗口函数的选择实验</a>，结果表明选择高斯函数最好</p></blockquote><p><img src="/img/article/2022/12/01/24.png" alt="" /></p><ul><li>DCL<sup id="fnref:35" class="footnote-ref"><a href="#fn:35" rel="footnote"><span class="hint--top hint--rounded" aria-label="Dense Label Encoding for Boundary Discontinuity Free Rotation Detection[√]">[35]</span></a></sup>是CSL<sup id="fnref:24" class="footnote-ref"><a href="#fn:24" rel="footnote"><span class="hint--top hint--rounded" aria-label="On the Arbitrary-Oriented Object Detection: Classification based Approaches Revisited[√]">[24]</span></a></sup>的优化版本，CSL的ω的变小会引起状态(类别)的成倍增长，这也势必会增大计算量：<br />原本one-hot编码/CSL编码是每有一个类就多出一位，因此DCL使用二进制编码和格雷码来对编码状态进行压缩:</li></ul><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mrow><mi>o</mi><mi>n</mi><mi>e</mi><mo>−</mo><mi>h</mi><mi>o</mi><mi>t</mi></mrow></msub><mo>=</mo><msub><mi>L</mi><mrow><mi>c</mi><mi>s</mi><mi>l</mi></mrow></msub><mo>=</mo><mi>A</mi><mi>R</mi><mi mathvariant="normal">/</mi><mi>ω</mi></mrow><annotation encoding="application/x-tex">{L_{one-hot} = L_{csl} = AR/ω}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">h</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span></span></span></span></span>   ， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mrow><mi>d</mi><mi>c</mi><mi>l</mi></mrow></msub><mo>=</mo><mrow><mo fence="true">⌊</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>A</mi><mi>R</mi><mi mathvariant="normal">/</mi><mi>ω</mi><mo stretchy="false">)</mo><mo fence="true">⌋</mo></mrow></mrow><annotation encoding="application/x-tex">{L_{dcl} = \left \lfloor log_2(AR/ω)   \right \rfloor }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">⌊</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="mclose">)</span><span class="mclose delimcenter" style="top:0em;">⌋</span></span></span></span></span></span></p><p><img src="/img/article/2022/12/01/25.png" alt="" /></p><ul><li>MGAR<sup id="fnref:42" class="footnote-ref"><a href="#fn:42" rel="footnote"><span class="hint--top hint--rounded" aria-label="Multi-Grained Angle Representation for Remote Sensing Object Detection[√]">[42]</span></a></sup> 提出了一种由粗粒度角度分类(CAC)和细粒度角度回归(FAR)组成的多粒度角度表示方法:</li></ul><p>这样先分类，后回归的方法，可以解决CSL的精度损失问题，并把回归的角度控制在锐角范围内</p><p><img src="/img/article/2022/12/01/27.png" alt="" /></p></blockquote><ol start="4"><li><p>QBB(四边形标注，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mo>−</mo><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">{Point-based}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span></span></span></span></span>): 标签点的混淆问题，也被视为BBox的一种越界问题。DOTA数据集中的GT采用基于顶点的八参数的表达形式<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>4</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>4</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{(x_1,y_1,x_2,y_2,x_3,y_3,x_4,y_4)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> ，只规定了(x1,y1)是左上角的点，剩下的点按顺时针顺序排列。</p><p><img src="/img/article/2022/12/01/15.png" alt="图源于19-SAR" /></p><p>具体来讲，当模型给出理想的预测，但是由于给出的预测顶点与GT的真实顶点顺序不符，造成了此时损失值巨大。例如，当物体的角度接近于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>π</mi><mi mathvariant="normal">/</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">{\pi/4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mord">/</span><span class="mord">4</span></span></span></span></span>或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mi>π</mi><mi mathvariant="normal">/</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">{3\pi/4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">3</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mord">/</span><span class="mord">4</span></span></span></span></span>时，左图和右图的实例十分相似，但根据DOTA左上角的点这一定义就变得模糊不清了。我们假设一张图像的GT是左图表示，然后网络预测出来的框是右图，这样点的错位就会造成Loss相减时变得很大。</p></li></ol><p><img src="/img/article/2022/12/01/16.png" alt="图源于21-Mask OBB" /></p><blockquote><ul><li><p>OPLD<sup id="fnref:27" class="footnote-ref"><a href="#fn:27" rel="footnote"><span class="hint--top hint--rounded" aria-label="Learning Point-Guided Localization for Detection in Remote Sensing Images[√]">[27]</span></a></sup>将定位从回归问题转换为关键点评估(EndPoint Score)问题，并引入中心点评估增加准确性。</p></li><li><p>RIDet<sup id="fnref:37" class="footnote-ref"><a href="#fn:37" rel="footnote"><span class="hint--top hint--rounded" aria-label="Optimization for Arbitrary-Oriented Object Detection via Representation Invariance Loss[√]">[37]</span></a></sup>提出使用匈牙利算法进行关键点的匹配</p></li></ul><p><img src="/img/article/2022/12/01/17.png" alt="" /></p><p>⭐️同样<strong>设计损失函数</strong>解决边界问题:</p><ul><li>RSDet<sup id="fnref:24" class="footnote-ref"><a href="#fn:24" rel="footnote"><span class="hint--top hint--rounded" aria-label="On the Arbitrary-Oriented Object Detection: Classification based Approaches Revisited[√]">[24]</span></a></sup>提出了8参数适用的Loss :<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>l</mi><mrow><mi>m</mi><mi>r</mi></mrow><mrow><mn>8</mn><mi>p</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">{l^{8p}_{mr}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.061108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span><span class="mord mathdefault mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></li></ul><p><img src="/img/article/2022/12/01/63.png" alt="" /></p><ul><li>P2P<sup id="fnref:45" class="footnote-ref"><a href="#fn:45" rel="footnote"><span class="hint--top hint--rounded" aria-label="Polygon-to-Polygon Distance Loss for Rotated Object Detection[√]">[45]</span></a></sup>把两个RBbox之间的回归转化为两个多边形之间距离的优化:<br />(基本上是纯数学公式会推导，定义了点到多边形的面积公式=&gt;推广到多边形到多边形的面积公式=&gt;推广到多边形到多边形的距离公式，很抽象)</li></ul><p><img src="/img/article/2022/12/01/64.png" alt="" /></p></blockquote><ol start="5"><li>特征没有实现真正意义上的对齐<sup id="fnref:13" class="footnote-ref"><a href="#fn:13" rel="footnote"><span class="hint--top hint--rounded" aria-label="Dynamic Refinement Network for Oriented and Densely Packed Object Detection[√]">[13]</span></a></sup>，卷积网络本身不具有旋转不变性，如何构造旋转等变性=&gt;需要设计anchor refine模块</li></ol><blockquote><ul><li><p>DRN<sup id="fnref:13" class="footnote-ref"><a href="#fn:13" rel="footnote"><span class="hint--top hint--rounded" aria-label="Dynamic Refinement Network for Oriented and Densely Packed Object Detection[√]">[13]</span></a></sup></p></li><li><p>CFC-Net<sup id="fnref:14" class="footnote-ref"><a href="#fn:14" rel="footnote"><span class="hint--top hint--rounded" aria-label="CFC-Net: A Critical Feature Capturing Network for Arbitrary-Oriented Object Detection in Remote Sensing Images[√]">[14]</span></a></sup>设计了R-ARM</p></li><li><p>TricubeNet<sup id="fnref:20" class="footnote-ref"><a href="#fn:20" rel="footnote"><span class="hint--top hint--rounded" aria-label="TricubeNet: 2D Kernel-Based Object Representation for Weakly-Occluded[×]">[20]</span></a></sup>提出了多角度卷积(MAC)模块，设计了Rotation Conv，通过<strong>旋转特征图</strong>，来提取旋转等(不)变特征。</p><p><img src="/img/article/2022/12/01/41.png" alt="" /></p></li><li><p>S2A-Net<sup id="fnref:48" class="footnote-ref"><a href="#fn:48" rel="footnote"><span class="hint--top hint--rounded" aria-label="Align Deep Features for Oriented Object Detection[√]">[48]</span></a></sup>提出特征对准模块FAM，FAM可以通过anchor refine-network来生成高质量的anchor，并通过新颖的对齐卷积，自适应的对齐卷积特征，实现深度特征对齐。</p></li></ul></blockquote><ol start="6"><li>密集目标</li></ol><blockquote><ul><li><p>Beyond Bounding-Box<sup id="fnref:31" class="footnote-ref"><a href="#fn:31" rel="footnote"><span class="hint--top hint--rounded" aria-label="Beyond Bounding-Box: Convex-hull Feature Adaptation for Oriented and Densely Packed Object Detection[√]">[31]</span></a></sup> 采用凸包表示，并且提出了凸包特征自适应(CFA)，来解决对象之间的感受野相交而导致特征混叠</p><p><img src="/img/article/2022/12/01/50.png" alt="" /></p></li><li><p>CLT-Det<sup id="fnref:36" class="footnote-ref"><a href="#fn:36" rel="footnote"><span class="hint--top hint--rounded" aria-label="CLT-Det: Correlation Learning Based on Transformer for Detecting Dense Objects in Remote Sensing Images[√]">[36]</span></a></sup> 在FPN的最后一个阶段加入Tansfomrer Block以增强密集对象表征能力，在分类阶段采用CTM下也许多个密集对象分类的相关性</p></li></ul></blockquote><hr /><h3 id="author"><a class="markdownIt-Anchor" href="#author"></a> Author</h3><p>一些大佬的工作专栏收集:</p><p><strong>DingJian</strong>(武大-夏桂松)的工作</p><p>FR-O (DOTA)<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="DOTA: A Large-Scale Dataset for Object Detection in Aerial Images[√]">[1]</span></a></sup></p><p>RoI Transformer<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="Learning RoI Transformer for Oriented Object Detection in Aerial Images[√]">[7]</span></a></sup></p><p>Mask OBB<sup id="fnref:21" class="footnote-ref"><a href="#fn:21" rel="footnote"><span class="hint--top hint--rounded" aria-label="Mask OBB: A Semantic Attention-Based Mask Oriented Bounding Box Representation for Multi-Category Object Detection in Aerial Images[√]">[21]</span></a></sup></p><p>S2A-Net<sup id="fnref:48" class="footnote-ref"><a href="#fn:48" rel="footnote"><span class="hint--top hint--rounded" aria-label="Align Deep Features for Oriented Object Detection[√]">[48]</span></a></sup></p><p><strong>YangXue</strong>(上交-严骏驰)的工作：</p><p>R-DFPN</p><p>SCRDet<sup id="fnref:11" class="footnote-ref"><a href="#fn:11" rel="footnote"><span class="hint--top hint--rounded" aria-label="SCRDet: Towards More Robust Detection for Small, Cluttered and Rotated Objects[√]">[11]</span></a></sup></p><p>R3Det<sup id="fnref:15" class="footnote-ref"><a href="#fn:15" rel="footnote"><span class="hint--top hint--rounded" aria-label="R3Det: Refined Single-Stage Detector with Feature Refinement for Rotating Object[√]">[15]</span></a></sup></p><p>分析了SkewIOU(RRPN<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="Arbitrary-Oriented Scene Text Detection via Rotation Proposals[√]">[4]</span></a></sup>提出)与Smooth L1 IOU的优缺点:</p><p>得出的结论就是SmoothL1 Loss不适合旋转目标检测，而SkewIOU对横纵比敏感。</p><blockquote><p>当角度偏差固定时，SkewIoU会随着长宽比增大而急剧下降，而Smooth L1损失不变 。</p><p>当横纵比固定时，  Smooth L1损失随着角度偏差的增大而增大, SkewIoU几乎不变。</p></blockquote><p>剖析了特征错位的根本原因，并采用SkewIoU判断<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>w</mi><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y,w,h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span>，Smooth L1判断<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>的方式</p><p>CSL<sup id="fnref:24" class="footnote-ref"><a href="#fn:24" rel="footnote"><span class="hint--top hint--rounded" aria-label="On the Arbitrary-Oriented Object Detection: Classification based Approaches Revisited[√]">[24]</span></a></sup></p><p>DCL<sup id="fnref:34" class="footnote-ref"><a href="#fn:34" rel="footnote"><span class="hint--top hint--rounded" aria-label="EAutoDet: Efficient Architecture Search for Object Detection[√]">[34]</span></a></sup></p><p>RSDet<sup id="fnref:25" class="footnote-ref"><a href="#fn:25" rel="footnote"><span class="hint--top hint--rounded" aria-label="Learning Modulated Loss for Rotated Object Detection[√]">[25]</span></a></sup></p><p>SLA<sup id="fnref:26" class="footnote-ref"><a href="#fn:26" rel="footnote"><span class="hint--top hint--rounded" aria-label="Sparse Label Assignment for Oriented Object Detection in Aerial Images[×]">[26]</span></a></sup></p><p><strong>Ming71</strong>(北理工-缪玲娟)的工作:</p><p>DAL<sup id="fnref:32" class="footnote-ref"><a href="#fn:32" rel="footnote"><span class="hint--top hint--rounded" aria-label="Dynamic Anchor Learning for Arbitrary-Oriented Object Detection[√]">[32]</span></a></sup></p><p>引入matching drgee(MD，匹配度)的概念，利用anchor的空间对齐、特征对齐能力和回归不确定性等先验信息来评估定位能力，定义如下:</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>d</mi><mo>=</mo><mi>α</mi><mo>∗</mo><mi>s</mi><mi>a</mi><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>f</mi><mi>a</mi><mo>−</mo><msup><mi>u</mi><mi>γ</mi></msup></mrow><annotation encoding="application/x-tex">{md= \alpha * sa + (1 - \alpha)*fa - u^\gamma}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05556em;">γ</span></span></span></span></span></span></span></span></span></span></span></span>  , 其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mo>=</mo><mi mathvariant="normal">∣</mi><mi>s</mi><mi>a</mi><mo>−</mo><mi>f</mi><mi>a</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">u = |sa - fa|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">s</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mord">∣</span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">{sa}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="mord mathdefault">a</span></span></span></span></span>表示anchor与GT之间的IoU，表示空间对齐的先验信息;<br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">{fa}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span></span></span></span></span>表示predict box与GT之间的IoU，表示特征对齐能力的先验信息;<br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">{u}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">u</span></span></span></span></span>是惩罚项，表示前后IoU之间的变化。</p><p>利用匹配度，就可以进行动态anchor选择，以获得更好的标签分配:<br />在训练阶段，就用匹配度而不是IoU，设置阈值来筛选正样本。</p><p>CFC-Net<sup id="fnref:14" class="footnote-ref"><a href="#fn:14" rel="footnote"><span class="hint--top hint--rounded" aria-label="CFC-Net: A Critical Feature Capturing Network for Arbitrary-Oriented Object Detection in Remote Sensing Images[√]">[14]</span></a></sup></p><p>论文的出发点也是通过实验而来的.</p><p>74%左右的正样本anchor回归的pred box后依然是高质量样本（IoU&gt;0.5）；近一半的高质量样本回归自负样本，这说明负样本还有很大的利用空间，当前基于输入IoU的label assignment选正样本的效率并不高，有待优化</p><p>引入了关键特征这一基本概念，通过可视化CNN提取特征，发现用于分类和回归的对象所需的关键特征并不总是均匀分布的，而是可能分布在船头或船尾上。大量的负面锚很好地捕捉关键特征，但无法被好好利用</p><p>CFC-Net可以好好看看，因为论文中有很多skill，包括之前的工作DAL:</p><ul><li><p>通道注意力，空间注意力 =&gt; 还有对注意力的极化操作</p></li><li><p>R-ARM, anchor的refine过程， +  DAL动态锚的选取(DAL只要一个预设水平的anchor)</p></li></ul><p>SLA<sup id="fnref:26" class="footnote-ref"><a href="#fn:26" rel="footnote"><span class="hint--top hint--rounded" aria-label="Sparse Label Assignment for Oriented Object Detection in Aerial Images[×]">[26]</span></a></sup></p><p>我认为这个也是因为物体高横纵比而导致的一种问题:<br />密集标签分配问题: 正样本的高Class Score不能够保证精确的定位结果，因此在NMS后可能发生错误的重复检测</p><p><img src="/img/article/2022/12/01/70.png" alt="" /></p><p><img src="/img/article/2022/12/01/71.png" alt="" /></p><ul><li>引入了稀疏标签分配策略，包括两个部分：正样本的后验抑制(P-NMS)和负样本的IoU平衡代表性采样。</li><li>提出了位置特征敏感的特征金字塔网络PS-FPN</li><li>采用了一种新的距离旋转IOU D-RIoU进行RBox的回归</li></ul><p>RIDet<sup id="fnref:37" class="footnote-ref"><a href="#fn:37" rel="footnote"><span class="hint--top hint--rounded" aria-label="Optimization for Arbitrary-Oriented Object Detection via Representation Invariance Loss[√]">[37]</span></a></sup></p><p><strong>HuangZhanchao</strong>(北理工)</p><p>基本只投遥感顶刊，Network偏向基于Anchor free的轻量级网络，喜欢用嵌入式设备(Jetson AGX Xavier)部署模型。</p><p>LO-Det<sup id="fnref:17" class="footnote-ref"><a href="#fn:17" rel="footnote"><span class="hint--top hint--rounded" aria-label="LO-Det: Lightweight Oriented Object Detection in Remote Sensing Images[√]">[17]</span></a></sup></p><p>TS-Conv<sup id="fnref:44" class="footnote-ref"><a href="#fn:44" rel="footnote"><span class="hint--top hint--rounded" aria-label="Task-wise Sampling Convolutions for Arbitrary-Oriented Object Detection in Aerial Images[√]">[44]</span></a></sup></p><hr /><h2 id="dota-doai"><a class="markdownIt-Anchor" href="#dota-doai"></a> DOTA-DOAI</h2><h3 id="dota10-task1"><a class="markdownIt-Anchor" href="#dota10-task1"></a> DOTA1.0 (Task1)</h3><p>recommend to read in DOTA1.0</p><p>Hourglass是CenterNet的Backbone</p><style>table{    font-size: 13px;}table th:first-of-type {    font-size: 15px;    width: 15%;}table th:nth-of-type(2) {    font-size: 15px;    width: 15%;}table th:nth-of-type(3) {    font-size: 15px;    width: 15%;}table th:nth-of-type(4) {    font-size: 15px;    width: 15%;}table th:nth-of-type(5) {    font-size: 15px;    width: 15%;}table th:nth-of-type(6) {    font-size: 15px;    width: 25%;}</style><table><thead><tr><th style="text-align:center">Model</th><th style="text-align:center">Backbone</th><th style="text-align:center">mAP</th><th style="text-align:center">Paper Link</th><th style="text-align:center">Code Link</th><th style="text-align:center">Remark</th><th>Year</th></tr></thead><tbody><tr><td style="text-align:center">FR-O (DOTA)</td><td style="text-align:center">ResNet101</td><td style="text-align:center">52.93</td><td style="text-align:center"><a href="http://openaccess.thecvf.com/content_cvpr_2018/html/Xia_DOTA_A_Large-Scale_CVPR_2018_paper.html">CVPR2018</a></td><td style="text-align:center"><a href="https://github.com/jessemelpolio/Faster_RCNN_for_DOTA">MXNet</a></td><td style="text-align:center">DOTA dataset, baseline</td><td></td></tr><tr><td style="text-align:center">PIoU Loss</td><td style="text-align:center">DLA34</td><td style="text-align:center">60.5</td><td style="text-align:center"><a href="https://arxiv.org/abs/2007.09584">ECCV2020</a></td><td style="text-align:center"><a href="https://github.com/clobotics/piou">PyTorch</a></td><td style="text-align:center">IoU loss</td><td></td></tr><tr><td style="text-align:center">R2CNN</td><td style="text-align:center">ResNet101</td><td style="text-align:center">60.67</td><td style="text-align:center"><a href="https://arxiv.org/abs/1706.09579">arXiv:1706.09579</a></td><td style="text-align:center"><a href="https://github.com/DetectionTeamUCAS/R2CNN_Faster-RCNN_Tensorflow">TF</a></td><td style="text-align:center">scene text, multi-task, different pooled sizes, baseline</td><td></td></tr><tr><td style="text-align:center">RRPN</td><td style="text-align:center">ResNet101</td><td style="text-align:center">61.01</td><td style="text-align:center"><a href="https://ieeexplore.ieee.org/document/8323240">TMM</a> <a href="https://arxiv.org/pdf/1703.01086.pdf">arXiv:1703.01086</a></td><td style="text-align:center"><a href="https://github.com/DetectionTeamUCAS/RRPN_Faster-RCNN_Tensorflow">TF</a></td><td style="text-align:center">scene text, rotation proposals, baseline</td><td></td></tr><tr><td style="text-align:center">Axis Learning</td><td style="text-align:center">ResNet101</td><td style="text-align:center">65.98</td><td style="text-align:center"><a href="https://www.mdpi.com/2072-4292/12/6/908">Remote Sensing</a></td><td style="text-align:center"><a href="https://github.com/RSIA-LIESMARS-WHU/AxisLearning">Pytorch</a></td><td style="text-align:center">axis, anchor free</td><td></td></tr><tr><td style="text-align:center">ICN</td><td style="text-align:center">ResNet101</td><td style="text-align:center">68.16</td><td style="text-align:center"><a href="https://link.springer.com/chapter/10.1007/978-3-030-20893-6_10">ACCV2018</a></td><td style="text-align:center">-</td><td style="text-align:center">image cascade, multi-scale</td><td></td></tr><tr><td style="text-align:center">RoI Transformer</td><td style="text-align:center">ResNet101</td><td style="text-align:center">69.56</td><td style="text-align:center"><a href="http://openaccess.thecvf.com/content_CVPR_2019/papers/Ding_Learning_RoI_Transformer_for_Oriented_Object_Detection_in_Aerial_Images_CVPR_2019_paper.pdf">CVPR2019</a></td><td style="text-align:center"><a href="https://github.com/dingjiansw101/RoITransformer_DOTA">MXNet</a>, <a href="https://github.com/dingjiansw101/AerialDetection">PyTorch</a>, <a href="https://github.com/open-mmlab/mmrotate">MMRotate</a></td><td style="text-align:center">roi transformer</td><td></td></tr><tr><td style="text-align:center">ProbIoU</td><td style="text-align:center">ResNet50</td><td style="text-align:center">70.04</td><td style="text-align:center"><a href="https://arxiv.org/abs/2106.06072">arXiv:2106.06072</a></td><td style="text-align:center"><a href="https://github.com/ProbIOU">TF</a></td><td style="text-align:center">gaussian bounding boxes, hellinger distance</td><td></td></tr><tr><td style="text-align:center">ACE</td><td style="text-align:center">DLA34</td><td style="text-align:center">71.7</td><td style="text-align:center"><a href="https://ieeexplore.ieee.org/document/9761381">TIP</a></td><td style="text-align:center">-</td><td style="text-align:center">corner point</td><td></td></tr><tr><td style="text-align:center">P-RSDet</td><td style="text-align:center">ResNet101</td><td style="text-align:center">72.30</td><td style="text-align:center"><a href="https://ieeexplore.ieee.org/abstract/document/9272784/">Access</a></td><td style="text-align:center">-</td><td style="text-align:center">anchor free, polar coordinates</td><td></td></tr><tr><td style="text-align:center">SCRDet</td><td style="text-align:center">ResNet101</td><td style="text-align:center">72.61</td><td style="text-align:center"><a href="http://openaccess.thecvf.com/content_ICCV_2019/papers/Yang_SCRDet_Towards_More_Robust_Detection_for_Small_Cluttered_and_Rotated_ICCV_2019_paper.pdf">ICCV2019</a></td><td style="text-align:center"><a href="https://github.com/SJTU-Thinklab-Det/R3Det_Tensorflow">RetinaNet-based</a>, <a href="https://github.com/DetectionTeamUCAS/RetinaNet_Tensorflow_Rotation">R3Det-based</a></td><td style="text-align:center">attention, angular boundary problem</td><td></td></tr><tr><td style="text-align:center">O2-DNet</td><td style="text-align:center">Hourglass104</td><td style="text-align:center">72.8</td><td style="text-align:center"><a href="https://www.sciencedirect.com/science/article/pii/S0924271620302690">ISPRS</a>, <a href="https://arxiv.org/abs/1912.10694">arXiv:1912.10694</a></td><td style="text-align:center">-</td><td style="text-align:center">centernet, anchor free</td><td>2020</td></tr><tr><td style="text-align:center">DRN</td><td style="text-align:center">Hourglass104</td><td style="text-align:center">73.23</td><td style="text-align:center"><a href="https://arxiv.org/abs/2005.09973">CVPR2020</a></td><td style="text-align:center"><a href="https://github.com/Anymake/DRN_CVPR2020">code</a></td><td style="text-align:center">centernet, feature selection module, dynamic refinement head, new dataset (SKU110K-R)</td><td>2020</td></tr><tr><td style="text-align:center">CFC-Net</td><td style="text-align:center">ResNet101</td><td style="text-align:center">73.50</td><td style="text-align:center"><a href="https://ieeexplore.ieee.org/document/9488629">TGRS</a></td><td style="text-align:center"><a href="https://github.com/ming71/CFC-Net">PyTorch</a></td><td style="text-align:center">critical feature, label assign, refine</td><td>2021</td></tr><tr><td style="text-align:center">R3Det</td><td style="text-align:center">ResNet101</td><td style="text-align:center">73.79</td><td style="text-align:center"><a href="https://arxiv.org/abs/1908.05612">AAAI2021</a></td><td style="text-align:center"><a href="https://github.com/yangxue0827/RotationDetection">TF</a>, <a href="https://github.com/SJTU-Thinklab-Det/r3det-on-mmdetection">r3det-on-mmdetection</a>, <a href="https://github.com/SJTU-Thinklab-Det/r3det-pytorch">r3det-pytorch</a>, <a href="https://github.com/open-mmlab/mmrotate">MMRotate</a></td><td style="text-align:center">refined single stage, feature alignment</td><td></td></tr><tr><td style="text-align:center">Gliding Vertex</td><td style="text-align:center">ResNet101</td><td style="text-align:center">75.02</td><td style="text-align:center"><a href="https://ieeexplore.ieee.org/document/9001201">TPAMI</a> <a href="https://arxiv.org/abs/1911.09358">arXiv:1911.09358</a></td><td style="text-align:center"><a href="https://github.com/MingtaoFu/gliding_vertex">PyTorch</a>, <a href="https://github.com/open-mmlab/mmrotate">MMRotate</a></td><td style="text-align:center">quadrilateral bbox</td><td>2020</td></tr><tr><td style="text-align:center">LO-Det</td><td style="text-align:center">Darknet53</td><td style="text-align:center">75.24</td><td style="text-align:center"><a href="https://ieeexplore.ieee.org/document/9390310">TGRS</a>, <a href="https://arxiv.org/abs/2209.07709">arXiv:2209.07709</a></td><td style="text-align:center"><a href="https://github.com/Shank2358/LO-Det">PyTorch</a></td><td style="text-align:center">lightweight</td><td>2022</td></tr><tr><td style="text-align:center">EFN</td><td style="text-align:center">U-Net</td><td style="text-align:center">75.27</td><td style="text-align:center"><a href="https://search.proquest.com/docview/2442440949?pq-origsite=gscholar&amp;fromopenview=true">Preprints</a></td><td style="text-align:center">-</td><td style="text-align:center">Field-based</td><td>2020</td></tr><tr><td style="text-align:center">SAR</td><td style="text-align:center">ResNet152</td><td style="text-align:center">75.26</td><td style="text-align:center"><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9256343">Access</a></td><td style="text-align:center">-</td><td style="text-align:center">越界分析和表征方式</td><td>2020</td></tr><tr><td style="text-align:center">TricubeNet</td><td style="text-align:center">Hourglass104</td><td style="text-align:center">75.26</td><td style="text-align:center"><a href="https://arxiv.org/abs/2104.11435">WACV2022</a></td><td style="text-align:center"><a href="https://github.com/qjadud1994/TricubeNet">code</a></td><td style="text-align:center">2D tricube kernel</td><td>2021</td></tr><tr><td style="text-align:center">Mask OBB</td><td style="text-align:center">ResNeXt101</td><td style="text-align:center">75.33</td><td style="text-align:center"><a href="https://www.mdpi.com/2072-4292/11/24/2930/htm">Remote Sensing</a></td><td style="text-align:center">-</td><td style="text-align:center">主要看越界分析</td><td>2019</td></tr><tr><td style="text-align:center">BBAVectors</td><td style="text-align:center">ResNet101</td><td style="text-align:center">75.36</td><td style="text-align:center"><a href="https://arxiv.org/abs/2008.07043">WACV2021</a></td><td style="text-align:center"><a href="https://github.com/yijingru/BBAVectors-Oriented-Object-Detection">PyTorch</a></td><td style="text-align:center">keypoint based</td><td>2020</td></tr><tr><td style="text-align:center">APE</td><td style="text-align:center">ResNeXt101(32x4)</td><td style="text-align:center">75.75</td><td style="text-align:center"><a href="https://ieeexplore.ieee.org/abstract/document/9057525">TGRS</a> <a href="https://arxiv.org/abs/1906.09447">arXiv:1906.09447</a></td><td style="text-align:center">-</td><td style="text-align:center">adaptive   period embedding, length independent IoU (LIIoU)</td><td>2019</td></tr><tr><td style="text-align:center">CSL</td><td style="text-align:center">ResNet152</td><td style="text-align:center">76.17</td><td style="text-align:center"><a href="http://arxiv.org/abs/2003.05597">ECCV2020</a></td><td style="text-align:center">TF, MMRotate, Pytorch: YOLOv5_DOTA_OBB (CSL)</td><td style="text-align:center">编码解决边界问题</td><td>2020</td></tr><tr><td style="text-align:center">RSDet/RSDet++</td><td style="text-align:center">ResNet152</td><td style="text-align:center">76.3</td><td style="text-align:center"><a href="https://ojs.aaai.org/index.php/AAAI/article/view/16347">AAAI2021</a>/<a href="https://arxiv.org/abs/2109.11906">TCSVT</a></td><td style="text-align:center"><a href="https://github.com/yangxue0827/RotationDetection">TF</a></td><td style="text-align:center">quadrilateral   bbox, angular boundary problem</td><td>2021</td></tr><tr><td style="text-align:center">SLA</td><td style="text-align:center">ResNet50</td><td style="text-align:center">76.36</td><td style="text-align:center"><a href="https://www.mdpi.com/2072-4292/13/14/2664/htm">Remote Sensing</a></td><td style="text-align:center"><a href="https://github.com/ming71/SLA">PyTorch</a></td><td style="text-align:center">sparse   label assignment</td><td>2021</td></tr><tr><td style="text-align:center">OPLD</td><td style="text-align:center">ResNet101</td><td style="text-align:center">76.43</td><td style="text-align:center"><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9252176">J-STARS</a></td><td style="text-align:center"><a href="https://github.com/yf19970118/OPLD-Pytorch">PyTorch</a></td><td style="text-align:center">boundary   problem, point-guided</td><td>2021</td></tr><tr><td style="text-align:center">Polar Ray(PRNet)</td><td style="text-align:center">ResNet101</td><td style="text-align:center">76.5</td><td style="text-align:center"><a href="https://dl.acm.org/doi/10.1145/3474085.3475457">ACM MM2021</a></td><td style="text-align:center">-</td><td style="text-align:center">polar   rays representation</td><td>2021</td></tr><tr><td style="text-align:center">SIoU</td><td style="text-align:center">ResNet50</td><td style="text-align:center">76.54</td><td style="text-align:center"><a href="https://ieeexplore.ieee.org/document/9661350">JSTARS</a></td><td style="text-align:center">-</td><td style="text-align:center">splicing   intersection over union</td><td>2022</td></tr><tr><td style="text-align:center">PolarDet</td><td style="text-align:center">ResNet101</td><td style="text-align:center">76.64</td><td style="text-align:center"><a href="https://www.tandfonline.com/doi/epub/10.1080/01431161.2021.1931535?needAccess=true">IJRS</a> <a href="https://arxiv.org/abs/2010.08720">arXiv:2010.08720</a></td><td style="text-align:center">-</td><td style="text-align:center">这篇文章不推荐看</td><td>2021</td></tr><tr><td style="text-align:center">Beyond   Bounding-Box(CFA)</td><td style="text-align:center">ResNet152</td><td style="text-align:center">76.67</td><td style="text-align:center"><a href="https://openaccess.thecvf.com/content/CVPR2021/papers/Guo_Beyond_Bounding-Box_Convex-Hull_Feature_Adaptation_for_Oriented_and_Densely_Packed_CVPR_2021_paper.pdf">CVPR2021</a></td><td style="text-align:center">PyTorch, MMRotate</td><td style="text-align:center">point-based,   reppoints</td><td>2021</td></tr><tr><td style="text-align:center">DAL</td><td style="text-align:center">ResNet50</td><td style="text-align:center">76.95</td><td style="text-align:center"><a href="https://arxiv.org/abs/2012.04150">AAAI2021</a></td><td style="text-align:center"><a href="https://github.com/ming71/DAL">PyTorch</a></td><td style="text-align:center">label   assign</td><td>2020</td></tr><tr><td style="text-align:center">GGHL</td><td style="text-align:center">DarkNet53</td><td style="text-align:center">76.95</td><td style="text-align:center"><a href="https://ieeexplore.ieee.org/abstract/document/9709203">TIP</a></td><td style="text-align:center"><a href="https://github.com/Shank2358/GGHL">PyTorch</a></td><td style="text-align:center">gaussian heatmap labeling</td><td>2022</td></tr><tr><td style="text-align:center">EAutoDet</td><td style="text-align:center">DarkNet53</td><td style="text-align:center">77.05</td><td style="text-align:center"><a href="https://arxiv.org/abs/2203.10747">arXiv:2203.10747</a></td><td style="text-align:center">-</td><td style="text-align:center">nas, yolov5</td><td>2022</td></tr><tr><td style="text-align:center">DCL</td><td style="text-align:center">ResNet152</td><td style="text-align:center">77.37</td><td style="text-align:center"><a href="https://arxiv.org/abs/2011.09670">CVPR2021</a></td><td style="text-align:center"><a href="https://github.com/yangxue0827/RotationDetection">TF</a></td><td style="text-align:center">boundary problem</td><td>2021</td></tr><tr><td style="text-align:center">CLT-Det</td><td style="text-align:center">ResNet101</td><td style="text-align:center">77.45</td><td style="text-align:center"><a href="https://ieeexplore.ieee.org/document/9878347/">TGRS</a></td><td style="text-align:center">-</td><td style="text-align:center">transformer,   思路简单但值得一看</td><td>2022</td></tr><tr><td style="text-align:center">RIDet</td><td style="text-align:center">ResNet50</td><td style="text-align:center">77.62</td><td style="text-align:center"><a href="https://ieeexplore.ieee.org/abstract/document/9555916">GRSL</a></td><td style="text-align:center">PyTorch, TF</td><td style="text-align:center">值得一看,最好读arxiv版的</td><td>2021</td></tr><tr><td style="text-align:center">Oriented   RepPoints</td><td style="text-align:center">Swin-Tiny</td><td style="text-align:center">77.63</td><td style="text-align:center"><a href="https://arxiv.org/abs/2105.11111">CVPR2022</a></td><td style="text-align:center">PyTorch, MMRotate</td><td style="text-align:center">point-based,   reppoints</td><td>2022</td></tr><tr><td style="text-align:center">RSP</td><td style="text-align:center">ViTAEv2-S</td><td style="text-align:center">77.72</td><td style="text-align:center"><a href="https://arxiv.org/abs/2204.02825">arXiv:2204.02825</a></td><td style="text-align:center"><a href="https://github.com/ViTAE-Transformer/ViTAE-Transformer-Remote-Sensing">PyTorch</a></td><td style="text-align:center">remote sensing   pretrain</td><td>2022</td></tr><tr><td style="text-align:center">CenterOBB</td><td style="text-align:center">DLA-34</td><td style="text-align:center">77.85</td><td style="text-align:center"><a href="https://www.mdpi.com/2072-4292/14/7/1536">Remote Sensing</a></td><td style="text-align:center">-</td><td style="text-align:center">基于centernet的缝合怪:    CSL&amp;ATSS</td><td>2022</td></tr><tr><td style="text-align:center">FSDet</td><td style="text-align:center">ResNet50</td><td style="text-align:center">77.85</td><td style="text-align:center"><a href="https://ieeexplore.ieee.org/document/9780146">TGRS</a></td><td style="text-align:center">-</td><td style="text-align:center">很值得一读;也是西电的</td><td>2022</td></tr><tr><td style="text-align:center">MGAR</td><td style="text-align:center">DarkNet53</td><td style="text-align:center">78.29</td><td style="text-align:center"><a href="https://arxiv.org/abs/2209.02884">arXiv:2209.02884</a></td><td style="text-align:center">-</td><td style="text-align:center">angle   classification</td><td>2022</td></tr><tr><td style="text-align:center">FR-Est</td><td style="text-align:center">ResNet101-DCN</td><td style="text-align:center">78.49</td><td style="text-align:center"><a href="https://ieeexplore.ieee.org/abstract/document/9194345">TGRS</a></td><td style="text-align:center">-</td><td style="text-align:center">方法太老，不推荐看</td><td>2021</td></tr><tr><td style="text-align:center">TS-Conv</td><td style="text-align:center">DarkNet53</td><td style="text-align:center">78.75</td><td style="text-align:center"><a href="https://arxiv.org/abs/2209.02200">arXiv:2209.02200</a></td><td style="text-align:center"><a href="https://github.com/Shank2358/TS-Conv">PyTorch</a></td><td style="text-align:center">dynamic label   assignment, task-wise samping</td><td>2022</td></tr><tr><td style="text-align:center">P2P</td><td style="text-align:center">ResNet101</td><td style="text-align:center">79.15</td><td style="text-align:center"><a href="https://www.aaai.org/AAAI22Papers/AAAI-8470.YangY.pdf">AAAI2022</a></td><td style="text-align:center">-</td><td style="text-align:center">poly iou loss</td><td>2022</td></tr><tr><td style="text-align:center">SASM</td><td style="text-align:center">ResNeXt101</td><td style="text-align:center">79.17</td><td style="text-align:center"><a href="https://www.aaai.org/AAAI22Papers/AAAI-2171.HouL.pdf">AAAI2022</a></td><td style="text-align:center">MMRotate, PyTorch</td><td style="text-align:center">label assign</td><td>2022</td></tr><tr><td style="text-align:center">AO2-DETR</td><td style="text-align:center">ResNet50</td><td style="text-align:center">79.22</td><td style="text-align:center"><a href="https://arxiv.org/abs/2205.12785">arXiv:2205.12785</a></td><td style="text-align:center"><a href="https://github.com/Ixiaohuihuihui/AO2-DETR">PyTorch</a></td><td style="text-align:center">detr, feature   refinement</td><td>2022</td></tr><tr><td style="text-align:center">S2A-Net</td><td style="text-align:center">ResNet50/ResNet101</td><td style="text-align:center">79.42/79.15</td><td style="text-align:center"><a href="https://ieeexplore.ieee.org/document/9377550">TGRS</a></td><td style="text-align:center">PyTorch, MMRotate</td><td style="text-align:center">refined single   stage, feature alignment</td><td>2022</td></tr><tr><td style="text-align:center">RBox</td><td style="text-align:center">ResNet50</td><td style="text-align:center">79.59</td><td style="text-align:center"><a href="https://arxiv.org/abs/2203.15221">CVPR2022</a></td><td style="text-align:center">-</td><td style="text-align:center">transformer,   feature sampling and grouping</td><td>2022</td></tr><tr><td style="text-align:center">O2DETR</td><td style="text-align:center">ResNet50</td><td style="text-align:center">79.66</td><td style="text-align:center"><a href="https://arxiv.org/abs/2106.03146">arXiv:2106.03146</a></td><td style="text-align:center">-</td><td style="text-align:center">deformable detr,   transformer</td><td>2021</td></tr></tbody></table><h2 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h2><p>其中引用的极少的 =&gt; 8   18 20  28  29  34    36<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://openaccess.thecvf.com/content_cvpr_2018/html/Xia_DOTA_A_Large-Scale_CVPR_2018_paper.html">DOTA: A Large-Scale Dataset for Object Detection in Aerial Images</a>[√]<br /><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://arxiv.org/pdf/2007.09584.pdf">PIoU Loss: Towards Accurate Oriented Object Detection in Complex Environments</a>[x]<br /><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://arxiv.org/ftp/arxiv/papers/1706/1706.09579.pdf">R<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>CNN: Rotational Region CNN for Orientation Robust Scene Text Detection</a>[x]<br /><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://arxiv.org/pdf/1703.01086.pdf">Arbitrary-Oriented Scene Text Detection via Rotation Proposals</a>[√]<br /><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="(https://www.mdpi.com/2072-4292/12/6/908)">Axis Learning for Orientated Objects Detection in Aerial Images</a>[x]<br /><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><a href="https://link.springer.com/chapter/10.1007/978-3-030-20893-6_10">Towards Multi-class Object Detection in Unconstrained Remote Sensing Imagery</a>[x]<br /><a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span><a href="http://openaccess.thecvf.com/content_CVPR_2019/papers/Ding_Learning_RoI_Transformer_for_Oriented_Object_Detection_in_Aerial_Images_CVPR_2019_paper.pdf">Learning RoI Transformer for Oriented Object Detection in Aerial Images</a>[√]<br /><a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:8" class="footnote-text"><span><a href="https://arxiv.org/pdf/2106.06072.pdf">Gaussian Bounding Boxes and Probabilistic Intersection-over-Union for Object Detection</a>[x]<br /><a href="#fnref:8" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:9" class="footnote-text"><span><a href="https://ieeexplore.ieee.org/document/9761381">ACE: Anchor-Free Corner Evolution for Real-Time Arbitrarily-Oriented Object Detection</a>[x]<br /><a href="#fnref:9" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:10" class="footnote-text"><span><a href="https://ieeexplore.ieee.org/abstract/document/9272784/">Arbitrary-Oriented Object Detection in Remote Sensing Images Based on Polar Coordinates</a>[x]<br /><a href="#fnref:10" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:11" class="footnote-text"><span><a href="http://openaccess.thecvf.com/content_ICCV_2019/papers/Yang_SCRDet_Towards_More_Robust_Detection_for_Small_Cluttered_and_Rotated_ICCV_2019_paper.pdf">SCRDet: Towards More Robust Detection for Small, Cluttered and Rotated Objects</a>[√]<br /><a href="#fnref:11" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:12" class="footnote-text"><span><a href="https://arxiv.org/abs/1912.10694.pdf">Oriented Objects as pairs of Middle Lines</a>[x]<br /><a href="#fnref:12" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:13" class="footnote-text"><span><a href="https://arxiv.org/abs/2005.09973.pdf">Dynamic Refinement Network for Oriented and Densely Packed Object Detection</a>[√]<br /><a href="#fnref:13" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:14" class="footnote-text"><span><a href="https://ieeexplore.ieee.org/document/9488629">CFC-Net: A Critical Feature Capturing Network for Arbitrary-Oriented Object Detection in Remote Sensing Images</a>[√]<br /><a href="#fnref:14" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:15" class="footnote-text"><span><a href="https://arxiv.org/abs/1908.05612">R3Det: Refined Single-Stage Detector with Feature Refinement for Rotating Object</a>[√]<br /><a href="#fnref:15" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:16" class="footnote-text"><span><a href="https://ieeexplore.ieee.org/document/9001201">Gliding vertex on the horizontal bounding box for multi-oriented object detection</a>[√]<br /><a href="#fnref:16" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:17" class="footnote-text"><span><a href="https://ieeexplore.ieee.org/document/9390310">LO-Det: Lightweight Oriented Object Detection in Remote Sensing Images</a>[√]<br /><a href="#fnref:17" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:18" class="footnote-text"><span><a href="https://search.proquest.com/docview/2442440949?pq-origsite=gscholar&amp;fromopenview=true">EFN: Field-Based Object Detection for Aerial Images</a>[√]<br /><a href="#fnref:18" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:19" class="footnote-text"><span><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9256343">SAR: Single-Stage Anchor-Free Rotating Object Detection</a>[√]<br /><a href="#fnref:19" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:20" class="footnote-text"><span><a href="https://arxiv.org/abs/2104.11435">TricubeNet: 2D Kernel-Based Object Representation for Weakly-Occluded</a>[×]<br /><a href="#fnref:20" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:21" class="footnote-text"><span><a href="https://www.mdpi.com/2072-4292/11/24/2930/htm">Mask OBB: A Semantic Attention-Based Mask Oriented Bounding Box Representation for Multi-Category Object Detection in Aerial Images</a>[√]<br /><a href="#fnref:21" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:22" class="footnote-text"><span><a href="https://arxiv.org/abs/2008.07043">Oriented Object Detection in Aerial Images with Box Boundary-Aware Vectors</a>[√]<br /><a href="#fnref:22" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:23" class="footnote-text"><span><a href="https://ieeexplore.ieee.org/abstract/document/9057525">Adaptive Period Embedding for Representing Oriented Objects in Aerial Images</a>[√]<br /><a href="#fnref:23" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:24" class="footnote-text"><span><a href="http://arxiv.org/abs/2003.05597">On the Arbitrary-Oriented Object Detection: Classification based Approaches Revisited</a>[√]<br /><a href="#fnref:24" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:25" class="footnote-text"><span><a href="https://ojs.aaai.org/index.php/AAAI/article/view/16347">Learning Modulated Loss for Rotated Object Detection</a>[√]<br /><a href="#fnref:25" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:26" class="footnote-text"><span><a href="https://www.mdpi.com/2072-4292/13/14/2664/htm">Sparse Label Assignment for Oriented Object Detection in Aerial Images</a>[×]<br /><a href="#fnref:26" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:27" class="footnote-text"><span><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9252176">Learning Point-Guided Localization for Detection in Remote Sensing Images</a>[√]<br /><a href="#fnref:27" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:28" class="footnote-text"><span><a href="https://dl.acm.org/doi/10.1145/3474085.3475457">Polar Ray: A Single-stage Angle-free Detector for Oriented Object Detection in Aerial Images</a>[√]<br /><a href="#fnref:28" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:29" class="footnote-text"><span><a href="https://ieeexplore.ieee.org/document/9661350">Constrained-SIoU: A Metric for Horizontal Candidates in Multi-Oriented Object Detection</a>[√]]<br /><a href="#fnref:29" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:30" class="footnote-text"><span><a href="https://arxiv.org/abs/2010.08720">PolarDet: a fast, more precise detector for rotated target in aerial images</a>[×]<br /><a href="#fnref:30" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:31" class="footnote-text"><span><a href="https://openaccess.thecvf.com/content/CVPR2021/papers/Guo_Beyond_Bounding-Box_Convex-Hull_Feature_Adaptation_for_Oriented_and_Densely_Packed_CVPR_2021_paper.pdf">Beyond Bounding-Box: Convex-hull Feature Adaptation for Oriented and Densely Packed Object Detection</a>[√]<br /><a href="#fnref:31" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:32" class="footnote-text"><span><a href="https://arxiv.org/abs/2012.04150">Dynamic Anchor Learning for Arbitrary-Oriented Object Detection</a>[√]<br /><a href="#fnref:32" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:33" class="footnote-text"><span><a href="https://ieeexplore.ieee.org/abstract/document/9709203">A General Gaussian Heatmap Label Assignment for Arbitrary-Oriented Object Detection</a>[√]<br /><a href="#fnref:33" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:34" class="footnote-text"><span><a href="https://arxiv.org/abs/2203.10747">EAutoDet: Efficient Architecture Search for Object Detection</a>[√]<br /><a href="#fnref:34" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:35" class="footnote-text"><span><a href="https://arxiv.org/abs/2011.09670">Dense Label Encoding for Boundary Discontinuity Free Rotation Detection</a>[√]<br /><a href="#fnref:35" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:36" class="footnote-text"><span><a href="https://arxiv.org/abs/2011.09670">CLT-Det: Correlation Learning Based on Transformer for Detecting Dense Objects in Remote Sensing Images</a>[√]<br /><a href="#fnref:36" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:37" class="footnote-text"><span><a href="https://arxiv.org/abs/2103.11636">Optimization for Arbitrary-Oriented Object Detection via Representation Invariance Loss</a>[√]<br /><a href="#fnref:37" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:38" class="footnote-text"><span><a href="https://arxiv.org/abs/2105.11111">Oriented RepPoints for Aerial Object Detection</a>[√]<br /><a href="#fnref:38" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:39" class="footnote-text"><span><a href="https://arxiv.org/abs/2204.02825">An Empirical Study of Remote Sensing Pretraining</a>[×]<br /><a href="#fnref:39" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:40" class="footnote-text"><span><a href="https://arxiv.org/abs/2204.02825">Arbitrarily Oriented Dense Object Detection Based on Center Point Network in Remote Sensing Images</a>[√]<br /><a href="#fnref:40" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:41" class="footnote-text"><span><a href="https://ieeexplore.ieee.org/document/9780146">Object Detection for Aerial Images With Feature Enhancement and Soft Label Assignment</a>[√]<br /><a href="#fnref:41" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:42" class="footnote-text"><span><a href="https://ieeexplore.ieee.org/document/9780146">Multi-Grained Angle Representation for Remote Sensing Object Detection</a>[√]<br /><a href="#fnref:42" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:43" class="footnote-text"><span><a href="https://ieeexplore.ieee.org/abstract/document/9194345">Point-Based Estimator for Arbitrary-Oriented Object Detection in Aerial Images</a>[×]<br /><a href="#fnref:43" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:44" class="footnote-text"><span><a href="https://arxiv.org/abs/2209.02200">Task-wise Sampling Convolutions for Arbitrary-Oriented Object Detection in Aerial Images</a>[√]<br /><a href="#fnref:44" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:45" class="footnote-text"><span><a href="https://www.aaai.org/AAAI22Papers/AAAI-8470.YangY.pdf">Polygon-to-Polygon Distance Loss for Rotated Object Detection</a>[√]<br /><a href="#fnref:45" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:46" class="footnote-text"><span><a href="https://www.aaai.org/AAAI22Papers/AAAI-2171.HouL.pdf">Shape-Adaptive Selection and Measurement for Oriented Object Detection</a>[√]<br /><a href="#fnref:46" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:47" class="footnote-text"><span><a href="https://arxiv.org/abs/2205.12785">AO2-DETR: Arbitrary-Oriented Object Detection Transformer</a>[√]<br /><a href="#fnref:47" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:48" class="footnote-text"><span><a href="https://ieeexplore.ieee.org/document/9377550">Align Deep Features for Oriented Object Detection</a>[√]<br /><a href="#fnref:48" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:49" class="footnote-text"><span><a href="https://arxiv.org/abs/2203.15221">Few Could Be Better Than All: Feature Sampling and Grouping for Scene Text Detection</a>[√]<br /><a href="#fnref:49" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:50" class="footnote-text"><span><a href="https://arxiv.org/abs/2106.03146">Oriented Object Detection with Transformer</a>[√]<br /><a href="#fnref:50" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
      <tag>旋转目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Localization Distillation</title>
    <link href="/2022/10/10/AI-Learning/20221011-Localization%20Distillation/"/>
    <url>/2022/10/10/AI-Learning/20221011-Localization%20Distillation/</url>
    
    <content type="html"><![CDATA[<h1 id="localization-distillation-for-dense-object-detection"><a class="markdownIt-Anchor" href="#localization-distillation-for-dense-object-detection"></a> Localization Distillation for Dense Object Detection</h1><h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2><p><strong>论文题目</strong> ：Localization Distillation for Dense Object Detection</p><p><strong>论文地址</strong> ：<a href="https://arxiv.org/pdf/2102.12252.pdf">https://arxiv.org/pdf/2102.12252.pdf</a></p><p><strong>论文出处</strong> ：2022’CVPR</p><p><strong>代码实现</strong> ：<a href="https://github.com/HikariTJU/LD">https://github.com/HikariTJU/LD</a></p><h2 id="idea"><a class="markdownIt-Anchor" href="#idea"></a> Idea</h2><p>把用于分类的KD（Knowledge Distillation），用于回归BBox中，形成了LD（Localization Distillation）。</p><p>做法：先把bbox的4个logits输出值，离散化成4n个logits输出值，之后与分类KD几乎一致。</p><h2 id="detail"><a class="markdownIt-Anchor" href="#detail"></a> Detail</h2><h3 id="logits-distillation"><a class="markdownIt-Anchor" href="#logits-distillation"></a> Logits Distillation</h3><p><strong>参考文献</strong>⏬</p><p>现在的深度学习模型越来越大，尤其是近年Transformer比较火，而各种基于的Transformer的模型参数普遍较多，在这种情况下就需要找到有效的模型压缩的方法。知识蒸馏就又回归到了研究者的视野之中。</p><p>KD最早就是专门为图像分类而设计的：</p><p><strong>核心思想</strong>：就是用一个已训练的复杂模型（Teacher，黑盒）输出的知识，去指导一个小模型（Student）训练学习。</p><p><img src="/img/article/2022/10/10/2.png" alt="" /></p><h4 id="知识soft-targets和hard-targets"><a class="markdownIt-Anchor" href="#知识soft-targets和hard-targets"></a> 知识：soft targets和hard targets</h4><p>分类采用的是one-hot编码：</p><p><strong>hard targets</strong>:  Ground truth   &lt;=&gt;    <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 0, 1, 0, 0, 0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">]</span></span></span></span>                      极大似然</p><p><strong>soft targets</strong>： Softmax层输出 &lt;=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0.01</mn><mo separator="true">,</mo><mn>0.03</mn><mo separator="true">,</mo><mn>0.91</mn><mo separator="true">,</mo><mn>0.01</mn><mo separator="true">,</mo><mn>0.02</mn><mo separator="true">,</mo><mn>0.01</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0.01,0.03,0.91,0.01,0.02,0.01]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">9</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">1</span><span class="mclose">]</span></span></span></span>  概论分布</p><blockquote><p>softmax层的输出，除了正例之外，<strong>负标签也带有大量的信息</strong>，比如某些负标签对应的概率远远大于其他负标签。而在传统的训练过程(hard target)中，所有负标签都被统一对待。</p><p><img src="/img/article/2022/10/10/3.png" alt="" /></p></blockquote><h4 id="蒸馏温度t"><a class="markdownIt-Anchor" href="#蒸馏温度t"></a> 蒸馏：温度T</h4><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>q</mi><mi>i</mi><mn>1</mn></msubsup><mo>=</mo><mfrac><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><msub><mi>z</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><mrow><msubsup><mo>∑</mo><mi>k</mi><mi>N</mi></msubsup><mo stretchy="false">(</mo><msub><mi>z</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">q_{i}^{1} = \frac{exp(z_i)}{\sum_{k}^{N}(z_k)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.072772em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.441336em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.664672em;vertical-align:-0.654672em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.570335em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop op-symbol small-op mtight" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8852357142857143em;"><span style="top:-2.1785614285714283em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-2.8971428571428572em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32143857142857146em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">p</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.654672em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>但是原始softmax函数的负标签概率都接近0，对损失函数的贡献非常小。</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>q</mi><mi>i</mi><mi>T</mi></msubsup><mo>=</mo><mfrac><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><msub><mi>z</mi><mi>i</mi></msub><mi mathvariant="normal">/</mi><mi>T</mi><mo stretchy="false">)</mo></mrow><mrow><msubsup><mo>∑</mo><mi>k</mi><mi>N</mi></msubsup><mo stretchy="false">(</mo><msub><mi>z</mi><mi>k</mi></msub><mi mathvariant="normal">/</mi><mi>T</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">q_{i}^{T} = \frac{exp(z_i/T)}{\sum_{k}^{N}(z_k/T)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0999949999999998em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.441336em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.664672em;vertical-align:-0.654672em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.570335em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop op-symbol small-op mtight" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8852357142857143em;"><span style="top:-2.1785614285714283em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-2.8971428571428572em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32143857142857146em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mord mtight">/</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">p</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight">/</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.654672em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>当T=1时，就是原始softmax函数，T越高，标签越平滑，负标签携带的信息会被相对地放大</p><blockquote><p>T = 100，标签更平滑</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0.01</mn><mo separator="true">,</mo><mn>0.03</mn><mo separator="true">,</mo><mn>0.91</mn><mo separator="true">,</mo><mn>0.01</mn><mo separator="true">,</mo><mn>0.02</mn><mo separator="true">,</mo><mn>0.01</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0.01,0.03,0.91,0.01,0.02,0.01]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">9</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0.0001</mn><mo separator="true">,</mo><mn>0.0003</mn><mo separator="true">,</mo><mn>0.0091</mn><mo separator="true">,</mo><mn>0.0001</mn><mo separator="true">,</mo><mn>0.0001</mn><mo separator="true">,</mo><mn>0.0001</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0.0001,0.0003,0.0091,0.0001,0.0001,0.0001]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">0</span><span class="mord">9</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p></blockquote><h4 id="distill-loss"><a class="markdownIt-Anchor" href="#distill-loss"></a> distill loss</h4><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mrow><mi>K</mi><mi>D</mi></mrow></msub><mo>=</mo><mi>α</mi><msub><mi>L</mi><mrow><mi>s</mi><mi>o</mi><mi>f</mi><mi>t</mi></mrow></msub><mo>+</mo><mi>β</mi><msub><mi>L</mi><mrow><mi>h</mi><mi>a</mi><mi>r</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">L_{KD} = \alpha L_{soft} + \beta L_{hard}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>在温度T的条件下，student的softmax输出和teacher输出的soft target的cross entropy就是<strong>Loss函数的第一部分</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mrow><mi>s</mi><mi>o</mi><mi>f</mi><mi>t</mi></mrow></msub><mo>=</mo><mo>−</mo><munderover><mo>∑</mo><mi>j</mi><mi>N</mi></munderover><msubsup><mi>p</mi><mi>j</mi><mi>T</mi></msubsup><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><msubsup><mi>q</mi><mi>j</mi><mi>T</mi></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L_{soft} = -\sum_{j}^{N}p_{j}^{T}log(q_{j}^{T})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.2421130000000007em;vertical-align:-1.4137769999999998em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000006em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4137769999999998em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.891331em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.891331em;"><span style="top:-2.4530000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>p</mi><mi>i</mi><mi>T</mi></msubsup><mo>=</mo><mfrac><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><msub><mi>v</mi><mi>i</mi></msub><mi mathvariant="normal">/</mi><mi>T</mi><mo stretchy="false">)</mo></mrow><mrow><msubsup><mo>∑</mo><mi>k</mi><mi>N</mi></msubsup><mo stretchy="false">(</mo><msub><mi>v</mi><mi>k</mi></msub><mi mathvariant="normal">/</mi><mi>T</mi><mo stretchy="false">)</mo></mrow></mfrac><mo separator="true">,</mo><msubsup><mi>q</mi><mi>i</mi><mi>T</mi></msubsup><mo>=</mo><mfrac><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><msub><mi>z</mi><mi>i</mi></msub><mi mathvariant="normal">/</mi><mi>T</mi><mo stretchy="false">)</mo></mrow><mrow><msubsup><mo>∑</mo><mi>k</mi><mi>N</mi></msubsup><mo stretchy="false">(</mo><msub><mi>z</mi><mi>k</mi></msub><mi mathvariant="normal">/</mi><mi>T</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">p_{i}^{T} = \frac{exp(v_i/T)}{\sum_{k}^{N}(v_k/T)},q_{i}^{T} = \frac{exp(z_i/T)}{\sum_{k}^{N}(z_k/T)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0999949999999998em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.664672em;vertical-align:-0.654672em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.570335em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop op-symbol small-op mtight" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8852357142857143em;"><span style="top:-2.1785614285714283em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-2.8971428571428572em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32143857142857146em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mord mtight">/</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">p</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight">/</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.654672em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.441336em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.664672em;vertical-align:-0.654672em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.570335em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop op-symbol small-op mtight" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8852357142857143em;"><span style="top:-2.1785614285714283em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-2.8971428571428572em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32143857142857146em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mord mtight">/</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">p</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight">/</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.654672em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>在温度T=1的条件下，student的softmax输出和ground truth的cross entropy就是<strong>Loss函数的第二部分</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mrow><mi>h</mi><mi>a</mi><mi>r</mi><mi>d</mi></mrow></msub><mo>=</mo><mo>−</mo><munderover><mo>∑</mo><mi>j</mi><mi>N</mi></munderover><msub><mi>c</mi><mi>j</mi></msub><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><msubsup><mi>q</mi><mi>j</mi><mn>1</mn></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L_{hard} = -\sum_{j}^{N}c_{j}log(q_{j}^{1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.2421130000000007em;vertical-align:-1.4137769999999998em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000006em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4137769999999998em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-2.4530000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>q</mi><mi>i</mi><mn>1</mn></msubsup><mo>=</mo><mfrac><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><msub><mi>z</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><mrow><msubsup><mo>∑</mo><mi>k</mi><mi>N</mi></msubsup><mo stretchy="false">(</mo><msub><mi>z</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">q_{i}^{1} = \frac{exp(z_i)}{\sum_{k}^{N}(z_k)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.072772em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.441336em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.664672em;vertical-align:-0.654672em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.570335em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop op-symbol small-op mtight" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8852357142857143em;"><span style="top:-2.1785614285714283em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-2.8971428571428572em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32143857142857146em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">p</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.654672em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><blockquote><p>上述公式中：</p><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ：Teacher模型中的logits(logits是softmax之前，网络中最后一个全连接层的输出)</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">z_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>： student模型中的logits</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>p</mi><mi>i</mi><mi>T</mi></msubsup></mrow><annotation encoding="application/x-tex">p_{i}^{T}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0999949999999998em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span>：Teacher模型在温度T下的softmax输出在第i类上的值</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>q</mi><mi>i</mi><mi>T</mi></msubsup></mrow><annotation encoding="application/x-tex">q_{i}^{T}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0999949999999998em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.441336em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span>：student模型在温度T下的softmax输出在第i类上的值</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>： ground truth在第i类上的值，正标签取1，负标签取0</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>： 总标签的数量</li></ul></blockquote><p>目前知识蒸馏主要分为了两个派系：logit蒸馏和feature蒸馏，上述是logit蒸馏</p><h3 id="localization-distillation"><a class="markdownIt-Anchor" href="#localization-distillation"></a> Localization Distillation</h3><p>基于此背景，再说说本文的LD，LD想解决的问题与GFL一样–由遮挡等因素带来的定位不确定性</p><p><img src="/img/article/2022/10/10/4.png" alt="" /></p><p>参考GFL，假设bbox的边e</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mo>=</mo><msubsup><mo>∫</mo><msub><mi>e</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><msub><mi>e</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></msubsup><mi>x</mi><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>d</mi><mi>x</mi><mo separator="true">,</mo><mi>e</mi><mo>∈</mo><mi>e</mi><mi>d</mi><mi>g</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">e = \int_{e_{min}}^{e_{max}} xP(x)dx, e\in edge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.426342em;vertical-align:-1.01205em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4142920000000003em;"><span style="top:-1.7880500000000004em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.01205em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span></span></span></span></span></p><p>然后把range<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mo>∈</mo><mo stretchy="false">[</mo><msub><mi>e</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo separator="true">,</mo><msub><mi>e</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">e\in[e_{min}, e_{max}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>离散化为集合<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><msub><mi>e</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo separator="true">,</mo><msub><mi>e</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>e</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>e</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo fence="true">}</mo></mrow><annotation encoding="application/x-tex">\left \{e_{min},e_{min+1},..e_{max-1},e_{max}  \right \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">}</span></span></span></span></span>。</p><blockquote><p><strong>集合中的每个值可以看作一个类</strong>，一般取间隔为1。</p></blockquote><p>这样bbox的每条边都可以通过Softmax函数转为一个概率分布。</p><p>作者使用的是相对熵（KL-divergence）作为LD的概率：</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mrow><mi>L</mi><mi>D</mi></mrow></msub><mo>=</mo><msubsup><mo>∑</mo><mi>e</mi><mrow><mi>e</mi><mi>d</mi><mi>g</mi><mi>e</mi></mrow></msubsup><mi>l</mi><mi>o</mi><mi>g</mi><mfrac><msubsup><mi>q</mi><mi>j</mi><mi>T</mi></msubsup><msubsup><mi>p</mi><mi>j</mi><mi>T</mi></msubsup></mfrac></mrow><annotation encoding="application/x-tex">L_{LD} = \sum_{e}^{edge} log\frac{q_{j}^{T}}{p_{j}^{T}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.9666299999999999em;vertical-align:-0.7158449999999998em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9890079999999999em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span></span></span></span><span style="top:-3.2029000000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.250785em;"><span style="top:-2.6069750000000003em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8328928571428571em;"><span style="top:-2.177714285714286em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-2.8448em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.46117142857142857em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.60742em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9190928571428572em;"><span style="top:-2.214em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.42488571428571426em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7158449999999998em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>p</mi><mi>i</mi><mi>T</mi></msubsup><mo>=</mo><mfrac><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><msub><mi>v</mi><mi>i</mi></msub><mi mathvariant="normal">/</mi><mi>T</mi><mo stretchy="false">)</mo></mrow><mrow><msubsup><mo>∑</mo><mi>e</mi><mrow><mi>e</mi><mi>d</mi><mi>g</mi><mi>e</mi></mrow></msubsup><mo stretchy="false">(</mo><msub><mi>v</mi><mi>e</mi></msub><mi mathvariant="normal">/</mi><mi>T</mi><mo stretchy="false">)</mo></mrow></mfrac><mo separator="true">,</mo><msubsup><mi>q</mi><mi>i</mi><mi>T</mi></msubsup><mo>=</mo><mfrac><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><msub><mi>z</mi><mi>i</mi></msub><mi mathvariant="normal">/</mi><mi>T</mi><mo stretchy="false">)</mo></mrow><mrow><msubsup><mo>∑</mo><mi>e</mi><mrow><mi>e</mi><mi>d</mi><mi>g</mi><mi>e</mi></mrow></msubsup><mo stretchy="false">(</mo><msub><mi>z</mi><mi>e</mi></msub><mi mathvariant="normal">/</mi><mi>T</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">p_{i}^{T} = \frac{exp(v_i/T)}{\sum_{e}^{edge}(v_e/T)},q_{i}^{T} = \frac{exp(z_i/T)}{\sum_{e}^{edge}(z_e/T)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0999949999999998em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.670227em;vertical-align:-0.6602269999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.5647800000000003em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop op-symbol small-op mtight" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8931714285714285em;"><span style="top:-2.1785614285714283em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span></span></span></span><span style="top:-2.8971428571428572em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32143857142857146em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight">/</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">p</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight">/</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.6602269999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.441336em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.670227em;vertical-align:-0.6602269999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.5647800000000003em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop op-symbol small-op mtight" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8931714285714285em;"><span style="top:-2.1785614285714283em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span></span></span></span><span style="top:-2.8971428571428572em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32143857142857146em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight">/</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">p</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight">/</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.6602269999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，符号基本与上文对应。</p><p>也算是把KD和LD的任务统一了，统称为Logit Mimicking。</p><h3 id="others"><a class="markdownIt-Anchor" href="#others"></a> others</h3><p>后续作者结合了feature蒸馏只会传递混合知识的，划分了两个区域：</p><p><img src="/img/article/2022/10/10/5.png" alt="" /></p><ul><li>Main distillation Region（主蒸馏区域、红色）&lt;=&gt; 直接通过正标签的所在区域确定</li><li>Valuable Localization Region（有价值区域，蓝色） &lt;=&gt; 通过设置DIOU阈值，计算DIOU确定</li></ul><p>讨论了分别在Main,VLR区域中使用KD、LD的效果消融实验:</p><p><img src="/img/article/2022/10/10/6.png" alt="" /></p><p>由于不太了解feature蒸馏，所以这一部分没细看。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>我认为蒸馏不是本文的重点，</p><p>倒是最近这种通过离散化，然后加权(概率)，把bbox的回归任务看成分类任务的思想比较常见。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
      <tag>目标检测</tag>
      
      <tag>知识蒸馏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Generalized Focal Loss</title>
    <link href="/2022/10/03/AI-Learning/20221003-GFL/"/>
    <url>/2022/10/03/AI-Learning/20221003-GFL/</url>
    
    <content type="html"><![CDATA[<h1 id="generalized-focal-loss"><a class="markdownIt-Anchor" href="#generalized-focal-loss"></a> Generalized Focal Loss</h1><h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2><p><strong>论文题目</strong> ：Generalized Focal Loss: Learning Qualified and Distributed Bounding Boxes for Dense Object Detection</p><p><strong>论文地址</strong> ：<a href="https://arxiv.org/pdf/2006.04388.pdf">https://arxiv.org/pdf/2006.04388.pdf</a></p><p><strong>论文出处</strong> ：2020’NeurIPS</p><p><strong>代码实现</strong> ：<a href="https://github.com/ViTAE-Transformer/Remote-Sensing-RVSA">https://github.com/ViTAE-Transformer/Remote-Sensing-RVSA</a></p><h2 id="idea"><a class="markdownIt-Anchor" href="#idea"></a> Idea</h2><p>one-stage的检测器最后都会归于两个子任务，即分类和定位。分类通常用Focal Loss，而定位通常用IOU Loss。而在近年的one-stage论文中（FCOS）,趋势是引入额外的分支centerness来评估检测框的定位质量。但是这样会带来两个问题(classification score 和 IoU/centerness score 训练测试不一致和bbox regression 采用的表示不够灵活，在建模复杂场景下的具有不确定性)，作者尝试解决这两个问题，提出了GFL。</p><p>基于任意one-stage 检测器上，调整框本身与框质量估计的表示，同时用泛化版本的GFocal Loss训练该改进的表示，可以实现无cost涨点（一般1个点出头）AP。</p><h2 id="detail"><a class="markdownIt-Anchor" href="#detail"></a> Detail</h2><h3 id="question"><a class="markdownIt-Anchor" href="#question"></a> Question</h3><h4 id="1classification-score-和-ioucenterness-score-训练测试不一致"><a class="markdownIt-Anchor" href="#1classification-score-和-ioucenterness-score-训练测试不一致"></a> 1.classification score 和 IoU/centerness score 训练测试不一致</h4><p><img src="/img/article/2022/10/03/2.png" alt="" /></p><ol><li><p>用法不一致。</p><p>训练的时候，分类和质量的评估是分离的，但测试的时候却又是乘在一起作为NMS score排序的依据，这个操作显然没有end-to-end，必然存在一定的gap</p></li><li><p>对象不一致。</p><p>Classification : 得益于Focal Loss ，可以计算少量正样本和大量负样本的classification score，并一起成功训练.</p><p>Localization: 在使用IoU/centerness score时，却是只针对正样本的score训练(正负样本的score都会计算)。</p><p>在做NMS score排序的时候，所有的样本都会将分类score和质量预测score相乘用于排序。</p></li></ol><blockquote><p>由于有大量的负样本，就很有可能出现以下情况：</p><p>NMS score: 负样本（分类score相对较低 * 高质量定位score）&gt; 正样本(分类score不够高 * 质量score较低)</p><p>出现NMS score排序后，负样本排在正样本前面的不合理现象，导致真实的正样本被NMS过滤。</p><p><img src="/img/article/2022/10/03/3.png" alt="" /></p><p>本文提出的联合分类和定位表示使得分类和定位得分保持一致(图b绿色的点)。</p></blockquote><p>可以看出来，作者在对监督训练和one-stage的端到端理念有很深的见解。</p><h4 id="2bbox-regression-采用的表示不够灵活在建模复杂场景下的具有不确定性"><a class="markdownIt-Anchor" href="#2bbox-regression-采用的表示不够灵活在建模复杂场景下的具有不确定性"></a> 2.bbox regression 采用的表示不够灵活，在建模复杂场景下的具有不确定性</h4><p><img src="/img/article/2022/10/03/4.png" alt="" /></p><p><img src="/img/article/2022/10/03/5.png" alt="" /></p><p>白色的是真实框，绿色的是预测框。可以看到图中的帆板边缘或被遮挡的大象边界，其实都很难去界定一个精确的位置。</p><p>在这时候，传统的单一Dirac delta分布建模并不符合实际的情况。</p><p>作者提出的一般分布，针对模糊和遮挡的物体采用扁平的分布来表示，清晰的物体采用尖锐的分布表示。</p><h3 id="method"><a class="markdownIt-Anchor" href="#method"></a> Method</h3><p><img src="/img/article/2022/10/03/6.png" alt="" /></p><p>针对离散的{0, 1}标签，本文classifcation 联合 IoU score变为了产生0~1的值作为相应类别的质量评估，将其扩展采用QFL来进行训练；</p><h4 id="qfl"><a class="markdownIt-Anchor" href="#qfl"></a> QFL</h4><p><img src="/img/article/2022/10/03/7.png" alt="" /></p><p><img src="/img/article/2022/10/03/8.png" alt="" /></p><p>对比可以发现，把离散的0，1分布改为了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>为0~1的质量标签，然后把调制因子<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msub><mi>p</mi><mi>t</mi></msub><msup><mo stretchy="false">)</mo><mi>γ</mi></msup></mrow><annotation encoding="application/x-tex">-(1-p_t)^\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05556em;">γ</span></span></span></span></span></span></span></span></span></span></span>外面括号换成了绝对值，形成了标准的交叉熵函数。</p><h4 id="dfl"><a class="markdownIt-Anchor" href="#dfl"></a> DFL</h4><p>之前的回归的标签<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>当作Dirac delta分布<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">−</mi><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">σ(x−y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>，只做单一概率分布，不够灵活。</p><p>假定我们回归的标签 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 存在最小值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">y_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和最大值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">y_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><p>通过均等划分<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><msub><mi>y</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[y_0,y_n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>(简单取:间隔为1)得到离散的集合<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><msub><mi>y</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>y</mi><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mn>2</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>y</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>i</mi></msub><mo>+</mo><mn>1.</mn><msub><mi>y</mi><mi>n</mi></msub><mo fence="true">}</mo></mrow><annotation encoding="application/x-tex">{\left \{y_0, y1, y2,..y_i, y_i+1. y_n\right \} }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">}</span></span></span></span></span></span>(这种离散化可以通过softmax实现)</p><p><img src="/img/article/2022/10/03/9.png" alt="" /></p><p>可以理解为DFL以类似交叉熵的形式去优化与标签<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>最接近的一左一右两个位置的概率<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub><mi mathvariant="normal">和</mi><msub><mi>y</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">y_i和y_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">和</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>，从而让网络快速地聚焦到目标位置的邻近区域的分布中去</p><h3 id="gfl"><a class="markdownIt-Anchor" href="#gfl"></a> GFL</h3><p>统合了QFL和DFL</p><p><img src="/img/article/2022/10/03/13.png" alt="" /></p><p><img src="/img/article/2022/10/03/10.png" alt="" /></p><h2 id="result"><a class="markdownIt-Anchor" href="#result"></a> Result</h2><p>在ATSS上做消融实验：</p><p><img src="/img/article/2022/10/03/11.png" alt="" /></p><p>总体网络对比：</p><p>仔细对比对应的网络结构，发现是有涨点的。</p><p><img src="/img/article/2022/10/03/12.png" alt="" /></p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
      <tag>旋转目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022-09-27-组会</title>
    <link href="/2022/09/26/Seminar/20220927-%E7%BB%84%E4%BC%9A/"/>
    <url>/2022/09/26/Seminar/20220927-%E7%BB%84%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="2022-09-12-组会"><a class="markdownIt-Anchor" href="#2022-09-12-组会"></a> 2022-09-12-组会</h1><h2 id="orthogonal-transformer"><a class="markdownIt-Anchor" href="#orthogonal-transformer"></a> Orthogonal Transformer</h2><p>NeurIPS’ 2022: <a href="https://nips.cc/Conferences/2022/Schedule?showEvent=55394">https://nips.cc/Conferences/2022/Schedule?showEvent=55394</a></p><p><img src="/img/article/2022/09/26/2.png" alt="" /></p><p><img src="/img/article/2022/09/26/3.png" alt="" /></p><p>如果后续这篇文章放到arxiv上了，我会再读一读。</p><h2 id="o-vitorthogonal-vision-transformer"><a class="markdownIt-Anchor" href="#o-vitorthogonal-vision-transformer"></a> O-ViT：Orthogonal Vision Transformer</h2><p>2022年2月16日： arXiv:2201.12133v2</p><p>这篇文章可以学习借鉴的地方不多：</p><p>=&gt;它是 <strong>纯数学理论上的优化</strong> ，通过正交流形在黎曼空间和欧几里得空间中的转换，保证特征图的失真度较小，进而保证计算过程的置信度</p><blockquote><p>文章中反复提到一些几何流形、正交群、李代数等概念，需要有相当好的矩阵论和抽象代数的基础才能理解，缺少一般Deep Learning的优化思想，我认为只适合套用。</p></blockquote><p>=&gt;该 <strong>文章代码未开源</strong> ，难以学习及复现（套用都套用不了）</p><h3 id="idea"><a class="markdownIt-Anchor" href="#idea"></a> Idea</h3><p><img src="/img/article/2022/09/26/4.png" alt="" /></p><ul><li>ViT中Self-Attention的线性变换会给特征空间带来尺度模糊性</li><li>Softmax函数存在梯度消失的风险</li></ul><p>前人有将流形优化用在R-NN和C-NN上，也有人利用正交矩阵的范式稳定性来缓解梯度爆炸和消失的问题，因此作者想试试将这个应用在ViT上。</p><h3 id="o-vit-architecture"><a class="markdownIt-Anchor" href="#o-vit-architecture"></a> O-ViT Architecture</h3><p>实际上，有用的就是两行伪代码：</p><p><img src="/img/article/2022/09/26/5.png" alt="" /></p><p><img src="/img/article/2022/09/26/6.png" alt="" /></p><p>通过构造斜对角矩阵<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>A</mi><mi>Q</mi></msup><mi mathvariant="normal">、</mi><msup><mi>A</mi><mi>k</mi></msup><mi mathvariant="normal">、</mi><msup><mi>A</mi><mi>v</mi></msup></mrow><annotation encoding="application/x-tex">A^Q、A^k、A^v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">Q</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span></span></span></span></span></span></span></span>过渡，来实现对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>W</mi><mi>Q</mi></msub><mo separator="true">,</mo><msub><mi>W</mi><mi>K</mi></msub><mo separator="true">,</mo><msub><mi>W</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">W_Q,W_K,W_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">Q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的正交约束。</p><blockquote><p>这就必须要求原<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>W</mi><mi>Q</mi></msub><mo separator="true">,</mo><msub><mi>W</mi><mi>K</mi></msub><mo separator="true">,</mo><msub><mi>W</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">W_Q,W_K,W_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">Q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>都是正交矩阵，这是怎么保证这三个权重矩阵初始化时就是正交矩阵的？</p></blockquote><p>附录中含有数学证明:</p><p><img src="/img/article/2022/09/26/7.png" alt="" /></p><h2 id="swin-transformer"><a class="markdownIt-Anchor" href="#swin-transformer"></a> Swin TransFormer</h2>]]></content>
    
    
    <categories>
      
      <category>组会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旋转目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Advancing ViT in Remote Sensing</title>
    <link href="/2022/09/19/AI-Learning/20220919-Advancing%20ViT%20in%20Remote%20Sensing/"/>
    <url>/2022/09/19/AI-Learning/20220919-Advancing%20ViT%20in%20Remote%20Sensing/</url>
    
    <content type="html"><![CDATA[<h1 id="advancing-vit-in-remote-sensing"><a class="markdownIt-Anchor" href="#advancing-vit-in-remote-sensing"></a> Advancing ViT in Remote Sensing</h1><h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2><p><strong>论文题目</strong> ：Advancing Plain Vision Transformer Towards Remote Sensing Foundation Model</p><p><strong>论文地址</strong> ：<a href="https://arxiv.org/pdf/2208.03987v2.pdf">https://arxiv.org/pdf/2208.03987v2.pdf</a></p><p><strong>论文出处</strong> ：arxiv</p><p><strong>代码实现</strong> ：<a href="https://github.com/ViTAE-Transformer/Remote-Sensing-RVSA">https://github.com/ViTAE-Transformer/Remote-Sensing-RVSA</a></p><h2 id="idea"><a class="markdownIt-Anchor" href="#idea"></a> Idea</h2><ul><li><p>提出了一个为Remote Sensing领域定制的大型ViT模型，有1亿个参数。</p></li><li><p>提出了一种新的旋转可变大小窗口注意力机制（RVSA）来替代Trasnsformer中的全注意力机制。</p></li></ul><p>检测任务的实验证明优于所有最先进的模型，在DOTA-V1.0上实现了81.16%的mAP。</p><h2 id="detail"><a class="markdownIt-Anchor" href="#detail"></a> Detail</h2><p><img src="/img/article/2022/09/19/2.png" alt="" /></p><p>本文与前面一些旋转目标检测文章的主要不同点就在pretrain和backbone上。</p><h3 id="pretrainmae"><a class="markdownIt-Anchor" href="#pretrainmae"></a> Pretrain–MAE</h3><p>本文当中的ViT和ViTAE都是基于一种自监督学习的方法MAE去进行预训练的，使用的数据集是MillionAID（无label）。</p><blockquote><p>MAE 2022 CVPR Kaiming He</p><p><img src="/img/article/2022/09/19/3.png" alt="" /></p><p>在预训练期间，对输入图像的patches按照预先指定的mask ratio进行随机掩码。</p><p>没有被掩盖的patch经过encoder生成visual token ; 被掩盖的patch不会经过encoder,而是按照原先patch的顺序填充mask token。</p><p>然后按顺序排列好的visual token和mask token经过decoder，decoder以像素为单位去生成原始图像。</p><p>预训练之后，decoder被丢弃，encoder被应用于未损坏的图像，为识别任务生成表示。</p></blockquote><p>在本文的介绍当中，是所有的patch都会经过encoder生成visual token，然后按照mask ratio的比率去随机丢弃token(token dropping)。</p><h3 id="backbonevit-和-vitae"><a class="markdownIt-Anchor" href="#backbonevit-和-vitae"></a> Backbone–ViT 和 ViTAE</h3><p>主要区别就在于堆叠的Vision Transformer Block结构上。</p><p><img src="/img/article/2022/09/19/4.png" alt="" /></p><p>ViT的Block就不过多介绍，很经典的Layer Normalization + Muti Head Sel Attention + Feed-Forwad Network(MLP) + Add</p><p>ViTAE，是作者之前的成果，论文中放的图片也是，</p><p>主要就是增加了一个并行卷积分支（Parallel convolution branches，PCM)</p><p>Group Conv + Batch Norm + SiLU + Group Conv</p><blockquote><p>本文的原话：MAE中关键的设计就是token dropping，但是这个操作会破坏token之间的空间关系，所以作者设计了ViTAE的Block。<br />原理是说结合了归纳偏置，具体是怎么回事可能还得看ViTAE的原文</p></blockquote><h3 id="attentionrvsa"><a class="markdownIt-Anchor" href="#attentionrvsa"></a> Attention–RVSA</h3><p>在本文中作者使用了旋转可变大小窗口注意力机制（(Rotated Varied-Size Attention,RVSA)替换了原先的多头注意力机制(MHSA)。</p><p>RVSA基于作者之前的成果(Varied-Size Window Attention,VSA)。</p><p><img src="/img/article/2022/09/19/5.png" alt="" /></p><p>Varied-Size Window Attention又是基于Window-base attention(思路源于Swin-T)，以固定大小的窗口作为初始化,并从这些窗口提取Qw，对于Kw和Vw，通过输入Xw去预测目标窗口的偏移量o和比例s去得到。</p><p>对着论文比较好讲，先讲Window-base attention的s，</p><p><img src="/img/article/2022/09/19/6.png" alt="" /></p><h4 id="coordinate-transformation"><a class="markdownIt-Anchor" href="#coordinate-transformation"></a> Coordinate Transformation</h4><p>该模块主要是就是坐标变换，</p><p>对于VSA:</p><p><img src="/img/article/2022/09/19/7.png" alt="" /></p><p>对于RVSA:</p><p><img src="/img/article/2022/09/19/8.png" alt="" /></p><h3 id="一些细节"><a class="markdownIt-Anchor" href="#一些细节"></a> 一些细节</h3><p>最佳Mask Ratio通过Linear probing setting和 Fine tune setting实验获得，为0.75时达到最佳性能。</p><p>Window-base attention的初始化分割， 通过实验，在DOTA和DIOR-R数据集上s均取7能达到最佳性能。</p><h2 id="result"><a class="markdownIt-Anchor" href="#result"></a> Result</h2><p>作者使用的大的网络框架是Oriented-RCNN，主要对比pretrain和backbone</p><p>黑、红、蓝色依次标注是该类别的acc1、2、 3名</p><p><img src="/img/article/2022/09/19/9.png" alt="" /></p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
      <tag>旋转目标检测</tag>
      
      <tag>Transformer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022-09-12-组会</title>
    <link href="/2022/09/11/Seminar/20220912-%E7%BB%84%E4%BC%9A/"/>
    <url>/2022/09/11/Seminar/20220912-%E7%BB%84%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="2022-09-12-组会"><a class="markdownIt-Anchor" href="#2022-09-12-组会"></a> 2022-09-12-组会</h1><h2 id="loss"><a class="markdownIt-Anchor" href="#loss"></a> loss</h2><h3 id="oriented-rcnn"><a class="markdownIt-Anchor" href="#oriented-rcnn"></a> Oriented-RCNN</h3><p><img src="/img/article/2022/09/12/2.png" alt="" /></p><p>分类分支: Cross Entropy Loss</p><p>回归分支: SmothL1Loss</p><p><img src="/img/article/2022/09/12/3.png" alt="" /></p><p><img src="/img/article/2022/09/12/4.png" alt="" /></p><h3 id="atss"><a class="markdownIt-Anchor" href="#atss"></a> ATSS</h3><h4 id="mmdet框架水平目标检测"><a class="markdownIt-Anchor" href="#mmdet框架水平目标检测"></a> mmdet框架(水平目标检测)</h4><p>分类分支: FocalLoss</p><p>回归分支: IOULoss</p><p>Centerness分支:</p><p><img src="/img/article/2022/09/12/5.png" alt="" /></p><p><img src="/img/article/2022/09/12/6.png" alt="" /></p><h4 id="mmrotate框架旋转目标检测"><a class="markdownIt-Anchor" href="#mmrotate框架旋转目标检测"></a> mmrotate框架(旋转目标检测)</h4><p>分类分支: FocalLoss</p><p>回归分支: L1Loss</p><p><img src="/img/article/2022/09/12/7.png" alt="" /></p>]]></content>
    
    
    <categories>
      
      <category>组会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旋转目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022-09-06-组会</title>
    <link href="/2022/09/06/Seminar/20220906-%E7%BB%84%E4%BC%9A/"/>
    <url>/2022/09/06/Seminar/20220906-%E7%BB%84%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="2022-09-06-组会"><a class="markdownIt-Anchor" href="#2022-09-06-组会"></a> 2022-09-06-组会</h1><h2 id="atss与oriented-r-cnn"><a class="markdownIt-Anchor" href="#atss与oriented-r-cnn"></a> ATSS与Oriented R-CNN</h2><h3 id="区别"><a class="markdownIt-Anchor" href="#区别"></a> 区别</h3><p>ATSS原论文是将ATSS这种动态划分正负样本策略应用在one-stage的RetinaNet(anchor-based)t和one-stage的FCOS(anchor-free)</p><blockquote><p>one-stage中能够匹配到目标的候选框（正样本）个数一般只用十几个或几十个，而没匹配到的候选框（负样本）大概有 10^4 - 10^5 个。</p><p>选出来的proposal直接就相当于正样本了</p><p>容易出现正负样本不均衡，所以要平衡正负样本</p></blockquote><p>anchor=&gt;proposal(positive sample)</p><hr /><p>Oriented R-CNN(anchor-based)是two-stage的检测器，它把正负样本的划分了2个步骤，每个stage各一个步骤。</p><blockquote><p>在第一阶段先选出一些候选框proposal（如Faster R-CNN 的rpn），大概2000个左右;</p><p>在第二阶段再从proposal中筛选出正负样本，虽然这时正负样本也是存在不均衡的，但是(10  ：2000) 相对（10  :   10^4 - 10^5 )好了很多。</p><p>这也是为什么普遍two-stage的检测器比one-stage的检测器的精度要高一些的原因之一。</p></blockquote><p>anchor=&gt;proposal=&gt;positive sample</p><h3 id="应用"><a class="markdownIt-Anchor" href="#应用"></a> 应用</h3><p>如果我要将ATSS应用在Oriented R-CNN中，我是应该要应用在第一阶段还是应用在第二阶段，还是都应用，这么做的提升效果？</p><p>如果我应用在第一阶段:  anchor=&gt;proposal， 相当于是提出了动态划分proposal策略（理论上来说可以应用）</p><p>而且Oriented R-CNN的在第一阶段的rpn-head中encoder-decoder就是采用的是6元组(midpointoffset)的表达形式。</p><blockquote><p>一些假想:</p><p>第一阶段，动态划分proposal，假设是Fast R-CNN中的数据规模，划分出1000-5000个;  数据规模相比与2000来说变化不大，会有提升效果么？<br />如果不改变第二阶段，当我筛出10:5000， 和原本的10:2000来说是不是负优化了？</p></blockquote><hr /><p>如果我应用在第二阶段:  proposal=&gt;positive sample</p><blockquote><p>感觉上不能直接用ATSS，因为ATSS是从所有anchor中选中心点与GT最近的topK个anchor，我不清楚从proposal开始，是否也有足够数量的proposal支持我这么做</p></blockquote><p>而且Oriented R-CNN的在第二阶段的rcnn-head中encoder-decoder已经回归到5元组(xywha)的表达形式了，也就不涉及表达转换。</p><p>所以将ATSS应用在two-stage检测器中真的有意义么，可能只有实验才能验证。</p><h3 id="表达转换"><a class="markdownIt-Anchor" href="#表达转换"></a> 表达转换</h3><p>我觉得直接使用Oriented R-CNN中的转换公式就行了</p><p>encoder:</p><p><img src="/img/article/2022/09/06/2.png" alt="" /></p><p>decoder:</p><p><img src="/img/article/2022/09/06/3.png" alt="" /></p><p>如果要设计公式，我觉得也是在loss部分</p><p>ATSS额外加入了 centerness 分支，这部分也要计算loss</p><hr />]]></content>
    
    
    <categories>
      
      <category>组会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旋转目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vision Transformer</title>
    <link href="/2022/08/29/AI-Learning/20220829-Vision%20Transformer/"/>
    <url>/2022/08/29/AI-Learning/20220829-Vision%20Transformer/</url>
    
    <content type="html"><![CDATA[<h1 id="vision-transformer"><a class="markdownIt-Anchor" href="#vision-transformer"></a> Vision Transformer</h1><h2 id="vision-transformer-2"><a class="markdownIt-Anchor" href="#vision-transformer-2"></a> Vision Transformer</h2><p><strong>论文题目</strong> ：AN IMAGE IS WORTH 16X16 WORDS: TRANSFORMERS FOR IMAGE RECOGNITION AT SCALE</p><p><strong>论文地址</strong> ：<a href="https://arxiv.org/pdf/2010.11929.pdf">https://arxiv.org/pdf/2010.11929.pdf</a></p><p><strong>论文出处</strong> ：ICLR’2021</p><p><strong>代码实现</strong> ：-</p><h3 id="idea"><a class="markdownIt-Anchor" href="#idea"></a> Idea</h3><p>通过将图像拆分为块 (patch)，并将这些图像块的线性嵌入序列作为 Transformer 的输入，作者将Transformer成功应用到CV领域。</p><blockquote><p>没有直接把像素点作为输入，可以减少参数量</p></blockquote><p>通过这篇文章的实验，说明Transformer在CV领域确实有效，并且效果惊人。</p><h3 id="detail"><a class="markdownIt-Anchor" href="#detail"></a> Detail</h3><h4 id="network"><a class="markdownIt-Anchor" href="#network"></a> Network</h4><p><img src="/img/article/2022/08/29/2.png" alt="" /></p><ul><li>Linear Projection of Flattened Patches(Patch Embedding层)</li><li>Transformer Encoder(图右侧有给出更加详细的结构)</li><li>MLP Head（最终用于分类的层结构）</li></ul><h4 id="patch-embedding"><a class="markdownIt-Anchor" href="#patch-embedding"></a> Patch Embedding</h4><p><img src="/img/article/2022/08/29/3.png" alt="" /></p><p>以ViT-Base/16为例:</p><p>首先将一张图片按给定大小分成一堆Patches。将输入图片(224x224)按照16x16大小的Patch进行划分，划分后会得到(224/16)^2 = 196 个patch。</p><p>每个Patche数据shape为<code>[16,16,3]</code>通过线性映射将每个Patch映射到一维向量中，映射得到一个长度为768的向量token<code>[196,768]</code>。</p><blockquote><p>具体使用一个卷积层（768个16x16的卷积核,stride为16）来实现Patch划分。</p></blockquote><p>拼接一个[class]token， Concat([1,768],[196,768] =&gt; <code>[197,768]</code>。</p><p>叠加位置编码Position Embedding, <code>[197,768]</code> =&gt; <code>[197,768]</code>。</p><blockquote><p>自注意力的<strong>扰动不变性</strong>(<strong>Permutation-invariant</strong>): <strong>打乱 Sequence 中 tokens 的顺序并不会改变结果</strong>。</p><p>这里的[class] token和位置编码都是可训练参数。</p></blockquote><p><img src="/img/article/2022/08/29/4.png" alt="" /></p><p>位置编码之间的余弦相似度可视化，表明任意两个patches之间在位置上的关联度。</p><p>可以发现相近的图像块的位置编码关联度较高，且同行或列的位置编码关联度也相近。</p><p>这里的图片按32x32的大小划分，所以是得到7x7个patch。</p><h4 id="transformer-encoder"><a class="markdownIt-Anchor" href="#transformer-encoder"></a> Transformer Encoder</h4><p><img src="/img/article/2022/08/29/5.png" alt="" /></p><p>Transformer Encoder其实就是重复堆叠Encoder Block L次:</p><p><img src="/img/article/2022/08/29/6.png" alt="" /></p><ul><li><p>Layer Norm，这种Normalization方法主要是针对NLP领域提出的，这里是对每个token进行Norm处理</p><blockquote><p>BN是取不同样本的同一个通道的特征做归一化；LN则是取同一个样本的不同通道做归一化。</p></blockquote></li><li><p>Multi-Head Attention，这个结构之前是在Attention Is All You Need这篇文章中提出</p><p><img src="/img/article/2022/08/29/7.png" alt="" /></p><p><img src="/img/article/2022/08/29/8.png" alt="" /></p><blockquote><p>我感觉这原文当中这两个图比较抽象，大概讲下我的理解:</p><p><strong>Self-Attention</strong> :</p><p><img src="/img/article/2022/08/29/9.png" alt="" /></p><p>首先把输入的token通过Input Embedding映射为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，然后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>通过3个可变换矩阵<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>W</mi><mi>q</mi></msub><mo separator="true">,</mo><msub><mi>W</mi><mi>k</mi></msub><mo separator="true">,</mo><msub><mi>W</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">W_q,W_k,W_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>(这三个参数是可训练的，并且是共享的)计算得到对应的Q,K,V。</p><ul><li>q代表query，后续会去和每一个k进行匹配</li><li>k代表key，后续会被每个q匹配</li><li>v代表value，从a中提取得到的信息，可以理解为相关性权值</li></ul><p>Q和K相乘，得到是查询向量和各个对应的键向量的相关性（匹配度），是 n×n 的矩阵。</p><p>除以根号dk，再通过SoftMax得到缩放后的attention score，再与V相乘，得到加权和作为最后的输出。</p><p>点乘操作可以写成矩阵乘法,实现计算并行化，因此计算速度会快很多。</p><p><strong>Multi-Head Attention</strong> :</p><p>Q，V，K分别通过n次线性变换得到n组Q，K，V，这里n对应着<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mi>e</mi><mi>a</mi><msub><mi>d</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">Head_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>对于每一组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>Q</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>K</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>V</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">Q_i,K_i,V_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>通过Self-Attention得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mi>e</mi><mi>a</mi><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">Head_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>拼接所有的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mi>e</mi><mi>a</mi><msub><mi>d</mi><mn>0</mn></msub><mo>−</mo><mi>H</mi><mi>e</mi><mi>a</mi><msub><mi>d</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">Head_0 - Head_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，然后将其线性映射得到最终输出。</p></blockquote></li><li><p>Dropout，减少过拟合，保证模型的稀疏性</p></li><li><p>MLP，如图所示，就是全连接+GELU激活函数+Dropout</p></li></ul><h4 id="mlp-head"><a class="markdownIt-Anchor" href="#mlp-head"></a> MLP Head</h4><p><img src="/img/article/2022/08/29/10.png" alt="" /></p><p>上面通过Transformer Encoder后输出的shape和输入的shape是保持不变的。</p><p>所以我们只需要提取出[class]token生成的对应结果就行，即<code>[197, 768]</code>中提取出[class]token对应的<code>[1, 768]</code>。</p><p>接着我们通过MLP Head得到我们最终的分类结果。</p><p>MLP Head 由 Linear+tanh激活函数+Linear组成。</p><p>整体网络的内部结构:</p><p><img src="/img/article/2022/08/29/11.png" alt="" /></p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
      <tag>旋转目标检测</tag>
      
      <tag>Transformer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022-08-22-组会</title>
    <link href="/2022/08/22/Seminar/20220822-%E7%BB%84%E4%BC%9A/"/>
    <url>/2022/08/22/Seminar/20220822-%E7%BB%84%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="2022-08-22-组会"><a class="markdownIt-Anchor" href="#2022-08-22-组会"></a> 2022-08-22-组会</h1><p><img src="/img/article/2022/08/22/2.png" alt="" /></p><p>上次组会开完后，目前比较主流的遥感旋转目标检测相关论文读得差不多了</p><h3 id="论文总结"><a class="markdownIt-Anchor" href="#论文总结"></a> 论文总结</h3><p>使用基于角度回归的检测方法=&gt;直接解决面对</p><p>角度参数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">{\theta}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span></span>的周期性带来的 <strong>损失的不连续性</strong> 和 <strong>回归的不一致性</strong></p><p>解决思路: 设计一些新型IOU或Loss函数去解决， 如GWD，KFIOU等</p><hr /><p>借鉴传统通用检测器的新型表示方法(如点集(reppoints)，平行四边形)，规避掉 <strong>损失的不连续性</strong> 和 <strong>回归的不一致性</strong></p><p>把这种检测框的表示，从水平垂直框迁移到旋转框的表示，需要设计一系列的转换函数。</p><blockquote><ul><li><p>有借鉴目标检测的新型表达方式的，如Oriented RepPoint(借鉴RepPoint)，效果很好</p></li><li><p>有自己设计的新型表达方式(如根据四边形偏移量)， 如Oriented R-CNN, RSDet, Gliding Vertex等，其中Oriented R-CNN效果很好，其它的效果一般</p></li></ul></blockquote><hr /><p>还有像ATSS(SASM)这样另辟蹊径，动态设置IOU阈值划分正负样本。设计一些算法，使用超参数调整动态值。</p><hr /><p>…</p><p>目前一个好的思路可以尝试： 能否将ATSS和Oriented R-CNN结合起来，达到一个更高的mAP?</p><p>实现思路：重新设计Head、BBox Assigner等模块去把原本固定的IOU阈值给覆盖掉</p><p><img src="/img/article/2022/08/22/3.png" alt="" /></p><p>目前的在做一些尝试性的实验，学习Pytorch。</p><h3 id="论文阅读"><a class="markdownIt-Anchor" href="#论文阅读"></a> 论文阅读</h3><h4 id="vit"><a class="markdownIt-Anchor" href="#vit"></a> ViT</h4><p>找到一篇论文Advancing Plain Vision Transformer Towards Remote Sensing Foundation Model 武汉大学 8月10号发布的</p><blockquote><p>有代码，是目前DOTA数据集上的SOTA</p></blockquote><p>这篇论文主要思想是把Vision Transformer应用在遥感图像，但ViT这一块我不太了解其具体实现，这篇论文可能自己也没有理解透彻(尤其是里面Mask Image Modeling部分)，所以我打算再找些相关的论文去读一读再讲。</p><p>它跟以往的基于rpn为backbone的网络模型结构完全不一样，可能能成为一个新的思路。</p><h4 id="文本检测方向"><a class="markdownIt-Anchor" href="#文本检测方向"></a> 文本检测方向</h4><p>水平文本检测、多向文本检测、弯曲文本检测，文本识别(OCR)</p><p>多向文本检测中的比较新的文章:</p><p>MOST[2021’CVPR] (A Multi-Oriented Scene Text Detector with Localization Refinement)</p><p><img src="/img/article/2022/08/22/4.png" alt="" /></p><p>使用的是DCN(可变形卷积)，这就回到了Oriented Reppoint中的新型表达方式了。</p><ul><li>后续是否应该继续读文章找新的思路？</li><li>遥感旋转目标检测方向上的文章读的差不多了，该如何找适合自己方向的新的文章?</li></ul>]]></content>
    
    
    <categories>
      
      <category>组会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旋转目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ATSS与SASM</title>
    <link href="/2022/08/01/AI-Learning/20220801-SASM/"/>
    <url>/2022/08/01/AI-Learning/20220801-SASM/</url>
    
    <content type="html"><![CDATA[<h1 id="atss与sasm"><a class="markdownIt-Anchor" href="#atss与sasm"></a> ATSS与SASM</h1><p>动态设置IOU阈值以划分正负样本。</p><h2 id="atss"><a class="markdownIt-Anchor" href="#atss"></a> ATSS</h2><p><strong>论文题目</strong> ：Bridging the Gap Between Anchor-based and Anchor-free Detection via Adaptive Training Sample Selection</p><p><strong>论文地址</strong> ：<a href="https://arxiv.org/pdf/1912.02424.pdf">https://arxiv.org/pdf/1912.02424.pdf</a></p><p><strong>论文出处</strong> ：2020’CVPR</p><p><strong>代码实现</strong> : <a href="https://github.com/sfzhang15/ATSS">https://github.com/sfzhang15/ATSS</a></p><h3 id="idea"><a class="markdownIt-Anchor" href="#idea"></a> Idea</h3><ul><li>指出anchor-free和一阶段anchor-based方法的根本差异主要来源于正负样本的选择</li><li>提出ATSS( Adaptive Training Sample Selection)方法来根据对象的统计特征自动选择正负样本</li></ul><h3 id="detail"><a class="markdownIt-Anchor" href="#detail"></a> Detail</h3><h3 id="retinanet与fcos"><a class="markdownIt-Anchor" href="#retinanet与fcos"></a> RetinaNet与FCOS</h3><p>RetinaNet 网络结构是目前主流的一阶段anchor-based目标检测网络结构，我在之前的组会中有介绍过。</p><p>FCOS沿用了主流网络结构 RetinaNet，使其具备公平对比的特性，在几乎没有修改情况下，性能可以超越 RetinaNet</p><p>区别:</p><blockquote><p>(1)<strong>每个位置平铺的anchor数目不同。</strong> RetinaNet每个位置会平铺几个anchor box而FCOS每个位置只会设定一个anchor point（anchor free 却 center-based）。</p><p>(2)<strong>正负样本的定义方式不同。</strong> RetinaNet根据IOU来选择正负样本，FCOS则利用空间和尺度约束来选择样本。</p><p>(3) <strong>回归的起始状态不同。</strong> RetinaNet从预定义的anchor处回归边界框，而FCOS则从预定义的point上定位目标。</p><p>(4) <strong>Trick</strong>。FCOS论文中提出了一些通用trick，可以有效提升性能。</p></blockquote><p>作者首先对两大主流算法进行深入公平对比分析，希望能找到性能差异的根本原因:</p><p><img src="/img/article/2022/08/01/2.png" alt="" /></p><p>因为 FCOS 算法性能优于 RetinaNet，并且其额外引入了许多 trick，为了公平对比，将 FCOS 所提 trick 也迁移到 RetinaNet 中，并且设置 RetinaNet 的 anchor 个数为 1，结果如上所示。可以看出即使所有 trick 都加上 RetinaNet 依然差了 0.8 mAP。</p><p>排除上述因素后，两个算法的区别是：</p><ul><li><p>分类分支上，正负样本的定义方式不同</p></li><li><p>回归分支上，回归的起始状态不同</p></li></ul><h4 id="essential-difference"><a class="markdownIt-Anchor" href="#essential-difference"></a> Essential Difference</h4><h5 id="classification"><a class="markdownIt-Anchor" href="#classification"></a> Classification</h5><p><img src="/img/article/2022/08/01/3.png" alt="" /></p><p>RetinaNet使用IoU阈值(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>θ</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">{\theta_p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>θ</mi><mi>g</mi></msub></mrow><annotation encoding="application/x-tex">{\theta_g}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span>)来区分正负anchor bbox，处于中间的全部忽略。</p><p>FCOS使用空间尺寸和尺寸限制来区分正负anchor point，正样本首先必须在GT box内，其次需要是GT尺寸对应的层，其余均为负样本。</p><h5 id="regression"><a class="markdownIt-Anchor" href="#regression"></a> Regression</h5><p><img src="/img/article/2022/08/01/4.png" alt="" /></p><p>RetinaNet预测4个偏移值对anchor box进行调整输出，而FCOS则预测4个相对于anchor point值对anchor box进行调整输出</p><p>对上述差异进行交叉实验做对比:</p><p><img src="/img/article/2022/08/01/5.png" alt="" /></p><p>发现相同的正负样本定义下的RetinaNet和FCOS性能几乎一样，不同的定义方法性能差异较大，而回归初始状态对性能影响不大。所以，基本可以确定正负样本的确定方法是影响性能的重要一环。</p><h3 id="atssadaptive-training-sample-selection"><a class="markdownIt-Anchor" href="#atssadaptive-training-sample-selection"></a> ATSS(Adaptive Training Sample Selection)</h3><p><img src="/img/article/2022/08/01/6.png" alt="" /></p><p>论文提出ATSS方法，该方法根据目标的相关统计特征，计算自适应阈值进行正负样本的选择。</p><p>论文提出ATSS方法，该方法根据目标的相关统计特征自动进行正负样本的选择，具体逻辑如算法1所示。对于每个GT box g，首先在每个特征层找到中心点最近的k个候选anchor boxes(非预测结果)，计算候选box与GT间的IoU Dg，计算IoU的均值mg和标准差vg，得到IoU阈值tg=mg+vg，最后选择阈值大于tg的box作为最后的输出。如果anchor box对应多个GT，则选择IoU最大的GT。</p><h3 id="result"><a class="markdownIt-Anchor" href="#result"></a> Result</h3><p>应用在RetinaNet与FCOS上的实验结果(COCO数据集):</p><p><img src="/img/article/2022/08/01/7.png" alt="" /></p><h2 id="sasm"><a class="markdownIt-Anchor" href="#sasm"></a> SASM</h2><p><strong>论文题目</strong> ：Shape-Adaptive Selection and Measurement for Oriented Object Detection</p><p><strong>论文地址</strong> ：<a href="https://www.aaai.org/AAAI22Papers/AAAI-2171.HouL.pdf?ref=https://githubhelp.com">https://www.aaai.org/AAAI22Papers/AAAI-2171.HouL.pdf?ref=https://githubhelp.com</a></p><p><strong>论文出处</strong> ：2022’AAAI</p><p><strong>代码实现</strong> : <a href="https://github.com/houliping/SASM">https://github.com/houliping/SASM</a></p><h3 id="idea-2"><a class="markdownIt-Anchor" href="#idea-2"></a> Idea</h3><p>提出了一种新的动态选择(SA-S)策略和动态评估(SA-M)策略，选择正负样本</p><h3 id="detail-2"><a class="markdownIt-Anchor" href="#detail-2"></a> Detail</h3><p><img src="/img/article/2022/08/01/8.png" alt="" /></p><h4 id="sa-s"><a class="markdownIt-Anchor" href="#sa-s"></a> SA-S</h4><p><img src="/img/article/2022/08/01/9.png" alt="" /></p><p>SA-S的做法很容易理解，效仿ATSS，根据物体的形状动态调整每个object的IoU阈值</p><p>根据物体长宽比设计了一个关于阈值的递减函数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>γ</mi><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{ f(γi) }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span></span>，长宽比越大，IoU越小。</p><p>论文中的公式 μ 就是计算出的均值， σ 就是计算出来的标准差。</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>γ</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">{γi}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="mord mathdefault">i</span></span></span></span></span>  是目标的纵横比，长边比短边。</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">{w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span></span>是一个超参数（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">{w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span></span> 越大，函数曲线越平滑，就更能表示纵横比更大的目标）</p><h4 id="sa-m"><a class="markdownIt-Anchor" href="#sa-m"></a> SA-M</h4><p>一般来说，做完动态选择（SA-M）策略之后，所有的正样本都会一视同仁。但作者认为，正样本之间也有质量上的区别的。以anchor-free的样本为例（即点），假如这5个点都被分配为了正样本点，但是位于位于物体中心的点比物体中心的点更能代表物体的特性。因此我们根据点相对于物体的距离对于选中的正样本点做了质量上的区分。对于anchor-based方法，点用anchor的中心点代表。</p><p><img src="/img/article/2022/08/01/10.png" alt="" /></p><p>第j个样本点与第i个目标中心点的距离计算:</p><p><img src="/img/article/2022/08/01/11.png" alt="" /></p><p>这样综合了点相对物体中心和边界的距离，离中心越近，边界越远，代表质量越好</p><p>正样本点的质量计算为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>Q</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><msup><mi>e</mi><mrow><mo>−</mo><mi mathvariant="normal">Δ</mi><msub><mi>d</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow></msup></mrow><annotation encoding="application/x-tex">{Q_{ij}=e^{-\Delta d_{ij}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1852159999999998em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">Δ</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>该质量权重后续运用在计算Loss函数中:</p><p><img src="/img/article/2022/08/01/12.png" alt="" /></p><p><img src="/img/article/2022/08/01/13.png" alt="" /></p><p><img src="/img/article/2022/08/01/14.png" alt="" /></p><p><img src="/img/article/2022/08/01/15.png" alt="" /></p><h3 id="result-2"><a class="markdownIt-Anchor" href="#result-2"></a> Result</h3><p>作者基于RepPoint(anchor-free)和S2A-Net(anchor-based)模型在HRSC2016上进行了实验，效果显著。</p><p><img src="/img/article/2022/08/01/16.png" alt="" /></p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
      <tag>旋转目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oriented RepPoints</title>
    <link href="/2022/07/25/AI-Learning/20220725-Oriented%20RepPoints/"/>
    <url>/2022/07/25/AI-Learning/20220725-Oriented%20RepPoints/</url>
    
    <content type="html"><![CDATA[<h1 id="oriented-reppoints"><a class="markdownIt-Anchor" href="#oriented-reppoints"></a> Oriented RepPoints</h1><h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2><p><strong>论文题目</strong> ：Oriented RepPoints for Aerial Object Detection</p><p><strong>论文地址</strong> ：<a href="https://arxiv.org/pdf/2105.11111.pdf">https://arxiv.org/pdf/2105.11111.pdf</a></p><p><strong>论文出处</strong> ：2022’CVPR</p><p><strong>代码实现</strong> ：<a href="https://github.com/LiWentomng/OrientedRepPoints">https://github.com/LiWentomng/OrientedRepPoints</a></p><h2 id="idea"><a class="markdownIt-Anchor" href="#idea"></a> Idea</h2><p>1.提出3种定向转换函数，将每个特征图中的点集（9个点），转换成有向的框。</p><p>2.点集学习提出了一种有效的 <strong>自适应点评估和分配样本方案APPA</strong> 。</p><p>3.为了匹配定向目标数据和转换函数，提出了损失函数的改进。</p><h2 id="detail"><a class="markdownIt-Anchor" href="#detail"></a> Detail</h2><h3 id="related-work"><a class="markdownIt-Anchor" href="#related-work"></a> Related Work</h3><p>此前，基于角度回归的检测方法在该研究领域占主导地位(通过直接添加角度参数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">{\theta}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span></span>)，</p><p>但是直接方向预测会带来一系列问题=&gt;包括 <strong>损失的不连续性</strong> 和 <strong>回归的不一致性</strong></p><blockquote><p>这两个问题主要是由于角度的周期性(有界)和旋转框的定义表示。</p></blockquote><p>这就导致虽然定位比较准确,但是旋转方向的回归很多时候是不太准确的。</p><p><img src="/img/article/2022/07/25/2.png" alt="" /></p><p>在传统通用检测器中，RepPoints通过使用点集表示来捕获细粒度对象。</p><h3 id="oriented-reppoints-2"><a class="markdownIt-Anchor" href="#oriented-reppoints-2"></a> Oriented RepPoints</h3><h4 id="pre-可变形卷积dcn"><a class="markdownIt-Anchor" href="#pre-可变形卷积dcn"></a> [Pre]-可变形卷积(DCN)</h4><p>ICCV2017： <a href="https://openaccess.thecvf.com/content_ICCV_2017/papers/Dai_Deformable_Convolutional_Networks_ICCV_2017_paper.pdf">Deformable Convolutional Networks</a></p><p><img src="/img/article/2022/07/25/3.png" alt="" /></p><p>这是可变形卷积想要表达的采样形式，a是代表普通的卷积核是3*3的，所示采样的点数是9个，b,c,d都是可变形卷积（c、d只是一种特殊的形式），可以看出a普通卷积采样的位置是固定的，而可变形卷积做的事情就是给9个采样点，<strong>每一个点加一个偏移量得到新的采样坐标</strong>（偏移量是小数，例如原一个采样点坐标（3,4）加上偏移量可能为（3.6,5.8）坐标变成了小数，这个时候就用双线性插值法为该点取值），把新的9个位置作为可变形卷积采样点的位置，<strong>然后再进行常规的卷积加权的操作</strong>。只是改变了采样点的位置。</p><blockquote><ul><li>单线性插值</li></ul><p><img src="/img/article/2022/07/25/5.png" alt="" /></p><p>根据同一条直线斜率相等，可得:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>y</mi><mo>−</mo><msub><mi>y</mi><mn>1</mn></msub></mrow><mrow><mi>x</mi><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub></mrow></mfrac><mo>=</mo><mfrac><mrow><msub><mi>y</mi><mn>2</mn></msub><mo>−</mo><msub><mi>y</mi><mn>1</mn></msub></mrow><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">{\frac{y-y_1}{x-x_1}= \frac{y_2-y_1}{x_2-x_1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.09633em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2603300000000002em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2603300000000002em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></p><p>整理得:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><mrow><mfrac><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><mi>x</mi></mrow><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub></mrow></mfrac><msub><mi>y</mi><mn>1</mn></msub><mo>+</mo><mfrac><mrow><mi>x</mi><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub></mrow></mfrac><msub><mi>y</mi><mn>2</mn></msub></mrow></mrow><annotation encoding="application/x-tex">y = {\frac{x_2-x}{x_2-x_1}y_1 +\frac{x-x_1}{x_2-x_1}y_2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.09633em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2603300000000002em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2603300000000002em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li>双线性插值</li></ul><p><img src="/img/article/2022/07/25/6.png" alt="" /></p><p>就是选择周围相邻的四个点进行三次单行线插值，其中x轴2次，y轴1次。</p></blockquote><p><img src="/img/article/2022/07/25/4.png" alt="" /></p><p>再说一下可变形卷积的结构，先从输入的特征图中，单独用一个小的卷积分支对特征图中的每一个点都学习一组偏移量的信息offset field（这里的通道数是2N，N表示采样点的个数3*3的卷积核N在这里表示9，2表示每个采样点都有x坐标偏移值和y坐标的偏移值），用来表示当卷积核的走到特征图该点的时候应该偏移到哪个位置来计算。这个偏移量没有具体的取值范围，offsets学出来值的应该是有正有负的小数(正负代表方向)，代码中也有后处理来保证加上偏移量的新采样的位置不会超过特征图的范围 。<strong>这个offsets就是点集表示目标的关键</strong>。</p><h4 id="pre-reppoints"><a class="markdownIt-Anchor" href="#pre-reppoints"></a> [Pre]-RepPoints</h4><p>ICCV2019: <a href="https://openaccess.thecvf.com/content_ICCV_2019/papers/Yang_RepPoints_Point_Set_Representation_for_Object_Detection_ICCV_2019_paper.pdf">RepPoints: Point Set Representation for Object Detection</a></p><p>RepPoints点集表示的目标检测属于anchor free的表示。</p><p><img src="/img/article/2022/07/25/7.png" alt="" /></p><p>整体上来看这个网络分为<strong>定位</strong>和<strong>分类</strong>两个内容。这个网络的训练<strong>定位是分为两个阶段</strong>，<strong>分类是一个阶段</strong>。</p><p>下面具体来看下网络结构:</p><p>首先这个网络的backone是用的FPN，出来的是5个层级的Scale的特征图，在此处只对一个特征图出来的head举例子。一层特征图出来被分为两个分支，一个用来做目标的定位，另一个用来做分类。</p><p><img src="/img/article/2022/07/25/8.png" alt="" /></p><p><strong>定位:</strong> 定位部分有两个阶段:</p><p>第一阶段:先做一次3x3的卷积学习一下特征，然后1x1的卷积用来改变通道产生offsets，再进入offset field进行可变形卷积得到每个点的x方向和y方向上的偏移量，我们得到了一组点集9个点的坐标，在通过转换函数Convert即可以生成pseudo box(伪框)。</p><p>转换函数Convert有三种：</p><p><strong>1.Min-max function.</strong> 通过点集所有点的x，y坐标的最大最小值画框。</p><p><strong>2.Partial min-max function.</strong> 通过点集部分点（文章中指出代码中是前四个点）的x，y坐标的最大最小值画框。</p><p><strong>3.Moment-based function.</strong> 通过一组点集中点位置的均值和标准差回归出框的位置。</p><p><img src="/img/article/2022/07/25/9.png" alt="" /></p><p>Positive:</p><p>1.根据GT的尺寸大小，选择某一个scale的特征图，将GT映射在该特征图上(中心点映射)</p><p>2.第一阶段产生的所有pseudo box中与GT的IOU的值大于0.5，评判为positive，进入第二阶段</p><p>第二阶段: Refine stage，与第一阶段步骤大致相同，可以看到point loss明显变小。</p><p><strong>分类:</strong> 分类分支也是对positive pseudo box（有目标的框）做分类，第一阶段产生的pseudo box与GT的IOU大于0.5认为有目标的框做分类损失，用的是focal loss。</p><h4 id="network"><a class="markdownIt-Anchor" href="#network"></a> Network</h4><p><img src="/img/article/2022/07/25/10.png" alt="" /></p><h4 id="oriented-conversion-function"><a class="markdownIt-Anchor" href="#oriented-conversion-function"></a> Oriented conversion function</h4><p>三个定向转换函数</p><p>1.<strong>MinAeraRect</strong> ：在采样点中选择具有最小面积的旋转矩形；（该函数不可导在网路中训练参数不可以反传，所以只在推理的时候应用）</p><p>2.<strong>NearestGTCorner</strong> ：GT的四个角点，找4个距离最近采样点作为预测点。</p><p>3.<strong>ConvexHull</strong>：通过Jarvis March算法，找到包围所有采样点的外接多边形。</p><p><img src="/img/article/2022/07/25/17.png" alt="" /></p><h4 id="adaptive-points-assessment-and-assignment"><a class="markdownIt-Anchor" href="#adaptive-points-assessment-and-assignment"></a> Adaptive Points Assessment and Assignment</h4><p>自适应点集评估和分配样本方案</p><p><img src="/img/article/2022/07/25/11.png" alt="" /></p><p>该方案是在pseudo box与GT box的IOU&gt;0.5的基础上，对这些pseudo box再从四个方面来衡量质量的好坏，然后按照质量分数对其进行排序，通过一个采样率选择质量分数Top前几的作为positive样本进行细化，通过此方式训练的网络可以更好。</p><p><img src="/img/article/2022/07/25/12.png" alt="" /></p><p>1.分类质量:该点集与GT的分类损失focal loss</p><p><img src="/img/article/2022/07/25/13.png" alt="" /></p><p>2.定位质量:该点集生成的多边形与GT的GIOU损失值</p><p><img src="/img/article/2022/07/25/14.png" alt="" /></p><p>3.定向质量:通过倒角距离（Chamfer distance）来衡量</p><p><img src="/img/article/2022/07/25/15.png" alt="" /></p><p>4.逐点相关性质量</p><p><img src="/img/article/2022/07/25/16.png" alt="" /></p><p><strong>动态Top K分配</strong>：选择根据前面4个质量标准，质量分数排在前面k的点集生成的pseudo box去做第二阶段的细化。</p><h4 id="loss-function"><a class="markdownIt-Anchor" href="#loss-function"></a> Loss function</h4><p><strong>NearestGTCorner</strong> 和 <strong>ConvexHull</strong> 转换函数实际上生成的不是一个规则的矩形，而是一个不规则的四边形和多边形。所以这个时候就能用GT的角点来衡量loc的损失，这里是用的GIOU的损失，也对分布在GT范围以外的离群点做了惩罚。惩罚项就是对超出GT的离群点做惩罚，让所有的点分布在GT box之内。(通过惩罚监督，边形框就会越来越接近标准的矩形)</p><p><img src="/img/article/2022/07/25/18.png" alt="" /></p><p>分类:</p><p><img src="/img/article/2022/07/25/19.png" alt="" /></p><p><img src="/img/article/2022/07/25/20.png" alt="" /></p><p>有向定位框:</p><p><img src="/img/article/2022/07/25/21.png" alt="" /></p><p>离散点惩罚：</p><p><img src="/img/article/2022/07/25/22.png" alt="" /></p><p><img src="/img/article/2022/07/25/23.png" alt="" /></p><h2 id="实验部分"><a class="markdownIt-Anchor" href="#实验部分"></a> 实验部分</h2><p>Oriented R-CNN</p><p>有两个问题:</p><p>map比论文中的大</p><p>应该是要取多个阈值训练下的平均值。</p><blockquote><p>voc07通过将IoU从0.5变化到0.95计算不同的mAP,再求平均,更能反映出定位精度</p></blockquote><p>与github上给出的log.json还有一定差距(4%)，不知道是不是参数的设置，准备做一个json比对。</p><p>我自己跑过两个相同的训练，相差只有0.2%左右。</p><p>mutilscale数据集</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
      <tag>旋转目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022-07-11-组会</title>
    <link href="/2022/07/11/Seminar/20220711-%E7%BB%84%E4%BC%9A/"/>
    <url>/2022/07/11/Seminar/20220711-%E7%BB%84%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="2022-07-11-组会"><a class="markdownIt-Anchor" href="#2022-07-11-组会"></a> 2022-07-11-组会</h1><h2 id="oriented-r-cnn"><a class="markdownIt-Anchor" href="#oriented-r-cnn"></a> Oriented R-CNN</h2><p>周末跑通了Oriented R-CNN的代码</p><p>目前在服务器上跑训练，跑到了epoch4/epoch12</p><p>预计明天跑完</p><h2 id="trick"><a class="markdownIt-Anchor" href="#trick"></a> Trick</h2><p>多尺度训练+多尺度测试（[0.5 1.0 1.5]），可以大幅度提升性能</p>]]></content>
    
    
    <categories>
      
      <category>组会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旋转目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022-07-04-组会</title>
    <link href="/2022/07/04/Seminar/20220704-%E7%BB%84%E4%BC%9A/"/>
    <url>/2022/07/04/Seminar/20220704-%E7%BB%84%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="2022-07-04-组会"><a class="markdownIt-Anchor" href="#2022-07-04-组会"></a> 2022-07-04-组会</h1><h2 id="gliding-vertex"><a class="markdownIt-Anchor" href="#gliding-vertex"></a> Gliding Vertex</h2><h2 id="rsdet"><a class="markdownIt-Anchor" href="#rsdet"></a> RSDet</h2><p>四边形的检测还是挺有意义的，毕竟四边形相比旋转矩形的定位更加精确。</p><p>这两篇文章也让我知道了，要想考虑使用四边形检测，需要要考虑标签顺序问题和边界回归问题。</p><h2 id="others"><a class="markdownIt-Anchor" href="#others"></a> Others</h2><p>最近使用batchsize = 8重跑了一次ReDet</p><p>5月底第一次用batchsize=1来跑</p><pre class="language-none"><code class="language-none">2022-05-31 11:41:46,926 - mmrotate - INFO - Saving checkpoint at 12 epochs2022-05-31 13:22:35,774 - mmrotate - INFO - +--------------------+-------+--------+--------+-------+| class              | gts   | dets   | recall | ap    |+--------------------+-------+--------+--------+-------+| plane              | 18788 | 23259  | 0.896  | 0.799 || baseball-diamond   | 1087  | 2135   | 0.724  | 0.651 || bridge             | 4181  | 4962   | 0.584  | 0.470 || ground-track-field | 733   | 1090   | 0.618  | 0.556 || small-vehicle      | 58868 | 110625 | 0.841  | 0.748 || large-vehicle      | 43075 | 74399  | 0.905  | 0.842 || ship               | 76153 | 88620  | 0.869  | 0.805 || tennis-court       | 5923  | 9230   | 0.937  | 0.904 || basketball-court   | 1180  | 2564   | 0.770  | 0.700 || storage-tank       | 13670 | 15183  | 0.674  | 0.622 || soccer-ball-field  | 827   | 2764   | 0.625  | 0.472 || roundabout         | 973   | 1973   | 0.623  | 0.544 || harbor             | 15468 | 22735  | 0.791  | 0.687 || swimming-pool      | 3836  | 8011   | 0.794  | 0.644 || helicopter         | 1189  | 1946   | 0.807  | 0.765 |+--------------------+-------+--------+--------+-------+| mAP                |       |        |        | 0.681 |+--------------------+-------+--------+--------+-------+2022-05-31 13:22:35,861 - mmrotate - INFO - Exp name: redet_re50_refpn_1x_dota_le90.py2022-05-31 13:22:35,861 - mmrotate - INFO - Epoch(val) [12][12800]mAP: 0.6807</code></pre><p>7月初第二次用batchsize=8(ReDet论文中的同一batchsize)来跑，结果近似。。</p><p>好像Batch Normalization在这里并没有提高精度</p><pre class="language-none"><code class="language-none">2022-07-02 19:50:12,213 - mmrotate - INFO - Saving checkpoint at 12 epochs2022-07-02 20:20:42,710 - mmrotate - INFO - +--------------------+-------+--------+--------+-------+| class              | gts   | dets   | recall | ap    |+--------------------+-------+--------+--------+-------+| plane              | 18788 | 39421  | 0.931  | 0.892 || baseball-diamond   | 1087  | 5512   | 0.857  | 0.711 || bridge             | 4181  | 25338  | 0.636  | 0.473 || ground-track-field | 733   | 6700   | 0.782  | 0.552 || small-vehicle      | 58868 | 155702 | 0.807  | 0.703 || large-vehicle      | 43075 | 103456 | 0.882  | 0.766 || ship               | 76153 | 112373 | 0.839  | 0.790 || tennis-court       | 5923  | 13502  | 0.932  | 0.901 || basketball-court   | 1180  | 7586   | 0.714  | 0.615 || storage-tank       | 13670 | 33506  | 0.696  | 0.615 || soccer-ball-field  | 827   | 6799   | 0.674  | 0.454 || roundabout         | 973   | 8810   | 0.733  | 0.549 || harbor             | 15468 | 30952  | 0.773  | 0.658 || swimming-pool      | 3836  | 11873  | 0.810  | 0.688 || helicopter         | 1189  | 3929   | 0.866  | 0.786 |+--------------------+-------+--------+--------+-------+| mAP                |       |        |        | 0.677 |+--------------------+-------+--------+--------+-------+2022-07-02 20:20:42,713 - mmrotate - INFO - Exp name: redet_re50_refpn_1x_dota_le90.py2022-07-02 20:20:42,713 - mmrotate - INFO - Epoch(val) [12][12800]mAP: 0.6769</code></pre>]]></content>
    
    
    <categories>
      
      <category>组会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旋转目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RSDet</title>
    <link href="/2022/07/03/AI-Learning/20220703-RSDet/"/>
    <url>/2022/07/03/AI-Learning/20220703-RSDet/</url>
    
    <content type="html"><![CDATA[<h1 id="rsdet"><a class="markdownIt-Anchor" href="#rsdet"></a> RSDet</h1><h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2><p><strong>论文题目</strong> ：Learning Modulated Loss for Rotated Object Detection</p><p><strong>论文地址</strong> ：<a href="https://arxiv.org/pdf/1911.08299v3.pdf">https://arxiv.org/pdf/1911.08299v3.pdf</a></p><p><strong>论文出处</strong> ：2021’AAAI</p><p><strong>代码实现</strong> ：MMRotate</p><h2 id="idea"><a class="markdownIt-Anchor" href="#idea"></a> Idea</h2><p>四边形检测，直面顺序标签问题</p><h2 id="detail"><a class="markdownIt-Anchor" href="#detail"></a> Detail</h2><h3 id="quadrilateral-detection"><a class="markdownIt-Anchor" href="#quadrilateral-detection"></a> Quadrilateral detection</h3><p>四边形检测需要考虑顺序标签点的问题:</p><p>举一个简单的例子，如果一个四边形的ground-truth是（x1,y1,x2,y2,x3,y3,x4,y4）并且所有的ground-truth并不是按一定规则顺序标注的，那么检测器有可能给出的预测结果是（x2,y2,x3,y3,x4,y4,x1,y1）。其实这两个是框是完全重合的，只是标注点的顺序变化了但是网络训练算损失的时候并不知道，它会按对应位置计算损失，此时的损失值并不为0甚至很大。</p><h3 id="rsdet-2"><a class="markdownIt-Anchor" href="#rsdet-2"></a> RSDet</h3><p>RSDet使用的是非常直白的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mn>1</mn><mo separator="true">,</mo><mi>x</mi><mn>2</mn><mo separator="true">,</mo><mi>y</mi><mn>2</mn><mo separator="true">,</mo><mi>x</mi><mn>3</mn><mo separator="true">,</mo><mi>y</mi><mn>3</mn><mo separator="true">,</mo><mi>x</mi><mn>4</mn><mo separator="true">,</mo><mi>y</mi><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x1,y1,x2,y2,x3,y3,x4,y4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">4</span><span class="mclose">)</span></span></span></span>八参数表示法，描述了四边形的四个顶点坐标。</p><p>解决四边形检测的顺序标签点问题:</p><p><img src="/img/article/2022/07/03/3.png" alt="" /></p><p>其主要步骤是先确定最左边的点（如果水平矩形的话有两个点满足取上面的那个）。然后通过向量叉乘找到对角点，也就是第三个点。最后利用这两个点构成的向量以及叉乘方法，根据顺序的要求（逆时针或者顺时针）找点其他两个点。</p><h4 id="边界问题"><a class="markdownIt-Anchor" href="#边界问题"></a> 边界问题</h4><p><img src="/img/article/2022/07/03/2.png" alt="" /></p><p>蓝色预选框到实际位置的回归过程。绿色真实框为{(a→a) , (b→b) ,(c→c), (d→d)} ，但显然理想的回归过程应为{(a→b),(b→c),(c→d),(d→a)}。这种情况也导致模型训练困难和回归不平滑。</p><p><img src="/img/article/2022/07/03/4.png" alt="" /><br />作者设计了旋转损失的八参数版本，由三个部分组成：<br />①将预选框的四个顶点顺时针移动一个位置；<br />②保持预选框顶点的顺序不变；<br />③将预选框的四个顶点逆时针移动一个位置；<br />④在上述三种情况下取最小值</p><h2 id="result"><a class="markdownIt-Anchor" href="#result"></a> Result</h2><p>作者使用RetinaNet进行有关实验。另外，作者得出八参数比五参数更容易回归。</p><p><img src="/img/article/2022/07/03/5.png" alt="" /></p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
      <tag>旋转目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gliding Vertex</title>
    <link href="/2022/07/02/AI-Learning/20220702-Gliding%20Vertex/"/>
    <url>/2022/07/02/AI-Learning/20220702-Gliding%20Vertex/</url>
    
    <content type="html"><![CDATA[<h1 id="gliding-vertex"><a class="markdownIt-Anchor" href="#gliding-vertex"></a> Gliding Vertex</h1><h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2><p><strong>论文题目</strong> ：Gliding vertex on the horizontal bounding box for multi-oriented object detection</p><p><strong>论文地址</strong> ：<a href="https://arxiv.org/pdf/1911.09358v2.pdf">https://arxiv.org/pdf/1911.09358v2.pdf</a></p><p><strong>论文出处</strong> ：2020’TPAMI</p><p><strong>代码实现</strong> ：MMRotate</p><h2 id="idea"><a class="markdownIt-Anchor" href="#idea"></a> Idea</h2><p>四边形检测，Gliding Vertex是通过学习四个点在非旋转矩形上的偏移来定位出一个四边形来表示一个物体。但具体来说不是直接回归四边形的四个顶点，而是回归四个长度比(这四个长度比反应了每个对应测的相对滑动偏移量)。额外引入了一个倾角因子r去指导应该进行水平检测还是定向检测。</p><h2 id="detail"><a class="markdownIt-Anchor" href="#detail"></a> Detail</h2><h3 id="quadrilateral-detection"><a class="markdownIt-Anchor" href="#quadrilateral-detection"></a> Quadrilateral detection</h3><p>四边形检测需要考虑顺序标签点的问题:</p><p>举一个简单的例子，如果一个四边形的ground-truth是（x1,y1,x2,y2,x3,y3,x4,y4）并且所有的ground-truth并不是按一定规则顺序标注的，那么检测器有可能给出的预测结果是（x2,y2,x3,y3,x4,y4,x1,y1）。其实这两个是框是完全重合的，只是标注点的顺序变化了但是网络训练算损失的时候并不知道，它会按对应位置计算损失，此时的损失值并不为0甚至很大。</p><h3 id="gliding-vertex-2"><a class="markdownIt-Anchor" href="#gliding-vertex-2"></a> Gliding Vertex</h3><p><img src="/img/article/2022/07/02/2.png" alt="" /></p><p>除了有水平矩形框的基本标签<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>w</mi><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,,y,w,h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span>，还额外增加了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>α</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>α</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>α</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>α</mi><mn>4</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\alpha_1,\alpha_2,\alpha_3,\alpha_4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，另外还额外引入了一个倾角因子<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>.</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>长度比反应了每个对应测的相对滑动偏移量，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>则是四边形框与其对应水平框的面积比。</p><p><img src="/img/article/2022/07/02/3.png" alt="" /></p><p>Gliding Vertex文章通过改变框的表示方式避免了上述四边形检测的标签排序问题。</p><h3 id="network"><a class="markdownIt-Anchor" href="#network"></a> Network</h3><p><img src="/img/article/2022/07/02/4.png" alt="" /></p><p>整体的网络结构就是Faster R-CNN，并且后续的损失函数也没有进行创新。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
      <tag>旋转目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu深度学习服务器环境搭建</title>
    <link href="/2022/07/01/Programing/20220701-Ubuntu%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/07/01/Programing/20220701-Ubuntu%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="ubuntu深度学习服务器环境搭建"><a class="markdownIt-Anchor" href="#ubuntu深度学习服务器环境搭建"></a> Ubuntu深度学习服务器环境搭建</h1><p>进入系统后设置一下root账户密码:</p><pre class="language-bash" data-language="bash"><code class="language-bash">sudo passwd root</code></pre><p>同时为了避免每次sudo都要输入密码，配置一下<code>visudo</code>:</p><pre class="language-bash" data-language="bash"><code class="language-bash">sudo visudo</code></pre><p>文件最后加上一行,$[UserName]改为自己的用户名</p><pre class="language-bash" data-language="bash"><code class="language-bash">$[UserName] All&#x3D;(ALL) NOPASSWD: ALL</code></pre><p><code>ctrl + O</code>，<code>回车</code>保存,<code>ctrl + X</code>退出</p><h2 id="下载安装配置"><a class="markdownIt-Anchor" href="#下载安装配置"></a> 下载安装配置</h2><h3 id="21下载vim"><a class="markdownIt-Anchor" href="#21下载vim"></a> 2.1下载vim</h3><pre class="language-bash" data-language="bash"><code class="language-bash">sudo apt install vim</code></pre><h3 id="22-配置国内镜像软件源"><a class="markdownIt-Anchor" href="#22-配置国内镜像软件源"></a> 2.2 配置国内镜像软件源</h3><ol><li>备份原来的源</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">cp &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sources.list.bak</code></pre><ol start="2"><li>设置阿里云镜像源</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">sudo vim &#x2F;etc&#x2F;apt&#x2F;sources.list</code></pre><p>修改内容为:</p><pre class="language-txt" data-language="txt"><code class="language-txt">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal main restricted universe multiversedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal-security main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal-security main restricted universe multiversedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal-updates main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal-updates main restricted universe multiversedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal-proposed main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal-proposed main restricted universe multiversedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal-backports main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal-backports main restricted universe multiverse</code></pre><p><code>esc</code>退出编辑,   <code>:wq</code>保存</p><p>更新软件列表</p><pre class="language-bash" data-language="bash"><code class="language-bash">sudo apt updatesudo apt upgrade</code></pre><h3 id="23-安装python和pip"><a class="markdownIt-Anchor" href="#23-安装python和pip"></a> 2.3 安装Python和pip</h3><p>步骤同智辉君.</p><h3 id="24-ssh远程连接"><a class="markdownIt-Anchor" href="#24-ssh远程连接"></a> 2.4  ssh远程连接</h3><ol><li>安装ssh</li></ol><pre class="language-text" data-language="text"><code class="language-text">sudo apt install ssh</code></pre><ol start="2"><li>安装xrdp</li></ol><pre class="language-text" data-language="text"><code class="language-text">sudo apt install xrdp</code></pre><p>启动xrdp:</p><pre class="language-text" data-language="text"><code class="language-text">sudo systemctl status xrdp</code></pre><p>`将xrdp用户添加到ssl-cert  用户组：</p><pre class="language-text" data-language="text"><code class="language-text">sudo adduser xrdp ssl-cert  sudo systemctl restart xrdp</code></pre><p>使用Windows自带的远程桌面软件连接服务器IP地址或者域名就行</p><h3 id="25-安装frp进行内网穿透"><a class="markdownIt-Anchor" href="#25-安装frp进行内网穿透"></a> 2.5 安装frp进行内网穿透</h3><p>这一部分需要一个公网ip,可以用网上的各种临时公网ip租用(如花生壳)，也可以买一个cvm云服务器(送一个公网ip)</p><p><a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a></p><p>本人下载的是frp_0.43.0_linux_amd64.tar</p><h4 id="在云服务器端配置frps-frp-server"><a class="markdownIt-Anchor" href="#在云服务器端配置frps-frp-server"></a> 在云服务器端配置frps (frp server)</h4><p>解压</p><pre class="language-bash" data-language="bash"><code class="language-bash">tar -zxvf frp_0.43.0_linux_amd64.tar.gz</code></pre><p>编辑frps.ini 文件</p><pre class="language-bash" data-language="bash"><code class="language-bash">[common]#frp服务的端口号，可以自己定bind_port &#x3D; 7000 #frp的web界面的端口号dashboard_port &#x3D; 7500 #web界面的登陆账户，自己修改dashboard_user &#x3D; user#web界面的登陆密码，自己修改dashboard_pwd &#x3D; pass authentication_method &#x3D; token#frp客户端连接时的密码，自己修改token &#x3D; xxxxx </code></pre><p>在<code>/etc/systemd/system/</code>配置自动运行服务脚本frps.service(<code>vim frps.service</code>)</p><pre class="language-bash" data-language="bash"><code class="language-bash">[GLACIER]Description&#x3D;Frp Server DaemonAfter&#x3D;syslog.target network.targetWants&#x3D;network.target [Service]Type&#x3D;simple#修改为你的frps实际安装目录ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;frp&#x2F;frps -c &#x2F;usr&#x2F;local&#x2F;bin&#x2F;frp&#x2F;frps.ini ExecStop&#x3D;&#x2F;usr&#x2F;bin&#x2F;killall frps#启动失败1分钟后再次启动RestartSec&#x3D;1minKillMode&#x3D;control-group#重启控制：总是重启Restart&#x3D;always [Install]WantedBy&#x3D;multi-user.target</code></pre><p>启用脚本并查看脚本状态,为running配置成功:</p><pre class="language-bash" data-language="bash"><code class="language-bash">sudo systemctl enable frps.servicesudo systemctl start frps.servicesudo systemctl status frps.service</code></pre><p><strong>注意</strong></p><blockquote><p>大部分云服务器都要配置安全组，将对应端口放行</p><p>如果云服务器上还配置了nginx服务器如宝塔，要注意防火墙将对应端口放行</p></blockquote><h4 id="在个人服务器端配置frpc-frp-client"><a class="markdownIt-Anchor" href="#在个人服务器端配置frpc-frp-client"></a> 在个人服务器端配置frpc (frp client)</h4><p>解压</p><pre class="language-bash" data-language="bash"><code class="language-bash">tar -zxvf frp_0.43.0_linux_amd64.tar.gz</code></pre><p>编辑frpc.ini 文件</p><pre class="language-bash" data-language="bash"><code class="language-bash">[common]#你的云服务器的公网ipserver_addr &#x3D; xx.xx.xx.xx authentication_method &#x3D; token#刚刚配置的frp连接密码 token &#x3D; xxxxx #刚刚配置的frp服务端口server_port &#x3D; 7000#Frpc login to server failed: i&#x2F;o deadline reachedtls_enable &#x3D; true[GLACIER-ssh]type &#x3D; tcplocal_ip &#x3D; 127.0.0.1local_port &#x3D; 22remote_port &#x3D; 20022[GLACIER-rdp]type &#x3D; tcplocal_ip &#x3D; 127.0.0.1local_port &#x3D; 3389remote_port &#x3D; 23389</code></pre><p>在<code>/etc/systemd/system/</code>下配置自动运行服务脚本frpc.service(<code>vim frpc.service</code>)</p><pre class="language-text" data-language="text"><code class="language-text">[GLACIER]Description&#x3D;Frp Client DaemonAfter&#x3D;syslog.target network.targetWants&#x3D;network.target [Service]Type&#x3D;simple#修改为你的frpc实际安装目录ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;frp&#x2F;frpc -c &#x2F;usr&#x2F;local&#x2F;bin&#x2F;frp&#x2F;frpc.ini ExecStop&#x3D;&#x2F;usr&#x2F;bin&#x2F;killall frpc#启动失败1分钟后再次启动RestartSec&#x3D;1minKillMode&#x3D;control-group#重启控制：总是重启Restart&#x3D;always [Install]WantedBy&#x3D;multi-user.target</code></pre><p>启用脚本并查看脚本状态,为running配置成功:</p><pre class="language-bash" data-language="bash"><code class="language-bash">sudo systemctl enable frpc.servicesudo systemctl start frpc.servicesudo systemctl status frpc.service</code></pre><h3 id="26-配置samba映射网络驱动"><a class="markdownIt-Anchor" href="#26-配置samba映射网络驱动"></a> 2.6 配置SAMBA，映射网络驱动</h3><h4 id="个人服务器端"><a class="markdownIt-Anchor" href="#个人服务器端"></a> 个人服务器端</h4><ol><li>安装<code>samba</code> 和<code>samba-common-bin</code></li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">sudo apt-get install samba samba-common-bin</code></pre><ol start="2"><li>配置/etc/samba/smb.conf文件</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">sudo vim &#x2F;etc&#x2F;samba&#x2F;smb.conf</code></pre><p>在最后一行后面加入：</p><pre class="language-bash" data-language="bash"><code class="language-bash"># 共享文件夹显示的名称[home]# 说明信息comment &#x3D; GLACIER WorkStation Storage# 可以访问的用户valid users &#x3D; grinder,root# 共享文件的路径path &#x3D; &#x2F;home&#x2F;grinder&#x2F;# 可被其他人看到资源名称（非内容）browseable &#x3D; yes# 可写writable &#x3D; yes# 新建文件的权限为 664create mask &#x3D; 0664# 新建目录的权限为 775directory mask &#x3D; 0775</code></pre><ol start="3"><li>添加登陆账户并创建密码</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">sudo smbpasswd -a grinder</code></pre><p>重启服务即可:</p><pre class="language-bash" data-language="bash"><code class="language-bash">sudo &#x2F;etc&#x2F;init.d&#x2F;samba-ad-dc restart</code></pre><h4 id="window端"><a class="markdownIt-Anchor" href="#window端"></a> Window端</h4><p><strong>控制面板</strong> -&gt; <strong>程序</strong> -&gt; <strong>程序和功能</strong> -&gt; <strong>启用或关闭 Windows 功能</strong> -&gt; 勾选<strong>SMB 1.0/CIFS 文件共享支持</strong></p><p>(<strong>Win + R</strong> 快捷键打开运行界面 ，输入<strong>gpedit.msc</strong> 打开本地组策略编辑器)</p><p><strong>本地组策略编辑器</strong> -&gt; <strong>计算机配置</strong> -&gt; <strong>管理模板</strong> -&gt; <strong>网络</strong> -&gt; <strong>Lanman工作站</strong> -&gt; <strong>启用不安全的来宾登录</strong></p><p>(<strong>Win + R</strong> 快捷键打开运行界面 ，输入<strong>secpol.msc</strong> 打开本地安全策略编辑器)</p><p><strong>本地安全策略编辑器</strong> -&gt; <strong>本地策略</strong> -&gt; <strong>安全选项</strong> -&gt; <strong>网络安全：LAN管理器身份验证级别</strong> -&gt; <strong>仅发送 NTLM2响应</strong></p><p>重启Windows</p><p>映射网络驱动器  : <code>\\192.168.0.106</code> =&gt; (ip地址是你的ubuntu服务器, 用<code>ifconfig</code>查看)</p><p>以上于2022年6月29日 配置完成</p><p>做完以上步骤就能方便的使用ssh连接该服务器了</p><h2 id="dl环境"><a class="markdownIt-Anchor" href="#dl环境"></a> DL环境</h2><h3 id="31-安装nvidia驱动"><a class="markdownIt-Anchor" href="#31-安装nvidia驱动"></a> 3.1 安装NVIDIA驱动</h3><p>进入系统的图形桌面，打开<code>Software &amp; Updates</code>软件，可以看到标签栏有一个<code>Additional Drivers</code>：</p><p>选择510版本的驱动安装，不要选择515测试版</p><p>安装完后重启电脑，查看显卡驱动:</p><pre class="language-none"><code class="language-none">nvidia-smi</code></pre><h3 id="32-安装cuda"><a class="markdownIt-Anchor" href="#32-安装cuda"></a> 3.2 安装CUDA</h3><p>这里pythorch 有11.3的支持，因此选择安装11.3update1版本的cuda</p><p>登录https://developer.nvidia.com/cuda-toolkit-archive</p><p>选择11.3.1版本的runfile版本,下载到/usr/local/bin中，在这个过程中可以先下载liburcu6</p><blockquote><p>然后22.04的ubuntu需要下载liburcu6: <a href="https://packages.debian.org/bullseye/amd64/liburcu6/download">https://packages.debian.org/bullseye/amd64/liburcu6/download</a><br />解压安装该liburcu6</p><pre class="language-bash" data-language="bash"><code class="language-bash">&gt;sudo dpkg -i  liburcu6_0.12.2-1amd64.deb</code></pre></blockquote><p>下载好cuda11.3后，执行以下命令安装</p><p>如果你的gcc版本是11，需要添加<code>--orverride</code>或者降级到gcc9</p><p><a href="https://blog.csdn.net/Cris_Hu/article/details/124711093">https://blog.csdn.net/Cris_Hu/article/details/124711093</a></p><pre class="language-bash" data-language="bash"><code class="language-bash">sudo chmod +x cuda_11.3.1_465.19.01_linux.runsudo sh cuda_11.3.1_465.19.01_linux.run  (--override)</code></pre><p>配置环境变量</p><pre class="language-bash" data-language="bash"><code class="language-bash">sudo vim  ~&#x2F;.bashrc</code></pre><p>在该文件的最后一行加入以下语句:</p><pre class="language-bash" data-language="bash"><code class="language-bash"># CUDA Environment Pathexport CUDA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;cuda-11.3export LD_LIBRARY_PATH&#x3D;$&#123;CUDA_HOME&#125;&#x2F;lib64export PATH&#x3D;$&#123;CUDA_HOME&#125;&#x2F;bin:$&#123;PATH&#125;</code></pre><p>更新环境变量:</p><pre class="language-bash" data-language="bash"><code class="language-bash">source ~&#x2F;.bashrc</code></pre><p>使用命令查看cuda信息，检验是否安装成功:</p><pre class="language-bash" data-language="bash"><code class="language-bash">nvcc -V</code></pre><h3 id="33安装cudnn"><a class="markdownIt-Anchor" href="#33安装cudnn"></a> 3.3安装CuDNN</h3><p><a href="https://developer.nvidia.com/rdp/cudnn-download">https://developer.nvidia.com/rdp/cudnn-download</a></p><p>需要登录网址才能下载cudnn</p><blockquote><p>备忘: 这里我用的是QQ邮箱账号和密码政注册的</p></blockquote><p>然后选择cudnn 8.4.1 Linux_x86_64.tar下载</p><p>解压:</p><p>使用以下两条命令复制这些文件到CUDA目录下：(<strong>注意修改</strong>)</p><pre class="language-text" data-language="text"><code class="language-text">sudo cp cudann&#x2F;lib64&#x2F;* &#x2F;usr&#x2F;local&#x2F;cuda-11.3&#x2F;lib64&#x2F;sudo cp cudann&#x2F;include&#x2F;* &#x2F;usr&#x2F;local&#x2F;cuda-11.3&#x2F;include&#x2F;</code></pre><p>查看CUDNN版本</p><pre class="language-none"><code class="language-none">cat &#x2F;usr&#x2F;local&#x2F;cuda&#x2F;include&#x2F;cudnn_version.h | grep CUDNN_MAJOR -A 2</code></pre><h3 id="34-安装anaconda"><a class="markdownIt-Anchor" href="#34-安装anaconda"></a> 3.4 安装anaconda</h3><p>浏览器搜索然后安装linux版的就好了</p><p>注意安装在<code>/home/&#123;用户名&#125;/Software</code>下，</p><p>如果你不想安装Docker，那么可以直接开始建你需要的虚拟环境了</p><h3 id="35-安装docker"><a class="markdownIt-Anchor" href="#35-安装docker"></a> 3.5 安装Docker</h3><h2 id="杂项配置"><a class="markdownIt-Anchor" href="#杂项配置"></a> 杂项配置</h2><h3 id="安装pycharm"><a class="markdownIt-Anchor" href="#安装pycharm"></a> 安装Pycharm</h3><h3 id="同步ubuntu和window时间"><a class="markdownIt-Anchor" href="#同步ubuntu和window时间"></a> 同步ubuntu和window时间</h3><pre class="language-bash" data-language="bash"><code class="language-bash">sudo apt install ntpdatesudo ntpdate time.windows.comsudo hwclock --localtime --systohc</code></pre><h3 id="unbuntu截图工具flameshot"><a class="markdownIt-Anchor" href="#unbuntu截图工具flameshot"></a> Unbuntu截图工具flameshot</h3><pre class="language-bash" data-language="bash"><code class="language-bash">sudo apt install flameshot</code></pre>]]></content>
    
    
    <categories>
      
      <category>常用命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Deep Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022-06-27-组会</title>
    <link href="/2022/06/27/Seminar/20220627-%E7%BB%84%E4%BC%9A/"/>
    <url>/2022/06/27/Seminar/20220627-%E7%BB%84%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="2022-06-27-组会"><a class="markdownIt-Anchor" href="#2022-06-27-组会"></a> 2022-06-27-组会</h1><h2 id="oriented-r-cnn"><a class="markdownIt-Anchor" href="#oriented-r-cnn"></a> Oriented R-CNN</h2><p>2021 CVPR</p><p><a href="/2022/06/26/AI-Learning/20220627-Oriented R-CNN" target="_blank">Oriented R-CNN解读</a></p><h2 id="kld"><a class="markdownIt-Anchor" href="#kld"></a> KLD</h2><p>2021 NeurIPS</p><p><strong>Gaussian Wasserstein Distance换成了Kullback-Leibler Divergence</strong></p><p>GWD的侧重点在于分析将框的表示从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>w</mi><mo separator="true">,</mo><mi>h</mi><mo separator="true">,</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y,w,h,\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span>转换成二维高斯分布的好处，也就是解决了边界问题、类正方形检测问题、损失和评估不一致问题</p><p>作者在KLD中从理论上分析：为什么Kullback-Leibler Divergence会比Wasserstein Distance要好</p><p>用旋转还是水平anchor有了一些新的理解:</p><blockquote><p><strong>当目标非常小或者某一条边比较短的时候，很小的位置偏移都会造成IoU的急剧下降</strong></p><p>偏移的现象和中心点参数梯度的权重有关，</p><p>旋转anchor能提供高质量的先验，它的长宽和gt接近，所以基于旋转anchor的方法中心点偏移不严重；</p><p>而水平anchor的长宽没法反应实际gt的尺寸大小，因此中心点偏移严重，需要额外的精修阶段</p></blockquote><h2 id="scrdet"><a class="markdownIt-Anchor" href="#scrdet"></a> SCRDet</h2><p>2019 ICCV</p><p>放在现在，没有特别多能够借鉴的地方，因为现在许多基于RPN的检测器都超过了该检测器</p><p>IoU-Smooth L1 Loss</p>]]></content>
    
    
    <categories>
      
      <category>组会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旋转目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oriented R-CNN</title>
    <link href="/2022/06/26/AI-Learning/20220627-Oriented%20R-CNN/"/>
    <url>/2022/06/26/AI-Learning/20220627-Oriented%20R-CNN/</url>
    
    <content type="html"><![CDATA[<h1 id="oriented-r-cnn"><a class="markdownIt-Anchor" href="#oriented-r-cnn"></a> Oriented R-CNN</h1><h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2><p><strong>论文题目</strong> ：Oriented R-CNN for Object Detection</p><p><strong>论文地址</strong> ：<a href="https://arxiv.org/pdf/2101.11952v4.pdf">https://arxiv.org/pdf/2101.11952v4.pdf</a></p><p><strong>论文出处</strong> ：2021’CVPR</p><p><strong>代码实现</strong> ：<a href="https://github.com/jbwang1997/OBBDetection">https://github.com/jbwang1997/OBBDetection</a></p><h2 id="idea"><a class="markdownIt-Anchor" href="#idea"></a> Idea</h2><p>Oriented R-CNN是一个Two-Stage的检测器。</p><p>在the first stage上，作者进行了主要创新:提出了oriented Region Proposal Network(简称oriented RPN)，该网络能 <strong>已近乎0成本的方式直接生成高质量的旋转建议框(oriented proposal)</strong> ，使得检测速度在单张2080ti上达到了15.1FPS；在the second stage上，作者沿用了ROI Transformer中的RROI Align提取旋转不变特征，并用于后续分类和回归。</p><h2 id="detail"><a class="markdownIt-Anchor" href="#detail"></a> Detail</h2><h3 id="related-work"><a class="markdownIt-Anchor" href="#related-work"></a> Related Work</h3><p><img src="/img/article/2022/06/27/2.png" alt="" /></p><p>之前的Two-Stage检测器主要存在以下问题：</p><ol><li>生成旋转建议框的计算成本很高</li><li>采用水平ROI进行分类和定向边界框回归，这样对象和特征之间的错位导致分类置信度与定位精度的不一致</li></ol><h3 id="oriented-r-cnn-2"><a class="markdownIt-Anchor" href="#oriented-r-cnn-2"></a> Oriented R-CNN</h3><p><img src="/img/article/2022/06/27/3.png" alt="" /></p><p>具体细分为Oriented RPN和Oriented R-CNN Head两个部分。</p><h4 id="oriented-rpn"><a class="markdownIt-Anchor" href="#oriented-rpn"></a> Oriented RPN</h4><p><img src="/img/article/2022/06/27/4.png" alt="" /></p><p><img src="/img/article/2022/06/27/5.png" alt="" /></p><p>其实Oriented RPN是很自然并且很直观的一个idea，但它实现的关键就在于如何直接表示oriented proposal。</p><p>在原本的RPN基础上，作者添加了两个1x1的conv layer构成了Oriented RPN。</p><p>第一个conv layer是一个回归分支，通过6A的channel输出proposal相对于anchor的偏移量:</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>δ</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>δ</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>δ</mi><mi>w</mi></msub><mo separator="true">,</mo><msub><mi>δ</mi><mi>h</mi></msub><mo separator="true">,</mo><msub><mi>δ</mi><mi>α</mi></msub><mo separator="true">,</mo><msub><mi>δ</mi><mi>β</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\delta = (\delta_{x},\delta_{y},\delta_{w},\delta_{h},\delta_{\alpha},\delta_{\beta})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.0037em;">α</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05278em;">β</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p><img src="/img/article/2022/06/27/6.png" alt="" /></p><p>然后通过上述公式Decoding得到:</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>w</mi><mo separator="true">,</mo><mi>h</mi><mo separator="true">,</mo><mi mathvariant="normal">△</mi><mi>α</mi><mo separator="true">,</mo><mi mathvariant="normal">△</mi><mi>β</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y,w,h,\triangle\alpha,\triangle\beta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">△</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">△</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">)</span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">△</mi><mi>α</mi><mo separator="true">,</mo><mi mathvariant="normal">△</mi><mi>β</mi></mrow><annotation encoding="application/x-tex">\triangle\alpha,\triangle\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">△</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">△</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span></span></span></span>是平行四边形proposal顶点相对于外部矩形上侧和右侧中点的偏移量</p><p><img src="/img/article/2022/06/27/7.png" alt="" /></p><p>然后通过上述公式求得proposal四个顶点:</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>v</mi><mn>1</mn><mo separator="true">,</mo><mi>v</mi><mn>2</mn><mo separator="true">,</mo><mi>v</mi><mn>3</mn><mo separator="true">,</mo><mi>v</mi><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v1,v2,v3,v4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">4</span><span class="mclose">)</span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mn>1</mn><mo separator="true">,</mo><mi>v</mi><mn>2</mn><mo separator="true">,</mo><mi>v</mi><mn>3</mn><mo separator="true">,</mo><mi>v</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">v1,v2,v3,v4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">4</span></span></span></span>是平行四边形proposal四个顶点的坐标向量</p><p><img src="/img/article/2022/06/27/8.png" alt="" /></p><p>作者将上述这个表示法称为midpoint offset representation。</p><p>第二个conv layer是一个对oriented proposal分类准确度的评分分支，不重要，具体没有展开讲解。</p><h4 id="oriented-r-cnn-head"><a class="markdownIt-Anchor" href="#oriented-r-cnn-head"></a> Oriented R-CNN Head</h4><p><img src="/img/article/2022/06/27/9.png" alt="" /></p><p>得到了上述的平行四边形oriented proposals<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>v</mi><mn>1</mn><mo separator="true">,</mo><mi>v</mi><mn>2</mn><mo separator="true">,</mo><mi>v</mi><mn>3</mn><mo separator="true">,</mo><mi>v</mi><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v1,v2,v3,v4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">4</span><span class="mclose">)</span></span></span></span>后，需要转换为矩形才能用于RROI Align。</p><p>作者的做法是 <strong>延长该平行四边形两条对角线中较短的一边，以此构成矩形框</strong></p><p><img src="/img/article/2022/06/27/10.png" alt="" /></p><p>通过数学方法将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>v</mi><mn>1</mn><mo separator="true">,</mo><mi>v</mi><mn>2</mn><mo separator="true">,</mo><mi>v</mi><mn>3</mn><mo separator="true">,</mo><mi>v</mi><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v1,v2,v3,v4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">4</span><span class="mclose">)</span></span></span></span>转为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>w</mi><mo separator="true">,</mo><mi>h</mi><mo separator="true">,</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y,w,h,\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span>，而后将该矩形框映射到Feature map上，再进入到后续RROI Align模块。</p><p>RROI Align部分，直接沿用了ROI Transformer中的成果，使用深度特征对齐提取旋转不变特征，并用于后续分类和回归。</p><h3 id="experiments"><a class="markdownIt-Anchor" href="#experiments"></a> Experiments</h3><p>作者使用ResNet-50-FPN, ResNet-101-FPN作为Backbone，在DOTA和HSRC2016数据集上，用单张2080ti做训练和测试，达到了SOTA。</p><p><img src="/img/article/2022/06/27/11.png" alt="" /></p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
      <tag>旋转目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GWD Loss</title>
    <link href="/2022/06/19/AI-Learning/20220620-GWD/"/>
    <url>/2022/06/19/AI-Learning/20220620-GWD/</url>
    
    <content type="html"><![CDATA[<h1 id="gaussian-wasserstein-distance-loss"><a class="markdownIt-Anchor" href="#gaussian-wasserstein-distance-loss"></a> Gaussian Wasserstein Distance Loss</h1><h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2><p><strong>论文题目</strong> : Rethinking Rotated Object Detection with GaussianWasserstein Distance Loss</p><p><strong>论文地址</strong> : <a href="https://arxiv.org/pdf/2101.11952v4.pdf">https://arxiv.org/pdf/2101.11952v4.pdf</a></p><h2 id="idea"><a class="markdownIt-Anchor" href="#idea"></a> Idea</h2><p>将任意旋转矩形近似成一个二维的高斯分布，通过计算分布之间的Wasserstein距离解决RIoU不可导的问题</p><p>目前旋转目标检测主流的工作，相较于水平目标检测，都是添加一个角度参数，采用回归的方法来预测旋转角度。但是这样的角度回归模型会带来新的问题：</p><ol><li>评估度量（metric）和损失（loss）和的不一致性</li><li>边界不连续性</li><li>类正方形检测问题</li></ol><h2 id="detail"><a class="markdownIt-Anchor" href="#detail"></a> Detail</h2><p>先认识上述提到的三个问题</p><h3 id="the-inconsistency-between-metriciou-and-loss"><a class="markdownIt-Anchor" href="#the-inconsistency-between-metriciou-and-loss"></a> The inconsistency between metric（IOU） and loss</h3><p>IOU一直是水平和旋转目标检测的标准评估指标，然而该度量和回归损失之间存在着不一致。</p><p>在水平目标检测中,后面提出的PIOU和DIOU可以填补这个问题，但是在旋转目标检测中，两个旋转框的IOU的Learning是不可微分的(旋转IoU存在稀疏的几个不可导点)</p><blockquote><p>作者举例提到了一个(ln-norms)，并给出了论文索引[45,80]，还没深究。</p></blockquote><p>而旋转目标检测的角度回归模型，更放大了这一特性:</p><p><img src="/img/article/2022/06/20/3.png" alt="" /></p><p>主要看图中IOU和经典旋转目标检测中的Smooth L1 Loss的对比</p><ol><li>图a描述了角度差和损失函数的关系</li><li>图b展示了具有不同的长宽比例的检测框和损失函数的关系</li><li>图c探讨了中心点移动和损失函数的关系</li></ol><p>通过以上对比，可以看出旋转目标检测中经典的Smooth L1 loss的缺陷。</p><h3 id="boundary-discontinuity"><a class="markdownIt-Anchor" href="#boundary-discontinuity"></a> Boundary discontinuity</h3><p>两种定义方法:长边定义法和OpenCV定义法。</p><p><img src="/img/article/2022/06/20/4.png" alt="" /></p><p>这里的边界问题主要在于预定义的anchor/proposal如果在90度,180度等这样的边界位置，</p><blockquote><p><strong>长边定义法在边界处有角度的周期性(POA)</strong></p><p><strong>OpenCV定义法在边界处有角度的周期性(POA)和长短边的可交换性(EOE)</strong></p></blockquote><p><strong>导致预测框的结果超出了定义范围</strong>，此时会带来非常大的Smooth L1 IOU Loss。</p><p>这对一些学习能力较弱的模型，在边界情况下的表现是非常脆弱的:</p><p><img src="/img/article/2022/06/20/2.png" alt="" /></p><h3 id="square-like-problem"><a class="markdownIt-Anchor" href="#square-like-problem"></a> Square-like problem</h3><p>基于长边定义法的模型还存在一个类似正方形的对象检测问题。</p><p><img src="/img/article/2022/06/20/5.png" alt="" /></p><p>预测框(-60度)和Ground Truth(30度)的IOU接近1，但是回归损失会很大，这样又回到了第一个问题:评估度量和损失的不一致。</p><p>而由于OpenCV定义法具有长短边的可交换性，因此不存在类Square-like problem。</p><h3 id="the-proposed-method"><a class="markdownIt-Anchor" href="#the-proposed-method"></a> The Proposed Method</h3><p>将任意旋转矩形近似成一个二维的高斯分布，通过计算分布之间的Wasserstein距离解决RIoU不可导的问题</p><p><img src="/img/article/2022/06/20/6.png" alt="" /></p><p>将任意旋转矩形框转换为二维高斯分布:</p><p><img src="/img/article/2022/06/20/7.png" alt="" /></p><p>两个高斯分布之间的Wasserstein距离公式:</p><p><img src="/img/article/2022/06/20/8.png" alt="" /></p><p>而该Wasserstein距离是可导的，这样通过计算两个高斯分布之间Wasserstein距离的Loss来近似IOU的Loss</p><p>后续通过引入一些超参数变换，控制函数值域，去近似IOU的Loss：</p><p><img src="/img/article/2022/06/20/9.png" alt="" /></p><h2 id="result"><a class="markdownIt-Anchor" href="#result"></a> Result</h2><p>作者在五个公共数据集和两个前沿的旋转目标检测模型上，应用了该GWD Loss，得到的效果基本完胜IoU-Smooth L1 Loss, Modulated loss，CSL, 和DCL。</p><p><img src="/img/article/2022/06/20/10.png" alt="" /></p><p><img src="/img/article/2022/06/20/11.png" alt="" /></p><p><img src="/img/article/2022/06/20/12.png" alt="" /></p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
      <tag>旋转目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022-06-06-组会</title>
    <link href="/2022/06/05/Seminar/20220606-%E7%BB%84%E4%BC%9A/"/>
    <url>/2022/06/05/Seminar/20220606-%E7%BB%84%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="2022-06-06-组会"><a class="markdownIt-Anchor" href="#2022-06-06-组会"></a> 2022-06-06-组会</h1><h2 id="训练结果"><a class="markdownIt-Anchor" href="#训练结果"></a> 训练结果</h2><p>跑完了ReDet的训练(基于DOTAv1.0)</p><p>训练结果日志:</p><p>ap为平均精度</p><pre class="language-none"><code class="language-none">2022-05-31 13:41:46,926 - mmrotate - INFO - Saving checkpoint at 12 epochs2022-05-31 14:22:35,774 - mmrotate - INFO - +--------------------+-------+--------+--------+-------+| class              | gts   | dets   | recall | ap    |+--------------------+-------+--------+--------+-------+| plane              | 18788 | 23259  | 0.896  | 0.799 || baseball-diamond   | 1087  | 2135   | 0.724  | 0.651 || bridge             | 4181  | 4962   | 0.584  | 0.470 || ground-track-field | 733   | 1090   | 0.618  | 0.556 || small-vehicle      | 58868 | 110625 | 0.841  | 0.748 || large-vehicle      | 43075 | 74399  | 0.905  | 0.842 || ship               | 76153 | 88620  | 0.869  | 0.805 || tennis-court       | 5923  | 9230   | 0.937  | 0.904 || basketball-court   | 1180  | 2564   | 0.770  | 0.700 || storage-tank       | 13670 | 15183  | 0.674  | 0.622 || soccer-ball-field  | 827   | 2764   | 0.625  | 0.472 || roundabout         | 973   | 1973   | 0.623  | 0.544 || harbor             | 15468 | 22735  | 0.791  | 0.687 || swimming-pool      | 3836  | 8011   | 0.794  | 0.644 || helicopter         | 1189  | 1946   | 0.807  | 0.765 |+--------------------+-------+--------+--------+-------+| mAP                |       |        |        | 0.681 |+--------------------+-------+--------+--------+-------+2022-05-31 14:22:35,861 - mmrotate - INFO - Exp name: redet_re50_refpn_1x_dota_le90.py2022-05-31 14:22:35,861 - mmrotate - INFO - Epoch(val) [12][12800]mAP: 0.6807</code></pre><p>和论文中贴出来的结果表格的相比，总体mAP(平均精度均值)要少8个百分点:</p><p><img src="/img/article/2022/06/06/1.png" alt="" /></p><p>初步分析是因为Batch Size不一样， GPU不一样,:</p><p><img src="/img/article/2022/06/06/4.png" alt="" /></p><p>我租用的云服务器GPU是2080ti，因为第一次训练怕爆显存，我跑的时候batch_size设置成了1。</p><h2 id="日志分析"><a class="markdownIt-Anchor" href="#日志分析"></a> 日志分析</h2><p>分类损失和回归损失:</p><p>最终loss_rpn_cls: 0.0263, loss_rpn_bbox: 0.0228</p><p><img src="/img/article/2022/06/06/2.png" alt="" /></p><p>总Loss函数损失:</p><p>最终总loss: 0.5917</p><p><img src="/img/article/2022/06/06/3.png" alt="" /></p>]]></content>
    
    
    <categories>
      
      <category>组会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旋转目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022-05-30-组会</title>
    <link href="/2022/05/29/Seminar/20220530-%E7%BB%84%E4%BC%9A/"/>
    <url>/2022/05/29/Seminar/20220530-%E7%BB%84%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="2022-05-29-组会"><a class="markdownIt-Anchor" href="#2022-05-29-组会"></a> 2022-05-29-组会</h1><p>已经通过MMRotate框架，跑通了ReDet模型</p><p>目前正在训练,设置了一共跑12个epoch。</p><p>2022/5/29  17时，开始训练</p><p><img src="/img/article/2022/05/30/1.png" alt="" /></p><p>2022/5/30  14时, 正在跑第6个epoch，</p><p><img src="/img/article/2022/05/30/2.png" alt="" /></p><p>大概要跑到5月31日晚上</p>]]></content>
    
    
    <categories>
      
      <category>组会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旋转目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MMRotate框架学习(一)</title>
    <link href="/2022/05/22/AI-Learning/Code-Implement/20220523-MMRotate/"/>
    <url>/2022/05/22/AI-Learning/Code-Implement/20220523-MMRotate/</url>
    
    <content type="html"><![CDATA[<h1 id="mmrotate框架学习一"><a class="markdownIt-Anchor" href="#mmrotate框架学习一"></a> MMRotate框架学习(一)</h1><h2 id="mmrotate中的旋转框定义"><a class="markdownIt-Anchor" href="#mmrotate中的旋转框定义"></a> MMRotate中的旋转框定义</h2><p>图像空间采用右手坐标系 (y,x) ，即 y轴 是从上-&gt;下， x轴是从左-&gt;右。 此时存在2种相反的旋转方向，顺时针和逆时针。</p><h3 id="旋转变换"><a class="markdownIt-Anchor" href="#旋转变换"></a> 旋转变换</h3><h4 id="顺时针cw"><a class="markdownIt-Anchor" href="#顺时针cw"></a> 顺时针(CW)</h4><p>顺时针正角度，逆时针负角度。(<strong>上负下正</strong>)</p><pre class="language-none"><code class="language-none">0-------------------&gt; x (0 rad)|  A-------------B|  |             ||  |     box     h|  |   angle&#x3D;0   ||  D------w------Cvy (pi&#x2F;2 rad)</code></pre><h5 id="顺时针的旋转矩阵"><a class="markdownIt-Anchor" href="#顺时针的旋转矩阵"></a> 顺时针的旋转矩阵</h5><p>因为采用的是右手坐标系，所以顺时针的旋转矩阵与普通坐标系逆时针的旋转矩阵是一样的。</p><p>{\begin{split}\begin{pmatrix} \cos\alpha & -\sin\alpha \\ \sin\alpha & \cos\alpha \end{pmatrix}\end{split}}</p><h5 id="顺时针的旋转变换"><a class="markdownIt-Anchor" href="#顺时针的旋转变换"></a> 顺时针的旋转变换</h5><p>通过旋转变换，可以通过目标框中心点，求得旋转后目标框的任意点坐标的公式，在代码中实现。</p><p>\begin{split}P_A= \begin{pmatrix} x_A \\ y_A\end{pmatrix} = \begin{pmatrix} x_{center} \\ y_{center}\end{pmatrix} + \begin{pmatrix}\cos\alpha & -\sin\alpha \\ \sin\alpha & \cos\alpha\end{pmatrix} \begin{pmatrix} -0.5w \\ -0.5h\end{pmatrix} \\ = \begin{pmatrix} x_{center}-0.5w\cos\alpha+0.5h\sin\alpha \\ y_{center}-0.5w\sin\alpha-0.5h\cos\alpha\end{pmatrix}\end{split}</p><h4 id="逆时针ccw"><a class="markdownIt-Anchor" href="#逆时针ccw"></a> 逆时针(CCW)</h4><p>顺时针负角度，逆时针负角度。(上正下负)</p><pre class="language-none"><code class="language-none">0-------------------&gt; x (0 rad)|  A-------------B|  |             ||  |     box     h|  |   angle&#x3D;0   ||  D------w------Cvy (-pi&#x2F;2 rad)</code></pre><h5 id="逆时针的旋转矩阵"><a class="markdownIt-Anchor" href="#逆时针的旋转矩阵"></a> 逆时针的旋转矩阵</h5><p>\begin{split}\begin{pmatrix} \cos\alpha & \sin\alpha \\ -\sin\alpha & \cos\alpha \end{pmatrix}\end{split}</p><h5 id="逆时针的旋转变换"><a class="markdownIt-Anchor" href="#逆时针的旋转变换"></a> 逆时针的旋转变换</h5><p>{\begin{split}P_A= \begin{pmatrix} x_A \\ y_A\end{pmatrix} = \begin{pmatrix} x_{center} \\ y_{center}\end{pmatrix} + \begin{pmatrix}\cos\alpha & \sin\alpha \\ -\sin\alpha & \cos\alpha\end{pmatrix} \begin{pmatrix} -0.5w \\ -0.5h\end{pmatrix} \\ = \begin{pmatrix} x_{center}-0.5w\cos\alpha-0.5h\sin\alpha \\ y_{center}+0.5w\sin\alpha-0.5h\cos\alpha\end{pmatrix}\end{split}}</p><blockquote><p>在MMRotate中，旋转框的旋转方向默认为顺时针(CW)方向</p></blockquote><h3 id="旋转框定义"><a class="markdownIt-Anchor" href="#旋转框定义"></a> 旋转框定义</h3><h4 id="opencv定义法"><a class="markdownIt-Anchor" href="#opencv定义法"></a> OpenCV定义法</h4><h5 id="opencv旧版本定义451"><a class="markdownIt-Anchor" href="#opencv旧版本定义451"></a> OpenCV旧版本定义(&lt;4.5.1)</h5><p>OpenCV在版本4.5.1之前，表示形式为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mrow><mi>o</mi><mi>c</mi></mrow></msub><mo separator="true">,</mo><msub><mi>y</mi><mrow><mi>o</mi><mi>c</mi></mrow></msub><mo separator="true">,</mo><msub><mi>w</mi><mrow><mi>o</mi><mi>c</mi></mrow></msub><mo separator="true">,</mo><msub><mi>h</mi><mrow><mi>o</mi><mi>c</mi></mrow></msub><mo separator="true">,</mo><msub><mi>θ</mi><mrow><mi>o</mi><mi>c</mi></mrow></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>θ</mi><mrow><mi>o</mi><mi>c</mi></mrow></msub><mo>∈</mo><mo stretchy="false">[</mo><mo>−</mo><mi>π</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{(x_{oc},y_{oc},w_{oc},h_{oc},{\theta}_{oc}),{\theta}_{oc}∈[-\pi/2,0)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mord">/</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span></p><p>角度的由宽W与x轴所成的<strong>负的锐角或者直角</strong>。</p><h5 id="opencv新版本定义451"><a class="markdownIt-Anchor" href="#opencv新版本定义451"></a> OpenCV新版本定义(&gt;=4.5.1)</h5><p>OpenCV在版本4.5.1之后修改了角度定义范围，表示形式为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mrow><mi>o</mi><mi>c</mi></mrow></msub><mo separator="true">,</mo><msub><mi>y</mi><mrow><mi>o</mi><mi>c</mi></mrow></msub><mo separator="true">,</mo><msub><mi>w</mi><mrow><mi>o</mi><mi>c</mi></mrow></msub><mo separator="true">,</mo><msub><mi>h</mi><mrow><mi>o</mi><mi>c</mi></mrow></msub><mo separator="true">,</mo><msub><mi>θ</mi><mrow><mi>o</mi><mi>c</mi></mrow></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>θ</mi><mrow><mi>o</mi><mi>c</mi></mrow></msub><mo>∈</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>π</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">{(x_{oc},y_{oc},w_{oc},h_{oc},{\theta}_{oc}),{\theta}_{oc}∈(0,\pi/2]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">]</span></span></span></span></span></p><p>角度的由宽W与x轴所成的<strong>正的锐角或者直角</strong>。</p><p>新旧版本的转换关系如下图所示:</p><p><img src="/img/article/2022/05/23/2.jpg" alt="" /></p><blockquote><p>在MMRotate中，旋转框的定义方式采用OpenCV新版本定义法</p></blockquote><h2 id="mmrotate框架结构"><a class="markdownIt-Anchor" href="#mmrotate框架结构"></a> MMRotate框架结构</h2><p>MMRotate主要包括四个部分, <code>datasets</code>, <code>models</code>, <code>core</code> and <code>apis</code>。</p><ul><li><code>datasets</code> 用于数据加载和数据增强。</li><li><code>models</code> 主要包括各类模型和损失函数。</li><li><code>core</code> 为模型训练和评估提供工具。</li><li><code>apis</code> 为模型训练、测试和推理提供的API接口。</li></ul><p><img src="/img/article/2022/05/23/3.jpg" alt="" /></p><p>关于Dataset，目前已完成DOTA_v1.5、HRSC2016、SSDD的预处理，还剩下HRSID和DOTA_V1.0</p><p>关于Model, 目前在尝试跑Rotated-RetinaNet模型，使用HRSC2016，目前还在调整代码，目前没有遇到问题</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
      <tag>旋转目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022-05-09-组会</title>
    <link href="/2022/05/08/Seminar/20220509-%E7%BB%84%E4%BC%9A/"/>
    <url>/2022/05/08/Seminar/20220509-%E7%BB%84%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="2022-05-09-组会"><a class="markdownIt-Anchor" href="#2022-05-09-组会"></a> 2022-05-09-组会</h1><h2 id="1redet"><a class="markdownIt-Anchor" href="#1redet"></a> 1.ReDet</h2><p>由于显示结果的代码实在调不通，所以先搁置。</p><h2 id="2-论文阅读"><a class="markdownIt-Anchor" href="#2-论文阅读"></a> 2. 论文阅读</h2><p>看了一篇论文Rotated Faster RCNN</p><p>感觉</p><h2 id="3-mmrotate框架"><a class="markdownIt-Anchor" href="#3-mmrotate框架"></a> 3. MMRotate框架</h2><p>前些天刷知乎，发现了一个4月份刚刚开源的旋转框检测框架。 基于Pytorch</p><p>MMRotate提供了目前旋转框检测任务最先进的算法模型，包括ReDet、 Oriented R-CNN等.</p><p>目前刚安装配置好环境，还没有实质性的进展。</p><p>后续打算边看文档学习该框架的使用，边写文章记录一些使用心得。</p>]]></content>
    
    
    <categories>
      
      <category>组会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旋转目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022-04-25-组会</title>
    <link href="/2022/04/24/Seminar/20220425-%E7%BB%84%E4%BC%9A/"/>
    <url>/2022/04/24/Seminar/20220425-%E7%BB%84%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="2022-04-25-组会"><a class="markdownIt-Anchor" href="#2022-04-25-组会"></a> 2022-04-25-组会</h1><h2 id="1redet"><a class="markdownIt-Anchor" href="#1redet"></a> 1.ReDet</h2><p>再细读了一遍ReDet，并回顾了ROI transformer，理解它的第二个创新点的实现过程。</p><p><a href="/2022/03/27/AI-Learning/20220328-ReDet" target="_blank">ReDet解读</a></p><h2 id="2代码"><a class="markdownIt-Anchor" href="#2代码"></a> 2.代码</h2><p>尝试了去修改文件格式，修改部分代码，修改路径,</p><p>仍然配置不成功，最好的结果是提示文件名过长</p><p><img src="/img/article/2022/04/25/1.png" alt="" /></p><p>注释中说</p><blockquote><p>detpath 是 result文件的路径</p><p>annopath 是 .xml文件的路径</p><p>imagesetfile 是图片文件路径</p></blockquote><p>但是按注释中配置还是会配置失败</p><p>我认为归根结底的原因还是因为作者没有给出配置样例，导致某个路径我设置错了，但我发现不了。</p><h2 id="3接下来的工作"><a class="markdownIt-Anchor" href="#3接下来的工作"></a> 3.接下来的工作</h2><p>我打算去看一些ReDet论文中提到的一些关键文章，如OBB,HBB,HTC 等，去补充一些旋转目标检测的基础理论。</p>]]></content>
    
    
    <categories>
      
      <category>组会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旋转目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022-04-18-组会</title>
    <link href="/2022/04/17/Seminar/20220418-%E7%BB%84%E4%BC%9A/"/>
    <url>/2022/04/17/Seminar/20220418-%E7%BB%84%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="2022-04-18-组会"><a class="markdownIt-Anchor" href="#2022-04-18-组会"></a> 2022-04-18-组会</h1><p>这两周毕业设计要提交很多材料，花费了很多时间来处理。</p><p>最近两天才有时间继续这边的实验研究。</p><h2 id="1邮箱"><a class="markdownIt-Anchor" href="#1邮箱"></a> 1.邮箱</h2><p>在4月2号晚上，我已经给ReDet的作者发送了电子邮件，询问评估Result的python文件中的路径该怎么配置。但是目前还没有收到回复。</p><h2 id="2reresnet"><a class="markdownIt-Anchor" href="#2reresnet"></a> 2.ReResNet</h2><p>也就是ReDet的backbone，作者在论文中基本没有提到这个backbone的具体实现。<br />我对比了ResNet和ReResNet的代码，查阅到了一些有用的资料，了解了其不同之处。</p><p>具体详情见<a href="/2022/03/27/AI-Learning/20220328-ReDet" target="_blank">ReDet解读</a></p>]]></content>
    
    
    <categories>
      
      <category>组会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旋转目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ReDet</title>
    <link href="/2022/03/27/AI-Learning/20220328-ReDet/"/>
    <url>/2022/03/27/AI-Learning/20220328-ReDet/</url>
    
    <content type="html"><![CDATA[<h1 id="redet"><a class="markdownIt-Anchor" href="#redet"></a> ReDet</h1><h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2><p><strong>论文题目</strong> : ReDet: A Rotation-equivariant Detector for Aerial Object Detection</p><p><strong>论文地址</strong> : <a href="https://arxiv.org/pdf/1708.02002.pdf">https://arxiv.org/pdf/1708.02002.pdf</a></p><h2 id="idea"><a class="markdownIt-Anchor" href="#idea"></a> Idea</h2><p>提出了一种旋转等变检测器(ReDet)来从旋转等变特征中提取完全旋转不变的特征。</p><p><img src="/img/article/2022/03/27/1.png" alt="" /></p><p>如图，作者首先说明了普通CNN层对平移的不变性，但对旋转不具备不变性和等变性。作者采用了新的backbone【Reresnet，旋转不变主干网络，使用e2cnn重写Resnet】，能输出具有旋转等变性的特征图。同时特征图经过align后就不再具备旋转不变性了，所以作者也设计了一个特殊的align方法【RiRoI Align,除了普通RRoI Align具有的空间对齐(spatial alignment)，还多了一层方向对齐(orientation alignment)】,使得生成的特征图具备旋转不变性用以检测分类。</p><p>最后，旋转不变主干网络和RiRoI Align的结合形成了ReDet，以提取完全旋转不变的特征，从而实现精确的航空目标检测。</p><h2 id="network"><a class="markdownIt-Anchor" href="#network"></a> Network</h2><p><img src="/img/article/2022/03/27/2.png" alt="" /></p><p>Backbone: ResNet + FPN</p><p>改进–&gt; 添加了旋转等变</p><p>Rotation-equivariant Backbone:  ReResNet + ReFPN</p><p>紧接着采用RPN + RoI Transformer去生成RRoIs，然后再喂入到RiRoI Align 生成RoI feature， 最后再使用全连接层，然后到classification和bbox regression。</p><p>方向对齐: 循环切换方向通道并插值特征，以生成完全旋转不变的特征。</p><h2 id="detail"><a class="markdownIt-Anchor" href="#detail"></a> Detail</h2><h3 id="1backbonereresnet"><a class="markdownIt-Anchor" href="#1backbonereresnet"></a> 1.backbone【ReResNet】</h3><p>作者使用e2cnn，重写了mmdetction框架中的ResNet，形成了新的ReResNet，使其能输出具有旋转等变性的特征图。</p><p><img src="/img/article/2022/03/27/3.png" alt="" /></p><p>如图所示，在整体代码结构上，ReResNet相较于ResNet几乎没有变化。</p><p>作者在这里的主要工作，是使用开源的e2cnn库，重写了所有层(包括convolution, pooling, normalization, non-linearity等)，然后在代码中使用了这些层的地方全部做了替换。</p><p><img src="/img/article/2022/03/27/4.png" alt="" /></p><h3 id="2neckrefpn"><a class="markdownIt-Anchor" href="#2neckrefpn"></a> 2.neck【ReFPN】</h3><p>几乎与ReResNet如法炮制，同样使用e2cnn重写所有层。</p><p>但在ReFPN中多出了一个ConvModule，其e2cnn的部分都在这边引用，具体细节还在对比。</p><p><strong>e2cnn</strong></p><p>e2cnn全称:E(2)群等变可操控神经网络，于2019年提出，基于群等变卷积网络GroupEquivariant-CNN，给出了群表示如何改变特征图的概述，论述了群表示与非线性的兼容性。</p><p>论文地址：<a href="https://arxiv.org/pdf/1911.08251">https://arxiv.org/pdf/1911.08251</a></p><p>该作者给出了e2cnn的实现库，发布在github上：<a href="https://github.com/QUVA-Lab/e2cnn">https://github.com/QUVA-Lab/e2cnn</a></p><p>论文解读：<a href="https://blog.csdn.net/bxdzyhx/article/details/110521748">https://blog.csdn.net/bxdzyhx/article/details/110521748</a></p><p>这一部分论文偏理论，太过硬核，没看懂，需要抽象代数学得很好。。。<br />不过知道这个trick对旋转框很有用就行了。</p><h3 id="3roi-transformer"><a class="markdownIt-Anchor" href="#3roi-transformer"></a> 3.RoI transformer</h3><p><img src="/img/article/2022/03/27/9.png" alt="" /><br />原本的RT分为两部分，RRoI learner和RRoI warping。learner用来捕捉对旋转鲁棒的特征，warping相当于align部分。在本文中被拆开来用了。下图是RT的结构图：<br /><img src="/img/article/2022/03/27/5.png" alt="" /></p><h4 id="rroi-learner"><a class="markdownIt-Anchor" href="#rroi-learner"></a> RRoI learner</h4><p>在learner中，把RPN输出的HRoI当作输入，一次卷积后缩小至10channels，进入全连接层，输出一个5维向量(x,y,w,h,θ)，每个维度的GT(Groud Turth)值如下：<br /><img src="/img/article/2022/03/27/6.png" alt="" /><br />这里的五个值是RRoI GT和HRoI的偏移量，用这些偏移量作为输入进入decoder模块，解码出RRoI的相关参数，即(x,y,w,h,θ)。<br />这样可以使得最终的RRoI尽可能靠近gt值，这样即减少了参数量也提高了旋转框检测的性能。</p><h4 id="rroi-warpingrotation-invariant-roi-align"><a class="markdownIt-Anchor" href="#rroi-warpingrotation-invariant-roi-align"></a> RRoI warping(Rotation-invariant RoI Align)</h4><p>作者认为RoI warping已经可以捕捉旋转特征，但还无法使得生成的特征图具备旋转不变性，因此在RoI warping基础上添加了一个orientation alignment。同时为了保留位置信息，重新设计了特征图。</p><p><img src="/img/article/2022/03/27/7.png" alt="" /></p><p>本文的特征图维度为(k,n,h,w)，k是位置信息，n是方向channel数。</p><p>在orientation alignment中，特征图被分为n个方向的子特征图(一个channel一个方向)，根据对应的RoI的θ值,去进行该特征图的方向对齐，作者称这个过程叫switch channels。其过程如下：</p><p><img src="/img/article/2022/03/27/8.png" alt="" /></p><p>根据θ值计算一个下标r=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">⌊</mo><mfrac><mrow><mi>θ</mi><mo>∗</mo><mi>N</mi></mrow><mrow><mn>2</mn><mi>π</mi></mrow></mfrac><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor \frac{\theta*N}{2\pi}\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span><span class="mbin mtight">∗</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span>，r&lt;=1说明在N个方向内，r&gt;1说明在N个方向外。</p><p>如果θ值属于我们事先设定的N个方向中，则将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mi>N</mi><mrow><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">C_N^{(r)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.338331em;vertical-align:-0.29353099999999993em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4064690000000004em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29353099999999993em;"><span></span></span></span></span></span></span></span></span></span>这个特征图与其他前一个orientation channel特征图循环交换，直到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mi>N</mi><mrow><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">C_N^{(r)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.338331em;vertical-align:-0.29353099999999993em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4064690000000004em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29353099999999993em;"><span></span></span></span></span></span></span></span></span></span>在第一位；如果θ值不属于N个方向，也就是说r需要向下取整，此时先交换至第一个特征图再通过线性插值的方法计算出该特征图的值。</p><p>【switch channels具体过程是这个样子，但是其原理没有弄懂，按文章中说应该是和e2cnn有很大关系】</p><blockquote><p>虽然目标检测方向的论文大体上都看过，了解一些目标检测Network架构，但感觉自己在遥感目标检测的一些专业术语知识还是太少了。</p><p>比如OBB, HBB,rotation-invariant features, RRoI Pooling ,RRoI Align，这篇文章还提到了 group convolutions（群卷积）也没接触过。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
      <tag>旋转目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RetinaNet</title>
    <link href="/2022/01/16/AI-Learning/20220117-RetinaNet/"/>
    <url>/2022/01/16/AI-Learning/20220117-RetinaNet/</url>
    
    <content type="html"><![CDATA[<h1 id="retinanet"><a class="markdownIt-Anchor" href="#retinanet"></a> RetinaNet</h1><h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2><p><strong>论文题目</strong> : ReDet:A Rotation-equivariant Detector for Aerial Object Detection</p><p><strong>论文地址</strong> : <a href="https://arxiv.org/pdf/1708.02002.pdf">https://arxiv.org/pdf/1708.02002.pdf</a></p><p>Focal Loss用于解决类别不均衡问题，从而创造了RetinaNet（One Stage目标检测算法）这个精度超越经典Two Stage的Faster-RCNN的目标检测网络。</p><h2 id="idea"><a class="markdownIt-Anchor" href="#idea"></a> Idea</h2><p><img src="/img/article/2022/01/17/1.png" alt="" /></p><p>基于深度学习的目标检测算法有两类经典的结构：Two Stage 和 One Stage。</p><p><strong>Two Stage(1-2k)</strong>：例如Faster-RCNN算法。第一阶段专注于proposal的提取，第二阶段对提取出的proposal进行分类和精确坐标回归。两级结构准确度较高，但因为第二级需要单独对每个proposal进行分类/回归，速度上就打了折扣。</p><p><strong>One Stage(~100k)</strong>:  例如SSD，YOLO算法。此类算法摒弃了提取proposal的过程，只用一级就完成了识别/回归，虽然速度较快但准确率远远比不上两级结构。</p><p><strong>产生精度差异的主要原因：类别失衡（Class Imbalance）</strong>。One Stage方法在得到特征图后，会产生密集的目标候选区域，而这些大量的候选区域中只有很少一部分是真正的目标，这样就造成了机器学习中经典的训练样本正负不平衡的问题。它往往会造成最终算出的training loss为占绝对多数但包含信息量却很少的负样本所支配，少样正样本提供的关键信息却不能在一般所用的training loss中发挥正常作用，从而无法得出一个能对模型训练提供正确指导的loss（而Two Stage方法得到proposal后，其候选区域要远远小于One Stage产生的候选区域，因此不会产生严重的类别失衡问题）。该论文中提出了Focal Loss来降低类别失衡，对最终的Loss进行校正。</p><h2 id="network"><a class="markdownIt-Anchor" href="#network"></a> Network</h2><p><img src="/img/article/2022/01/17/2.png" alt="" /></p><p>RetinaNet的网络结构: ResNet + FPN +  FCN*2</p><p>输入图像经过Backbone的特征提取后，可以得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">{P_3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>~<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>7</mn></msub></mrow><annotation encoding="application/x-tex">{P_7}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>特征金字塔，对每层特征金字塔分别使用两个子网络（分类网络+检测框位置回归）。</p><p>子网络的设计类似于RPN，使用anchors来产生proposal。</p><p><strong>上面说到的Focal Loss就应用于类别分类的子网络</strong>，即可有效移植类别不均衡问题。</p><p>特征金字塔每层都相应的产生目标类别与位置的预测，最后再将其融合起来，同时使用NMS来得到最后的检测结果。</p><h3 id="focal-loss"><a class="markdownIt-Anchor" href="#focal-loss"></a> Focal Loss</h3><p>Focal Loss这个trick主要是在交叉熵损失函数做改进。</p><p>对于一般的二分类问题，其交叉熵损失函数如下:</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>E</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo><mi>y</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><mi>y</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>−</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>y</mi><mo stretchy="false">)</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{CE(p,y) = L(y,p) = -ylog(p) - (1-y)log(1-p)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span></span></p><p>可以写成:</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>E</mi><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mrow></mrow></msub><mrow><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> if </mtext><mi>y</mi><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mrow></mrow></msub><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> if </mtext><mi>y</mi><mo>=</mo><mo>−</mo><mn>1</mn><mo stretchy="false">(</mo><mi>o</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>w</mi><mi>i</mi><mi>s</mi><mi>e</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">CE= \begin{cases}  -\log_{}{(p)} &amp; \text{ if } y=1   \\  -\log_{}{(1-p)} &amp; \text{ if } y=-1(otherwise)\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.24414em;"><span style="top:-1.75586em;margin-right:0.05em;"><span class="pstrut" style="height:2em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.24414em;"><span style="top:-1.75586em;margin-right:0.05em;"><span class="pstrut" style="height:2em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord"> if </span></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord"> if </span></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>为了方便，定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">{p_t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>，如下:</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>t</mi></msub><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>p</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> if </mtext><mi>y</mi><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo>−</mo><mi>p</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> if </mtext><mi>y</mi><mo>=</mo><mo>−</mo><mn>1</mn><mo stretchy="false">(</mo><mi>o</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>w</mi><mi>i</mi><mi>s</mi><mi>e</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">p_t= \begin{cases}  p &amp; \text{ if } y=1   \\  1-p &amp; \text{ if } y=-1(otherwise)\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">p</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord"> if </span></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord"> if </span></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>这样CE就可以表示成如下表达式:</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>E</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>C</mi><mi>E</mi><mo stretchy="false">(</mo><msub><mi>p</mi><mi>t</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><mi>log</mi><mo>⁡</mo><mrow></mrow><msub><mi>p</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">CE(p,y) = CE(p_t) = -\log{}{p_t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"></span><span class="mord"><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>pt可以看作样本被正确分类的一个概率值。</p><p>可以认为当模型预测得到的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>t</mi></msub><mo>&gt;</mo><mn>0.5</mn></mrow><annotation encoding="application/x-tex">P_t &gt; 0.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span></span></span></span>的样本为easy examples ; 而<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">P_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>值预测较小的样本为hard examples。</p><h4 id="postivenegative-example"><a class="markdownIt-Anchor" href="#postivenegative-example"></a> Postive/Negative example</h4><p>解决class imbalance的一个方法是为类1添加一个权重因子α ∈ [0, 1]，对于y =1的使用权重 α ，对y =-1使用 1-α；这样就能一定程度上的解决了正负样本的不平衡。</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>E</mi><mo>=</mo><mo>−</mo><mi>α</mi><msub><mo><mi>log</mi><mo>⁡</mo></mo><mrow></mrow></msub><msub><mi>p</mi><mi>t</mi></msub><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>α</mi><msub><mo><mi>log</mi><mo>⁡</mo></mo><mrow></mrow></msub><mrow><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> if </mtext><mi>y</mi><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="false">)</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mrow></mrow></msub><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> if </mtext><mi>y</mi><mo>=</mo><mo>−</mo><mn>1</mn><mo stretchy="false">(</mo><mi>o</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>w</mi><mi>i</mi><mi>s</mi><mi>e</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">CE= -\alpha \log_{}{p_t}= \begin{cases}  -\alpha \log_{}{(p)} &amp; \text{ if } y=1   \\  -(1-\alpha)\log_{}{(1-p)} &amp; \text{ if } y=-1(otherwise)\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.24414em;"><span style="top:-1.75586em;margin-right:0.05em;"><span class="pstrut" style="height:2em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.24414em;"><span style="top:-1.75586em;margin-right:0.05em;"><span class="pstrut" style="height:2em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">−</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.24414em;"><span style="top:-1.75586em;margin-right:0.05em;"><span class="pstrut" style="height:2em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord"> if </span></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord"> if </span></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><h4 id="easyhard-example"><a class="markdownIt-Anchor" href="#easyhard-example"></a> Easy/Hard example</h4><p>因为hard examples通常为少数样本，所以虽然其对应的loss值较高，但是最后全部累加后，大部分的loss值来自于容易分类的样本，这样在模型优化的过程中就会将更多的优化放到容易分类的样本中，而忽略hard examples。因此论文中引入调节因子<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msub><mi>p</mi><mi>t</mi></msub><msup><mo stretchy="false">)</mo><mi>γ</mi></msup></mrow><annotation encoding="application/x-tex">(1-p_t)^{\gamma}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05556em;">γ</span></span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>E</mi><mo>=</mo><mo>−</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msub><mi>p</mi><mi>t</mi></msub><msup><mo stretchy="false">)</mo><mi>γ</mi></msup><msub><mo><mi>log</mi><mo>⁡</mo></mo><mrow></mrow></msub><msub><mi>p</mi><mi>t</mi></msub><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><msup><mo stretchy="false">)</mo><mi>γ</mi></msup><msub><mo><mi>log</mi><mo>⁡</mo></mo><mrow></mrow></msub><mrow><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> if </mtext><mi>y</mi><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><msup><mi>p</mi><mi>γ</mi></msup><msub><mo><mi>log</mi><mo>⁡</mo></mo><mrow></mrow></msub><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> if </mtext><mi>y</mi><mo>=</mo><mo>−</mo><mn>1</mn><mo stretchy="false">(</mo><mi>o</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>w</mi><mi>i</mi><mi>s</mi><mi>e</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">CE= -(1-p_t)^{\gamma} \log_{}{p_t}= \begin{cases}  -(1-p)^{\gamma} \log_{}{(p)} &amp; \text{ if } y=1   \\  -p^{\gamma}\log_{}{(1-p)} &amp; \text{ if } y=-1(otherwise)\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05556em;">γ</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.24414em;"><span style="top:-1.75586em;margin-right:0.05em;"><span class="pstrut" style="height:2em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">−</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">p</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05556em;">γ</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.24414em;"><span style="top:-1.75586em;margin-right:0.05em;"><span class="pstrut" style="height:2em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">−</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05556em;">γ</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.24414em;"><span style="top:-1.75586em;margin-right:0.05em;"><span class="pstrut" style="height:2em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord"> if </span></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord"> if </span></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">P_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>较大时为Easy example，此时调制因子接近0, 降低了Loss累加中Easy example的权重;</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">P_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>较小时为Hard example，此时调制因子接近1, 增加了Loss累加中Easy example的权重。</p><p>通过实验测试，超参数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>γ</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\gamma = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>效果最好。</p><p><img src="/img/article/2022/01/17/3.png" alt="" /></p><hr /><p>将上述两种权重因子整合起来，就是最终的Focal Loss:</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>E</mi><mo>=</mo><mo>−</mo><mi>α</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msub><mi>p</mi><mi>t</mi></msub><msup><mo stretchy="false">)</mo><mi>γ</mi></msup><msub><mo><mi>log</mi><mo>⁡</mo></mo><mrow></mrow></msub><msub><mi>p</mi><mi>t</mi></msub><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>α</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><msup><mo stretchy="false">)</mo><mi>γ</mi></msup><msub><mo><mi>log</mi><mo>⁡</mo></mo><mrow></mrow></msub><mrow><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> if </mtext><mi>y</mi><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="false">)</mo><msup><mi>p</mi><mi>γ</mi></msup><msub><mo><mi>log</mi><mo>⁡</mo></mo><mrow></mrow></msub><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> if </mtext><mi>y</mi><mo>=</mo><mo>−</mo><mn>1</mn><mo stretchy="false">(</mo><mi>o</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>w</mi><mi>i</mi><mi>s</mi><mi>e</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">CE= -\alpha(1-p_t)^{\gamma} \log_{}{p_t}= \begin{cases}  -\alpha(1-p)^{\gamma} \log_{}{(p)} &amp; \text{ if } y=1   \\  -(1-\alpha)p^{\gamma}\log_{}{(1-p)} &amp; \text{ if } y=-1(otherwise)\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05556em;">γ</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.24414em;"><span style="top:-1.75586em;margin-right:0.05em;"><span class="pstrut" style="height:2em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">p</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05556em;">γ</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.24414em;"><span style="top:-1.75586em;margin-right:0.05em;"><span class="pstrut" style="height:2em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">−</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05556em;">γ</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.24414em;"><span style="top:-1.75586em;margin-right:0.05em;"><span class="pstrut" style="height:2em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord"> if </span></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord"> if </span></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>下图是论文中给出的试验结果，相比较于经典的Two Stage检测方法Faster-RCNN，RetinaNet具有更高的精度。</p><p><img src="/img/article/2022/01/17/4.png" alt="" /></p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
      <tag>旋转目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROI Transformer</title>
    <link href="/2021/12/12/AI-Learning/20211212-ROI%20Transformer/"/>
    <url>/2021/12/12/AI-Learning/20211212-ROI%20Transformer/</url>
    
    <content type="html"><![CDATA[<h1 id="roi-transformer"><a class="markdownIt-Anchor" href="#roi-transformer"></a> ROI Transformer</h1><h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2><ul><li><strong>论文题目</strong> : Learning RoI Transformer for Oriented Object Detection in Aerial Images</li><li><strong>论文作者</strong> : Jian Ding, Nan Xue, Yang Long, Gui-Song Xia∗ , Qikai Lu – LIESMARS-CAPTAIN, Wuhan University</li><li><strong>论文地址</strong> : <a href="https://openaccess.thecvf.com/content_CVPR_2019/html/Ding_Learning_RoI_Transformer_for_Oriented_Object_Detection_in_Aerial_Images_CVPR_2019_paper">CVPR_2019-ROI Transformer</a></li><li><strong>代码实现</strong> : <a href="https://github.com/dingjiansw101/AerialDetection">https://github.com/dingjiansw101/AerialDetection</a></li></ul><p>鸟瞰视角、高度复杂的背景、目标外形的剧烈变化使得航拍图像目标检测成为难题。尤其当航拍图像中目标密集存在时，常规目标检测中的水平proposals（HRoIs）与目标之间的不匹配将进一步影响分类和定位。本文中作者提出了[<strong>RoI Transformer</strong>]方法来解决这一问题，基于两阶段框架，通过基于位置敏感对齐的监督RRoI学习和特征提取，实现定向和密集对象的检测。</p><p><img src="/img/article/2021/12/12/1.png" alt="" /></p><p>水平RoI通常包含多个实例，而旋转RoI通常更加精确。</p><p>RoI Transformer是轻量级的且可以很容易的嵌入各种旋转目标检测器中。</p><h2 id="idea"><a class="markdownIt-Anchor" href="#idea"></a> Idea</h2><p>本文中作者提出的ROI Transformer 由两部分组成:</p><ul><li><p><strong>第一部分是RRoI Learner，它学习从HRoIs到RRoIs的转换；</strong></p></li><li><p><strong>第二部分是RRoI Warping，它从RRoI中提取旋转不变的特征，用于后续的分类和回归子任务</strong>。</p></li><li><p>HRoIs(horizontal RoIs):水平候选框</p></li><li><p>RRoIs(Rotated RoIs):   旋转候选框</p></li><li><p>RGTs(Rotated Ground Truths): 预先标注的旋转真实框</p></li></ul><h2 id="details"><a class="markdownIt-Anchor" href="#details"></a> Details</h2><h3 id="rroi-learner"><a class="markdownIt-Anchor" href="#rroi-learner"></a> RRoI Learner</h3><p><img src="/img/article/2021/12/12/2.png" alt="" /></p><p>PS RoI Align(Position Sensitive RoI Alignment) [位置敏感的候选区域]</p><blockquote><p>这个概念涉及到一篇以前的论文R-FCN，其主要思想是在特征聚集时 <strong>人工引入位置信息</strong> ，从而有效改善较深的神经网络对物体位置信息的敏感程度</p><p>PS-ROI Align 对模型的检测性能有提升，对小物体的感知能力有明显改善</p></blockquote><p>这个网络将HRoIs 作为输入传给RRoI Learner，</p><p>FC-5: 后面跟着一个5维的全连接层，该全连接层用于回归RGTs相对于HRoIs的偏移量。</p><p>DeCoder: 解码器，将HRoIs和偏移量作为输入，输出RRoI</p><p>后续将Featrue map和RRoIs传递给RRoI Warping，用于几何鲁棒特征提取。</p><h3 id="rroi-warping"><a class="markdownIt-Anchor" href="#rroi-warping"></a> RRoI Warping</h3><p>RRoI Warping通过RRoI的参数提取旋转不变的深度特征（其实就是用Rotated Position Sensitive RoI pooling实现旋转版的池化）。</p><p><img src="/img/article/2021/12/12/4.png" alt="" /></p><p>因为采用Light-Head R-CNN，这里RRoI Warping具体使用Rotated Position Sensitive (RPS) RoI Align。</p><p><img src="/img/article/2021/12/12/5.png" alt="" /></p><p>给定具有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mo>×</mo><mi>W</mi><mo>×</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">H × W × C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>通道的输入特征图  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">\mathcal{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span></span> 和 RRoI <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>r</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>r</mi></msub><mo separator="true">,</mo><msub><mi>w</mi><mi>r</mi></msub><mo separator="true">,</mo><msub><mi>h</mi><mi>r</mi></msub><mo separator="true">,</mo><msub><mi>θ</mi><mi>r</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_r,y_r,w_r,h_r,θ_r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>RPS RoI pooling 将旋转的 Rotated RoI 分成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mo>×</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">K × K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> bin，并输出形状为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mo>×</mo><mi>K</mi><mo>×</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">K × K × C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 的特征图 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">Y</mi></mrow><annotation encoding="application/x-tex">\mathcal{Y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78055em;vertical-align:-0.09722em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">Y</span></span></span></span></span>。</p><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">\mathcal{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span></span>是输入的feature map</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>θ</mi></msub></mrow><annotation encoding="application/x-tex">T_θ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是RRoIs</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">Y</mi></mrow><annotation encoding="application/x-tex">\mathcal{Y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78055em;vertical-align:-0.09722em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">Y</span></span></span></span></span>是输出的feature map</li><li>bin 是池化的一小块， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">n_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>是每一块bin的样本参数量</li></ul><p>对于每个bin的(x,y)，通过以下式子转换为(x’,y’):</p><p><img src="/img/article/2021/12/12/6.png" alt="" /></p><h3 id="iou的计算"><a class="markdownIt-Anchor" href="#iou的计算"></a> IOU的计算</h3><p><img src="/img/article/2021/12/12/7.jpg" alt="" /></p><p>计算RRoI 和匹配的 RGT 之间的 IoU，也是不规则多边形的IOU，作者在文章中没有提及计算方法。</p><p>对于长而窄的边界框，角度的轻微抖动可能导致两个盒子的 IoU 非常低，因此阈值取0.5.</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
      <tag>旋转目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>YOLOv2v3</title>
    <link href="/2021/11/27/AI-Learning/20211128-YOLOv2v3/"/>
    <url>/2021/11/27/AI-Learning/20211128-YOLOv2v3/</url>
    
    <content type="html"><![CDATA[<h1 id="yolo-v2v3"><a class="markdownIt-Anchor" href="#yolo-v2v3"></a> YOLO v2v3</h1><p>YOLOv1的缺陷:</p><ol><li><p>虽然速度快，但是准确度比较低</p></li><li><p>定位性能比较差，相对于FastRCNN来说，是就调整检测框的能力较差</p></li><li><p>ReCall比较低，(把全部目标检出的能力较差)YOLOv1把图像划分成7*7个Grid Cell，每个GridCell 预测两个BBox，最多有98个BBox，如果图像中目标很多，就很难把所有目标检测出来，所以ReCall比较低</p></li><li><p>7*7个Grid Cell 每个GridCell只能负责预测一个物体，所以最多检测出49个物体，因此检测小目标和密集目标也很差</p></li></ol><p>Better:</p><ul><li>Batch Normalization</li></ul><p>归一化 = (输出- 输出均值) / 标准差</p><ul><li>High Resolution Classifier (高分辨率的分类器)</li><li>Anchor</li><li>Dimension Cluster</li><li>Direct location prediction(直接定位)</li><li>Fine-Grained Features (细粒度特征)</li><li>Multi-Scale Training(多尺度训练)</li></ul>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
      <tag>旋转目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>YOLOv1</title>
    <link href="/2021/11/21/AI-Learning/20211121-YOLOv1/"/>
    <url>/2021/11/21/AI-Learning/20211121-YOLOv1/</url>
    
    <content type="html"><![CDATA[<h1 id="yolov1"><a class="markdownIt-Anchor" href="#yolov1"></a> YOLOv1</h1><h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2><ul><li><strong>论文题目</strong> : You Only Look Once: Unified, Real-Time Object Detection</li><li><strong>论文地址</strong> : <a href="https://arxiv.org/pdf/1506.02640.pdf">https://arxiv.org/pdf/1506.02640.pdf</a><br />YOLO将物体检测作为回归问题求解。基于一个单独的end-to-end网络，完成从原始图像的输入到物体位置和类别输出。</li></ul><h2 id="idea"><a class="markdownIt-Anchor" href="#idea"></a> Idea</h2><p>[1] YOLO训练和检测均是在一个单独网络中进行。YOLO没有显示地求取region proposal的过程。而rcnn/fast rcnn 采用分离的模块）求取候选框（可能会包含物体的矩形区域），训练过程因此也是分成多个模块进行。</p><p>[2]YOLO将物体检测作为一个回归问题进行求解，输入图像经过一次inference，便能得到图像中所有物体的位置和其所属类别及相应的置信概率。</p><h2 id="network"><a class="markdownIt-Anchor" href="#network"></a> NetWork</h2><p><img src="/img/article/2021/11/21/1.png" alt="" /></p><h3 id="predicting"><a class="markdownIt-Anchor" href="#predicting"></a> Predicting</h3><p><img src="/img/article/2021/11/21/13.png" alt="" /></p><p><img src="/img/article/2021/11/21/2.png" alt="" /></p><p><strong>PPT演示</strong> : <a href="https://docs.google.com/presentation/d/1aeRvtKG21KHdD5lg6Hgyhx5rPq_ZOsGjG5rJ1HP7BbA/pub?start=false&amp;loop=false&amp;delayms=3000&amp;slide=id.p">地址</a></p><p>把448x448x3的输入图像，进行编码、压缩、处理，经过卷积层，全连接层，最后得到一个7x7x30的张量。</p><p>7x7对应的是7x7个Grid Cell，30维由5(第一个BBox参数)、5(第一个BBox参数)、20(假设在该GridCell的条件下，对应的20个类别概率)构成。</p><p>全概率=条件本身发生的概率[置信度,Grid Cell在该BBox包含物体的概率]x条件概率[该条件下，20个类别概率]</p><p>使用NMS[非极大值抑制]把低置信度和重复的框过滤掉，只保留一个，最终获得目标检测的结果。</p><h3 id="training"><a class="markdownIt-Anchor" href="#training"></a> Training</h3><p>深度学习的训练是通过梯度下降和反向传播方法，去迭代更新神经元的权重，来使得Loss函数最小化的过程。</p><p><img src="/img/article/2021/11/21/10.png" alt="" /></p><p>人工标注数据Ground Truth，这个Ground Truth的中心点落在哪个Grid Cell里，就应该由哪个Grid Cell预测出的BBox负责拟合这个Ground Truth。</p><p><img src="/img/article/2021/11/21/11.png" alt="" /></p><p>之前也说到每个Grid Cell预测两个BBox，然后分别计算IOU，选择IOU较大的BBox来负责拟合该Ground Truth，让该BBox最终尽可能逼近Ground Truth。</p><p><img src="/img/article/2021/11/21/12.png" alt="" /></p><p>接下来看损失函数:</p><p><img src="/img/article/2021/11/21/14.png" alt="" /></p><p>遍历所有Grid Cell中的所有BBox，采用平方和误差。</p><ul><li>整体分为五个部分，负责检测的BBox的中心点误差、负责检测的BBox的宽高误差、负责检测的BBox的Confidence误差、不负责检测的BBox的Confidence误差、负责检测物体的Grid Cell的分类误差。</li><li>对于负责检测的BBox的宽高误差，采用求根号能使小框对误差更敏感</li><li>给予负责检测物体的BBox更高的权重：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>λ</mi><mrow><mi>c</mi><mi>o</mi><mi>o</mi><mi>r</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">{\lambda _{coord} }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>  ，给予不负责检测物体的BBox较低的权重：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>λ</mi><mrow><mi>n</mi><mi>o</mi><mi>o</mi><mi>b</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">{\lambda _{noobj}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></li></ul>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
      <tag>旋转目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>R-CNN系列目标检测模型</title>
    <link href="/2021/11/14/AI-Learning/20211114-R-CNN%E7%B3%BB%E5%88%97%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/"/>
    <url>/2021/11/14/AI-Learning/20211114-R-CNN%E7%B3%BB%E5%88%97%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="r-cnn-fast-r-cnn-faster-r-cnn"><a class="markdownIt-Anchor" href="#r-cnn-fast-r-cnn-faster-r-cnn"></a> R-CNN、Fast R-CNN、Faster R-CNN</h1><h2 id="1-r-cnn"><a class="markdownIt-Anchor" href="#1-r-cnn"></a> 1 R-CNN</h2><h3 id="11-introduction"><a class="markdownIt-Anchor" href="#11-introduction"></a> 1.1 Introduction</h3><ul><li><strong>论文题目</strong> : Rich feature hierarchies for accurate object detection and semantic segmentation</li><li><strong>论文地址</strong> : <a href="https://arxiv.org/abs/1311.2524v3">https://arxiv.org/abs/1311.2524v3</a></li></ul><p>R-CNN（Region CNN，区域卷积神经网络）可以说是利用深度学习进行目标检测的开山之作。</p><h3 id="12-idea"><a class="markdownIt-Anchor" href="#12-idea"></a> 1.2 Idea</h3><ul><li>经典的目标检测算法使用滑动窗法依次判断所有可能的区域。作者则(采用Selective Search方法)预先提取一系列较可能是物体的候选区域。</li><li>经典的目标检测算法在区域中提取人工设定的特征。作者则采用深度网络(CNN)进行特征提取。</li></ul><h3 id="13-network"><a class="markdownIt-Anchor" href="#13-network"></a> 1.3 Network</h3><p><img src="/img/article/2021/11/14/1.png" alt="R-CNN网络结构" /></p><p><strong>Step1</strong> :输入图像<br /><strong>Step2</strong> :每张图像生成1K~2K个候选区域<br /><strong>Step3</strong> :对每个候选区域，使用卷积网络(如VGG16)提取特征<br /><strong>Step4</strong> :将特征送入每一类的SVM分类器，判别是否属于该类; 使用回归器精细修正候选框位置</p><h3 id="14-detail"><a class="markdownIt-Anchor" href="#14-detail"></a> 1.4 Detail</h3><h4 id="region-proposal"><a class="markdownIt-Anchor" href="#region-proposal"></a> Region Proposal</h4><p>对应上述Step2</p><p>作者使用Selective Search（选择性搜索）生成候选区域，Selective Search的实现思路如下:</p><blockquote><p>（1）使用一种过分割手段，将图像分割成小区域</p><p>（2）查看现有小区域，合并可能性最高的两个区域，重复直到整张图像合并成一个区域位置。优先合并以下区域：</p><ul><li>颜色（颜色直方图）相近的</li><li>纹理（梯度直方图）相近的</li><li>合并后总面积小的</li><li>合并后，总面积在其BBOX中所占比例大的<br />在合并时须保证合并操作的尺度较为均匀，避免一个大区域陆续“吃掉”其它小区域，保证合并后形状规则。</li></ul><p>（3）输出所有曾经存在过的区域，即所谓候选区域</p></blockquote><p>具体算法可以看原论文<a href="https://ivi.fnwi.uva.nl/isis/publications/2013/UijlingsIJCV2013/UijlingsIJCV2013.pdf">《Selective Search for Object Recognition》</a></p><h4 id="feature-extraction"><a class="markdownIt-Anchor" href="#feature-extraction"></a> Feature Extraction</h4><p>对应上述Step3</p><p>使用深度网络提取特征之前，首先把候选区域归一化成同一尺寸227×227。</p><p>作者使用CNN网络进行训练，第一选择经典的Alexnet；第二选择VGG16。(经测试Alexnet精度为58.5%，VGG16精度为66%)</p><p>通过CNN网络训练完毕后，最后提取特征每个输入候选框图片都能得到一个4096维的特征向量。</p><h4 id="classification-and-regression"><a class="markdownIt-Anchor" href="#classification-and-regression"></a> Classification and Regression</h4><p>分类，作者使用的是SVM分类器</p><p>作者测试了IOU阈值各种方案数值0.1,0.2,0.3,0.4,0.5。最后通过训练发现，如果选择IOU阈值为0.3效果最好（选择为0精度下降了4个百分点，选择0.5精度下降了5个百分点）,即当重叠度小于0.3的时候，把它标注为负样本。</p><p>我们将为每个物体类训练一个SVM分类器。当我们用CNN提取2000个候选框，可以得到[2000x4096]这样的特征向量矩阵，然后我们只需要把这样的一个矩阵与svm权值矩阵4096xN点乘(N为分类类别数目，因为我们训练的N个SVM，每个SVM包含了4096个权值w)，就可以得到分类结果了。</p><p>边界回归，也就是Bounding-box regression。</p><p><img src="/img/article/2021/11/14/2.png" alt="" /></p><p><img src="/img/article/2021/11/14/3.png" alt="" /></p><p><img src="/img/article/2021/11/14/4.png" alt="" /></p><h2 id="2-fast-r-cnn"><a class="markdownIt-Anchor" href="#2-fast-r-cnn"></a> 2 Fast R-CNN</h2><h3 id="21-introduction"><a class="markdownIt-Anchor" href="#21-introduction"></a> 2.1 Introduction</h3><ul><li><strong>论文题目</strong> : Fast R-CNN</li><li><strong>论文地址</strong> : <a href="https://arxiv.org/abs/1504.08083">https://arxiv.org/abs/1504.08083</a></li></ul><p>继2014年的R-CNN推出之后，作者在2015年推出Fast R-CNN，其流程更为紧凑，大幅提升了目标检测的速度。Fast R-CNN和R-CNN相比，训练时间从84小时减少到9.5小时，测试时间从47秒减少到0.32秒，并且在PASCAL VOC 2007上测试的准确率相差无几，约在66%-67%之间。</p><h3 id="22-idea"><a class="markdownIt-Anchor" href="#22-idea"></a> 2.2 Idea</h3><p>与前作相比，Fast R-CNN解决了以下问题:</p><p>1、训练、测试时速度慢<br />R-CNN的一张图像内候选框之间存在大量重叠，提取特征操作冗余。而Fast R-CNN将整张图像归一化后直接送入深度网络，紧接着送入从这幅图像上提取出的候选区域。这些候选区域的前几层特征不需要再重复计算。<br />2、训练所需空间大<br />R-CNN中独立的SVM分类器和回归器需要大量特征作为训练样本。Fast R-CNN把类别判断和位置精调统一用深度网络实现，不再需要额外存储。</p><h3 id="23network"><a class="markdownIt-Anchor" href="#23network"></a> 2.3Network</h3><p><img src="/img/article/2021/11/14/5.png" alt="" /></p><p><strong>Step1</strong> :首先将整个图片输入到一个卷积网络，得到整张图的feature map，然后将region proposal（RoI）映射到feature map的对应位置。</p><p><strong>Step2</strong> :RoI pooling layer提取一个__固定长度__的特征向量，每个特征会输入到一系列全连接层，得到一个RoI特征向量</p><p><strong>Step3</strong> :建立softmax层进行分类，建立bounding box regressor回归边界，二者合并为多目标损失函数任务。</p><h3 id="24-detail"><a class="markdownIt-Anchor" href="#24-detail"></a> 2.4 Detail</h3><h4 id="feature-extraction-2"><a class="markdownIt-Anchor" href="#feature-extraction-2"></a> Feature Extraction</h4><p>对应上述Step2</p><p>在Fast R-CNN中，作者提出了一个叫做ROI Pooling的网络层，这个网络层可以把不同大小的输入[Region Proposal]映射到一个固定尺度的特征向量。</p><p><img src="/img/article/2021/11/14/6.png" alt="" /></p><p>在文章当中，作者使用H=W=7的超参数作为ROI Pooling输出的特征向量的固定尺度。即将一个<code>h*w</code>的region proposal分割成<code>H*W</code>大小的网格，作为最后一层卷积层，然后分别对每个网格的进行Max Pooling，将特征图上大小不一的region proposal转变为大小统一的<code>H*W</code>矩阵。</p><p><strong>意义</strong> :因为全连接层的输入要求尺寸大小一样，所以不能直接将不同大小的region proposal映射到feature map作为输出，需要做尺寸变换。这个时候在全连接层前加一层ROI Pooling可以解决该问题。</p><h4 id="classification-and-regression-2"><a class="markdownIt-Anchor" href="#classification-and-regression-2"></a> Classification and Regression</h4><p>对应上述Step3</p><p><img src="/img/article/2021/11/14/7.png" alt="" /></p><p>在R-CNN中，先生成候选框，然后再通过CNN提取特征，之后再用SVM分类，最后再做回归得到具体位置（bbox regression）。</p><p>而在Fast R-CNN中，作者把最后的bbox regression也放进了神经网络内部，与区域分类合并成为了一个multi-task模型。</p><p><strong>分类loss</strong>：使用一个N+1路的softmax代替原来的SVM分类器，其中的N是类别个数，1是背景，使用交叉熵损失<br /><strong>回归loss</strong>：一个4xN路输出的regressor，也就是说对于每个类别都会训练一个单独的regressor，使用平均绝对误差（MAE）损失</p><p><img src="/img/article/2021/11/14/8.png" alt="" /></p><h2 id="3-faster-r-cnn"><a class="markdownIt-Anchor" href="#3-faster-r-cnn"></a> 3 Faster R-CNN</h2><h3 id="31-introduction"><a class="markdownIt-Anchor" href="#31-introduction"></a> 3.1 Introduction</h3><ul><li><strong>论文题目</strong> : Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks</li><li><strong>论文地址</strong> : <a href="https://arxiv.org/abs/1506.01497">https://arxiv.org/abs/1506.01497</a></li></ul><h3 id="32-idea"><a class="markdownIt-Anchor" href="#32-idea"></a> 3.2 Idea</h3><p>与前作相比:</p><p>Faster R-CNN设计了提取候选区域的网络RPN，代替了费时的Selective Search（选择性搜索），已经将Feature Extraction、</p><p>region proposal、Classification、Bounding-Box regression(rect refine)都整合在了一个网络中，使得综合性能有较大提高</p><p><img src="/img/article/2021/11/14/11.png" alt="" /></p><h3 id="33-network"><a class="markdownIt-Anchor" href="#33-network"></a> 3.3 Network</h3><p><img src="/img/article/2021/11/14/9.png" alt="" /></p><p><strong>Step1</strong> :Conv layers。作为一种CNN网络目标检测方法，Faster RCNN首先使用一组基础的conv+relu+pooling层提取image的feature maps。该feature maps被共享用于后续RPN层和全连接层。</p><p><strong>Step2</strong> :Region Proposal Networks。RPN网络用于生成region proposals。该层通过softmax判断anchors属于positive或者negative，再利用bounding box regression修正anchors获得精确的proposals。</p><p><strong>Step3</strong> :RoI Pooling。该层收集输入的feature maps和proposals，综合这些信息后提取proposal feature maps，送入后续全连接层判定目标类别。</p><p><strong>Step4</strong> :Classification。利用proposal feature maps计算proposal的类别，同时再次bounding box regression获得检测框最终的精确位置。</p><h3 id="34-detail"><a class="markdownIt-Anchor" href="#34-detail"></a> 3.4 Detail</h3><h4 id="rpn"><a class="markdownIt-Anchor" href="#rpn"></a> RPN</h4><p><img src="/img/article/2021/11/14/12.jpg" alt="" /></p><p>上图展示了RPN网络的具体结构。可以看到RPN网络实际分为2条线:</p><p>上面一条通过softmax分类anchors获得positive和negative分类，</p><p>下面一条用于计算对于anchors的bounding box regression偏移量，以获得精确的proposal。</p><p>而最后的Proposal层则负责综合positive anchors和对应bounding box regression偏移量获取proposals，同时剔除太小和超出边界的proposals。其实整个网络到了Proposal Layer这里，就完成了相当于目标定位的功能。</p><blockquote><p>Todo :</p><ol><li>关于Selective Search、RPN、Bounding-Box regression的详细实现原理，还是要看看具体代码才能更清晰。</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
      <tag>旋转目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>旋转目标检测(一)-RRPN</title>
    <link href="/2021/10/30/AI-Learning/20211030-%E6%97%8B%E8%BD%AC%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B(%E4%B8%80)-RRPN/"/>
    <url>/2021/10/30/AI-Learning/20211030-%E6%97%8B%E8%BD%AC%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B(%E4%B8%80)-RRPN/</url>
    
    <content type="html"><![CDATA[<h1 id="旋转目标检测一-rrpn"><a class="markdownIt-Anchor" href="#旋转目标检测一-rrpn"></a> 旋转目标检测(一)-RRPN</h1><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><ul><li><strong>论文题目</strong> : Arbitrary-Oriented Scene Text Detection via Rotation Proposals</li><li><strong>论文地址</strong> : <a href="https://arxiv.org/abs/1703.01086">https://arxiv.org/abs/1703.01086</a></li><li><strong>代码实现</strong> : <a href="https://github.com/mjq11302010044/RRPN">https://github.com/mjq11302010044/RRPN</a></li></ul><p><img src="/img/article/2021/10/30/introduce.png" alt="" /></p><p>自然场景文本检测存在的困难：光照不均，模糊，透视畸变，文本不定向等等</p><p>前人提出的使用分段网络（如完全卷积网络[FCN])生成文本预测图，需要几个后处理步骤来生成具有所需方向的最终文本区域建议，通常非常耗时。</p><p>作者提出了基于旋转候选框实现任意方向的场景文本检测，简称RRPN，其思想沿用的是目标检测中的RPN，在其基础上增加了旋转角度信息。最后在三个数据集(MSRA-TD500, ICDAR2013,ICDAR2015)进行了测试，发现它比以前的方法准确而且更有效。</p><h2 id="idea"><a class="markdownIt-Anchor" href="#idea"></a> Idea</h2><ul><li>与先前基于分割的框架不同，作者提出了基于候选框的不定向文本检测，使得候选框可以更好地适应文本区域，可以更好地修正长文本区域</li><li>作者将新提出的RROI池化层和旋转候选框的学习加入到基于候选框区域的结构当中，与传统的基于分割的文本检测框架相比，确保了文本检测的计算效率</li><li>作者提出了任意方向选择候选框的新的修正方法(refinement)，以提高任意文本检测的性能。</li></ul><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><h3 id="网络结构-rrpn框架"><a class="markdownIt-Anchor" href="#网络结构-rrpn框架"></a> 网络结构-RRPN框架</h3><p><img src="/img/article/2021/10/30/Network.png" alt="RRPN网络结构" /></p><p>RRPN沿用了Faster-RCNN中的RPN的思想(即使用其来生成候选区域)，并在此基础上进行了改进，提出了基于旋转候选网络区域(RRPN)．整个网络结构和Faster-RCNN非常相似，RRPN也是分成并行两路：一路用于预测类别，另一路用于回归旋转矩形框。</p><p>具体步骤如下:</p><ol><li>前端使用非常经典的 <strong>VGG16</strong> 作为主干特征提取网络</li><li>中间采用RRPN主要是用于生成带倾斜角的候选区域，该层输出包括候选框的类别和旋转矩形框的回归</li><li>通过RRoI Pooling将RRPN生成的候选框映射到特征图上，得到最终的文本行检测结果</li></ol><h3 id="具体细节"><a class="markdownIt-Anchor" href="#具体细节"></a> 具体细节</h3><h4 id="1rotated-bounding-box-representation-旋转矩形框的表示"><a class="markdownIt-Anchor" href="#1rotated-bounding-box-representation-旋转矩形框的表示"></a> 1.Rotated Bounding Box Representation-旋转矩形框的表示</h4><p>用(x,y,w,h,θ)表示旋转矩形框：其中(x,y)表示几何矩形中心点坐标,h表示矩形框的短边长度,w 表示矩形框的长边,θ表示x正轴与矩形框长边的夹角。</p><p>围绕矩阵中心旋转α角后，中心锚点坐标公式:</p><p><img src="/img/article/2021/10/30/1.png" alt="" /></p><p>其中 <strong>T</strong> 是平移矩阵, <strong>R</strong> 是旋转矩阵。</p><p><img src="/img/article/2021/10/30/2.png" alt="" /></p><h4 id="2rotation-anchors-strategy-锚点旋转策略"><a class="markdownIt-Anchor" href="#2rotation-anchors-strategy-锚点旋转策略"></a> 2.Rotation Anchors Strategy-锚点旋转策略</h4><p>Anchors 就是按照固定比例（长宽、大小）预定义的框，在后续阶段找出Bounding-box位置和大小，是以这些框为基础。</p><p><img src="/img/article/2021/10/30/3.png" alt="" /></p><p>作者提出的锚点R-anchor有三类策略：</p><ul><li>scale 有8，16，32三种，表示文本行的大小</li><li>ratio 有1：2，1：5，1：8三种，表示文本行的宽高比</li><li>angle 有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mo>−</mo><mi>π</mi></mrow><mn>6</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{-\pi}{6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1473309999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.802331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>π</mi><mn>6</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{\pi}{6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>π</mi><mn>3</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{\pi}{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>π</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{\pi}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mn>2</mn><mi>π</mi></mrow><mn>3</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{2\pi}{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>六种，表示提议框的旋转角</li></ul><p>综上所述，特征图上每个点将生成54个R-anchor（６个方向，３个尺度，３个宽高比）</p><h4 id="3learning-of-rotated-proposal-旋转矩形候选框的学习"><a class="markdownIt-Anchor" href="#3learning-of-rotated-proposal-旋转矩形候选框的学习"></a> 3.Learning of Rotated Proposal-旋转矩形候选框的学习</h4><p>RRPN层会生成很对很多的旋转矩形框，那么这些矩形框中有哪些是需要送入网络参与训练呢？</p><p>首先作者提出了如何确定它们当中用于作为训练的正、负样本的标准:</p><ul><li>训练正样本</li></ul><blockquote><p>需要同时满足以下两种条件:</p><p>1.其与ground truth的IOU大于0.7<br />2.其与ground truth的夹角小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>π</mi><mn>12</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{\pi}{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p></blockquote><ul><li>训练负样本</li></ul><blockquote><p>满足以下条件之一:</p><p>1.其与ground truth的IOU小于0.3<br />2.其与ground truth的IOU大于0.7，并且与ground truth的夹角大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>π</mi><mn>12</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{\pi}{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p></blockquote><ul><li>损失函数</li></ul><p>作者采用的是多任务损失函数，总公式如下:</p><p><img src="/img/article/2021/10/30/4.png" alt="" /></p><p>其中分类损失函数L<sub>cls</sub>:<img src="/img/article/2021/10/30/5.png" alt="" /></p><p>其中回归损失函数L<sub>reg</sub>:<img src="/img/article/2021/10/30/6.png" alt="" /></p><h4 id="4proposal-refinement候选框修正"><a class="markdownIt-Anchor" href="#4proposal-refinement候选框修正"></a> 4.Proposal Refinement–候选框修正</h4><p><strong>倾斜IOU的计算</strong></p><p>作者使用的是倾斜的候选框，所以基于水平候选框的IOU计算方法不合适，因此提出了倾斜IOU的计算方法</p><p><img src="/img/article/2021/10/30/7.png" alt="" /></p><p>总体思路：将两个矩形的交点进行顺时针排序并连成多边形，然后分割成一个个小三角形计算总面积。</p><p>以下图（b）举例子，多边形顺序AIJCKL，分割成三角形AIJ,AJC,ACK,AKL,计算这四个三角形的和。</p><p><img src="/img/article/2021/10/30/8.png" alt="" /></p><p><strong>RROI pooling</strong></p><p>针对任意方向的文本，作者提出了旋转ROI池化层．</p><p>将高度为h和宽度为w的旋转候选区域平均划分,每个子区域和候选框的方向相同．具体的实现细节如下</p><p><img src="/img/article/2021/10/30/9.png" alt="" /></p><h2 id="实验结果"><a class="markdownIt-Anchor" href="#实验结果"></a> 实验结果</h2><p>作者最后在三个数据集(MSRA-TD500, ICDAR2013,ICDAR2015)进行了测试，发现它比以前的方法准确而且更有效。</p><p><img src="/img/article/2021/10/30/12.png" alt="" /></p><h2 id="知识索引"><a class="markdownIt-Anchor" href="#知识索引"></a> 知识索引</h2><p><strong>正样本/负样本</strong></p><p>正样本是指属于某一类别的样本,反样本是指不属于某一类别的样本。</p><p><strong>Intersection over Union - IoU - 交并比</strong></p><p><img src="/img/article/2021/10/30/13.png" alt="" /></p><p>交并比 (Intersection-over-Union，IoU)，是候选框(candidate bound) 与 原标记框(ground-truth bounding box)的交叠率，即它们的交集与并集的比值。</p><p>一般情况下，0.5 是阈值，用来判断预测的边界框是否正确。如果你希望更严格一点，你可以将 IoU 定得更高，比如说大于 0.6 或者更大的数字。IoU 越高，边界框越精确。</p><h2 id="个人反思总结"><a class="markdownIt-Anchor" href="#个人反思总结"></a> 个人反思总结</h2><blockquote><ol><li><p>接触到了许多陌生的概念，读起来感觉有些吃力</p><p>(</p><p>有时非常搞不懂某一步的意义:</p><ul><li>为什么要做这一步，作者是怎么想到要这样做的</li><li>这一步是怎么推导实现的？【突然出现一个公式或是算法，让人感觉摸不着头脑】</li></ul><p>)，</p><ol start="2"><li>应该先找找比较经典的CV论文看看，打好基础</li></ol></li><li><p>很多论文之间的思路都具有关联性，只有多看才能真正理解作者的思路</p></li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
      <tag>旋转目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++杂谈</title>
    <link href="/2021/10/27/Programing/20211027-C++%E6%9D%82%E8%B0%88/"/>
    <url>/2021/10/27/Programing/20211027-C++%E6%9D%82%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<ol><li><p>函数传入数组时，能用引用<code>&amp;</code>就用引用<code>&amp;</code>，因为不用引用传参会复制数组，时间会变长</p><ul><li>要去想一想这个数组传入函数后其内部元素会被改变么？/ 改变后对后续有无影响？</li></ul></li><li><p>习惯定义一个<code>const int N = 1e6 + 10; // 题目的数据范围</code>，顺便<code>const ind MOD; // 取模</code></p><ul><li>一维vector初始化: <code>vector&lt;int&gt; arr(N);</code></li><li>二维vector初始化:<code>vector&lt;vector&lt;int&gt;&gt; arr(N, vector&lt;int&gt;(N));</code></li></ul></li><li><p>输入输出:  循环内用<code>scanf()</code>和<code>printf()</code>； 循环外用<code>cin &gt;&gt;</code> 和<code>cout &lt;&lt;</code></p><pre class="language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 可以用下面两句来解除cin cout的绑定和 iostream的输入输出缓存&#x2F;&#x2F; 可以但没必要，因为启用后就不能用scanf()和printf()了cin.tie(NULL);ios::sync_with_stdio(false);</code></pre><p>如果要输入字符串怎么弄?</p><ul><li><p>循环外：推荐  string s，cin &gt;&gt;  s</p></li><li><p>循环内：推荐 char[MAX_N]，然后按%s读入， 注意char数组的以<code>\0</code>结尾的特性，因此预定义长度要比输入的最大长度大1。</p><pre class="language-c" data-language="c"><code class="language-c">while (m --) &#123;    char str[max_n];    scanf(&quot;%s&quot;, str);&#125;</code></pre></li><li><p>需要读入一行(即把空格也读进来）: <code>getline(cin, s);</code></p></li></ul></li><li><p>pair的sort排序会优先排序左端点first，如果左端点一样再按右端点right排序</p></li><li><p><strong>构造自定义排序的priority_queue、sort、map、set</strong>要重载<code>&lt;</code>运算符，或者写一个cmp()，cmp()可以直接用lambda表达式，写一个就地匿名函数</p></li><li><p>字典在C++中和python中的定义:</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;unordered_map&gt;using namespace std;&#x2F;&#x2F; C++中用hash map可以实现unordered_map&lt;string, int&gt; dic &#x3D; &#123;&#123;&quot;type&quot;, 0&#125;, &#123;&quot;color&quot;, 1&#125;, &#123;&quot;name&quot;, 2&#125;&#125;;</code></pre><pre class="language-python" data-language="python"><code class="language-python">dic &#x3D; &#123;&quot;type&quot;: 0, &quot;color&quot;: 1, &quot;name&quot;: 2&#125;</code></pre></li><li><p><code>next</code>在C++中是关键字，所以一般取<code>nxt</code>表示下一个, 对应<code>pre</code>表示上一个,还有<code>cur</code>当前</p></li><li><p>求一个vector中最大值最小值的最快方式是用max_element()和min_element()，注意返回的是地址要解引用</p><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; arr;int max &#x3D; *max_element(arr.begin(), arr.end());int min &#x3D; *min_element(arr.begin(). arr.end());</code></pre></li><li><p>if中的判断简写</p><pre class="language-c" data-language="c"><code class="language-c">if (j) ⇔ if (j &gt; 0)if (!j) ⇔ if (j &#x3D;&#x3D; 0) ⇔ if (j &#x3D;&#x3D; false)if (~j) ⇔ if (j &#x3D;&#x3D; -1)if (j &amp; 1) ⇔ if (j % 2 &#x3D;&#x3D; 1) &#x2F;&#x2F;判断是否是奇数</code></pre></li><li><p>数学</p><pre class="language-C" data-language="C"><code class="language-C">#include &lt;cmath&gt;&#x2F;&#x2F; 绝对值abs(x)&#x2F;&#x2F; 开方 [向下取整]sqrt(1.0 * x)</code></pre></li><li><p>操作符可以用op来记录</p><pre class="language-c" data-language="c"><code class="language-c">while (m --) &#123;    char op[2];scanf(&quot;%s&quot;, op); &#x2F;&#x2F;注意用%s，字符串读入，可以忽略空格if(op[0] &#x3D;&#x3D; &#39;I&#39;) &#123;        &#x2F;&#x2F; 插入操作            &#125; else if (op[0] &#x3D;&#x3D; &#39;Q&#39;) &#123;        &#x2F;&#x2F; 查询操作    &#125;&#125;</code></pre></li><li><p>memset初始化数组 (memset是按每个字节来初始化的)</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;cstring&gt;&#x2F;&#x2F; 0 8位全是0; -1 8位全是1memset(arr, 0, sizeof arr)memset(arr, -1, sizeof arr)&#x2F;&#x2F; 当以16进制初始化时，要确保其能转为8位2进制memset(arr, 0x3f, sizeof arr);</code></pre></li><li><p>时间复杂度对于一个算法来说，可以决定算法是否会超出时间限制，与题目数据范围结合可以快速确定解决该问题会用到什么样的算法，比如我们拿到一道题看到数据范围是1e5，那么我们可以判定这道题的时间复杂度需要控制在O(n)或者O(nlogn)的级别，因此可以判断出这道题可能是O(n)的DP，可能是双指针或者是二分答案等等</p><blockquote><p>各种例子</p><ul><li>复杂度在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>的，基本就是各种数学知识或者脑筋急转弯，n的量级基本不受限制</li><li>二分查找等复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(logn)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>，n一般在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">{10^9}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></span>这个量级内</li><li>单调栈、单调队列、差分数组、BFS、DFS、贪心、哈希、前缀和、一维动态规划等复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>，n一般可以在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">{10^6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span>这个量级内</li><li>排序、（堆）优先队列、BFS、DFS、图、分治、二分查找、字典树、线段树、并查集等复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(nlogn)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>，n一般在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">{10^5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span>这个量级内</li><li>二维动态规划等复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(n^{2})}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>，n一般在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">{10^3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span>这个量级内</li><li>三维动态规划等复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(n^{3})}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>，n一般在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">{10^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>这个量级内</li></ul></blockquote></li></ol><blockquote><ul><li>状态压缩等复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，n一般在16左右</li></ul></blockquote><ol start="14"><li><p>5分钟写不出来就直接看题解，但是不要边看边写，看完之后在不借助任何帮助的情况下自己写一遍</p></li><li><p><a href="https://www.acoier.com/tags/">https://www.acoier.com/tags/</a></p></li><li><p>kuangbin专题</p></li><li><p>剑指Offer 33.二叉搜索树的后续遍历序列，这道题，再次印证了二叉搜索树是一种变相的递增序列</p></li><li><p>BFS走二维图</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 定义方向:上右下左 0 1 0vector&lt;int&gt; dx &#x3D; &#123;0, 1, 0, -1&#125;;vector&lt;int&gt; dy &#x3D; &#123;-1, 0, 1, 0&#125;;</code></pre></li><li><p>频繁调用的函数可以设为inline函数</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 图的存储inline void add (int u, int v, int w);    &#x2F;&#x2F; 手写堆的up和down函数inline void up(int u)inline void down(int u)</code></pre></li><li><p>出现段错误Segmentation Fault，可以用删代码法(主要删包含访问数组的循环)排除问题。</p></li><li><p>做图论问题，一定要看请是有向图还是无向图，无向图一定要把M的范围扩成2倍，不然容易TLE,在图论中，存储也是比较怪的一点，有向图只存一条边，无向图可以看成双向有向图，存两条边。无向图最多存n * (n - - 1)，考虑自环n * n；有向图最多n(n -1) / 2。</p><pre class="language-c" data-language="c"><code class="language-c">const int N &#x3D; 1e5 + 7;const int M &#x3D; 2 * 1e5&#39;</code></pre></li><li><p>清楚有些操作是可以分拆的，如加减乘除；有些操作是不可以分拆的=(如求max，求最大公约,最小公倍数),这时候可以考虑使用线段树优化</p><blockquote><p>已知了一个序列中的max，你去掉末尾的数，就求不出当前序列的max</p></blockquote></li><li><p>到底是leetcode上的动态写法更好还是普通形式的静态写法比较好。还是一般静态，为了leetcode上一些专门的题型而去刷一些动态写法，如链表和二叉搜索树。</p></li><li><p>右操作数命名为Node&amp; rhs   为right hand size  <a href="https://leetcode.cn/submissions/detail/385963390/">https://leetcode.cn/submissions/detail/385963390/</a></p></li><li><p>unordered_set和unordered_map不能直接以pair等复杂(自定义)类型作为键名 <a href="https://blog.csdn.net/weixin_44966641/article/details/121536027">参考</a></p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 如需使用，你需要自定义一个hash函数，然后在声明时将其传入struct SimplePairHash &#123;    std::size_t operator()(const std::pair&lt;int, int&gt;&amp; p) const &#123;        return p.first ^ p.second;    &#125;&#125;;std::unordered_set&lt;std::pair&lt;int, int&gt;, SimplePairHash&gt; S;</code></pre></li><li><p><code>while(cin &gt;&gt; n)</code> 或者<code>while(scanf(&quot;%d&quot;, &amp;n) != EOF)</code>可以处理没有特判的输入结尾。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>保研后记</title>
    <link href="/2021/10/06/Diary/20211006-%E4%BF%9D%E7%A0%94%E5%90%8E%E8%AE%B0/"/>
    <url>/2021/10/06/Diary/20211006-%E4%BF%9D%E7%A0%94%E5%90%8E%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="079a60d0107f4c0da05e58625d0a3df8484f9b8aaaa6d10f3b621f145e4e22bb">10d79030e8222445804370796b90fca1b3149e2c2a0f36d6b4ea04e548758c219d5ce3f3ea33aadd8650b46a4ea9e603f7ed139b64c27d0c8eaaaa4dc2038915e34ae6c879d454ee122b9a657114dd93066bf077e7deeef2a5bb90debeb851790c0fedda0d4e47f63c66c315fce9a8093806e529b403a8594264e1b038acbd35c21b563c71581e12e06ded51e5ee3028857bd8c5da677250e1cd07e715e9a7c39dbcd9cf49f6153b9daa2f4d6fc0de87cfaf056723b909d10557068f9e4016091cef38be85e423bc368d2f7be83eddf65fe51bfdfe3ac19114a78749956b73d134ae6ed0971ffc001914da4d1fdedf72386b8cb55aa990bc283da562725679a9a9b6ed09edb7265fd57ab3d413de97f282a41b799b09d91cc17d56fc02c6c202f94a1f8a8eefa30cf49007fc7c1de65d199068c99c133c1ff9d2c0d39a34e3c2f7a06eae8d74bab6f4282c355a64c1a231af52e10b5f9b09379f650b90304ce6d01ff36a26d7c085c5f844d1916c5434c3cc792347e8978b7cf4b12dddca964fe9a6832cc0a4aee40ae4633ff43350bc2b7a0a0aa37d9fd792a373185d8da39b818d057b57fbdff5b0564d4f21896d1ffcaab4a174e7091a85aa7d3b693ef24e6024e55cddbddebf2254cae886874cebef5379ed16add84f0e6b96d6dcd9e43fa0f49c4db27dc216a057b8129ffa41706d6c99ca9fccc73772421c69c2c5a23f0291e1475350e3d60011da243ab77592312b6145a8b428378354b5613b4e110a7020e592b8bff78b638b8c4eaeb41a4df23ca6f67fcf199dfdef5e686fbd673add73bd047bd25f4b94c097e85fbd7423da9cc807a86222768201bcadcc1755748af78d64af08188ec164e141e779541026b9032637798ff93feb5f5fd604f937e33a27e32daf1e5d3f587842a11fa028ff05aa3fefabefd82d3732ac8b6ca38634300957ca5b8035215f3c736ebf19ead27140c7916c9a8d3664ae6c4920a5f9f5c02eca276ad4d792e586c501381d7c6002ad760843d861d05df0361254a76b424055b7d232e77681747c6b7f145dec8bf18fc8a154cdaa6bbe05264033baac440140ad2db01bfd25a80bce7efcea98d5060c32fc36533baf912766ea8ce0768f11089ef09543702411d3a755dbc3675c17d531704273236d86b0b83c95f5a5a6178591d2dbfc205f2ca0a3e769f8b8a17bc08fdec48691bef5cd013646d0307fc31140ac741eafa788759fc98e52865afb430b9ccfbae3f57c29caad7d7a5977bd1794727aaf64e6c4adc55474b9177d9c125c4dfa08c4923bff577c3c1b6d89d75190b61321fa87a935004bb1b07fa63097ce62a1ebd8ebf34ea5da565bf8d4eaa79a93060d61e50862d9ee6bf52515f77c915f3d03ff8b107be7277c6065ca38b7c2eab7cdde4db05931983e913027f6b0251ade1d1a849e464994d4ecef1d029d524e3be6f77be3b12768d628382c8f8dab5e0ffb963b07a4a3c8bd3405691fe469f04448e26dcbf02fbc3953bf793ba5d1071e6e1392d5e5b9f19a90af86664896d916d8d2064ceb15a0100b47c6ff9b2a14ebc51820aa0979355ce5f2f5079dfe5065e3cce4faccc3e67caea2d98c46b93232062ac594c31a57a57c4015a7fcff72c308eefdb9bcd657360b46857928f949a606fa9aeb2488013ad976cf92d91464b2bb8faaa4c8858a51a6c9335011d23f0e7e312c0312cb05403dff14b5257a502c151343dfef58e26d28095917ae985864dedc781485d237942363e83db48a3e82a6d3d41b0a0f25c77fc38861b7e2a3a30a08e4827c74e10b581b6eca94533585842644ee8bc474f84238b59fe413b86397fdfd02dc8593b1b6944c9508dd4f74738839f1253fc1a990c757b0f6aeb1bd001850c04fe29a3553073d930fe58740ed94f57c0bec243ea5b0d334ff74c9a883de5fea7ecd97bd8e08ee4b00dbdba7996bc9f9c96bbdbc58e078357a9b8d6215239589ca7e12b0fc057bbf5fa77a428d2f8c4755aaf35eb939f08a5a6fc5fae13d03e03a7d1dec68a2a3cd327658a1844bc45a785ad03f82baa399d868a161d5020cb894936eb81214c139d913a66cca01ccc526c144231a4d2f2d2dc9d5819a89184307670a9af9a0135e54aa5b7d8456a731124c174769bcd8e9ff601462ab3e9c58505f09cc3b2e5e7da541e669823454d561de4033d639226eabf5bbbea0badeb9a15620815faee0fa8c3dd039eea0ed8c702fb876e5b6f17eefdac4479316f2fbc4867e64673c3fee742d4decfec1ff861c1193d484c065a285befe38dc0f3979c65ab89cabd9ed81d061360a997f37a285f031c451b244a1f3c60909004a74426083a661084a8d645d42eb24538a47069c4e885aa96e401c641e0e964ca7a03da8ebb796943fbcbe98ff6161d9d813309771f32ce4678080655859fb175189517b4512ee62228a5b93050f41396bf6558fb04e87ac7eb9802ef0bf019d46ea97879b74873e4511af36418aaabd0b117b05e093bfdab0a5f6a4af53d9f2f48224111952173b13dbf8e931f5be739f887c67eada8b812693dd44ac0354acc0a201976cacd2371df1dceb6a3bcc22ac6489a7f4457305a94681bb6100751629a61eb8a5d923704b3314f1396c4ef9d5a815f0ded17e7ac6099933fdafb61dabd444027259b9fd9cd83ece5725c2f4a1d6b4bd328df1724d0f9c1384a2e3374e5550df32fea0bf2ccb08bd3911fa74339ef4523f09037c3a0beb5a503a1f198ea044af6d023a877b2af1c81302dcf85693bb284e9692821b557e26a9c1acabd439026843c056576ccd6255a86c8576b68cca8dce1710b371bbbd06260bdd7c4e96debe24e4e8ca1643cb47ab5911e78b21b485cabc6615fd9778da5f3e134bb83ec4d8ec5d06a96160657d43f500dc11b6186fa953d97ccf2d681fd661a25dc7b11291b202d088eb382d404cc27bba713a661f66643afc3eaf48eb1e4d863293ef5c0857404e53f90f676814b1025e98a4192c273e381256aa6eb979ed026bef9cf20d1fff099439ac08a65b50570e0bd195848a09c2c8fec99e28c2cc183adfe44a17a320705343f7ec42c79bbfb4b8e33e92254294bd647de9155a9cc76e6fa6fe902eaf9fa28bf741c8c5acd646c73ad213e15a39f248e13e101994ef73308f97fc3af8aaa6afc8fca8d44ac97c0937dd5ec6a3ec66c16f756cbb4d2b2653789043e90c505a921db6cc8cf7d1d188bcbe16b3ebdb546c64372fbd8fb64a18653177bca3b60cabd38a2d1a42e6e0fd055cf7aa9ad186acda642b1162a31f648c9782c03549b3b90f8e4c928dcc88d32e27a20bce89a84c4220076c30e336f6e69caed17dc41741aa6d0fcb720c2a870e2eea6e43904b0834e5fa6e8057f2f2a50bc38cbd2064de070b131298b9f29f5777a2224419219868e07b74f617e33fa767f0862d649003d27767898fdfb69ac59e48b3aebb4b3b889ac51be3919004e21273f50e916d79436fe912ed041af8f600da777f456ad2126b27cb3b8123f3a61702baa9073600f9ff9564c21c6f2cbf4dedd7b053c0ed80eb419dafae92b5e24dd4670f1fa7066badac90fddf5d76b4d617fcb9a6707341e6b355d9499ac92b5b42e97fd1e4dc2f3ca3828d6e9f119f1f4d04a02d6522d3bc1caedd187f278533720f4df6810acba8f8415e83205898474120e96238430371ce0fa32a630aef29fa2b9980eda487abd30e350136be945148261371eb48eee54b736abb4bfff7dd57dae0d4027f1dec847423f267620407343f3896b3e86c1a860b13a7e71cac466919a7b1262abef676990219f7c5282d2f284ff1b498e4790f4d3d0e73e8b677af88a15a7b1e762ed7e23935de073ec7058dfacbb1de07fe887c6ab1267b8f374f3aeb324542368b0f42ae9575da83024a1d98d57984516cc53213223d183873cc48ce888ef8bbff3f1145deb1f6095e7450e47a2e4b4b0d9a459b5d75764f9cf5f756ddbf52be0fe64300a367d83a3a9fdab8c62da828f6989f448649d650cbb60df20735f50cad83384b505039a537c7a2e68c11e0dce1b9376fa930346d12ec2273c8e421557dd04c1d4d52beb19b1648fdaf11e3d9e545212e9983ac2343430d67aa643d18b5de621fb14cf9e27984c99937779065fee1d57270851f012c971bd87c3bbbd4f04397bd39a5b87d17dd7294e938fd26c4e21715d8397d059c24ffeaba06af12d8bdc384d788b9351b3bf432c4aa6d276ea30f92203cce5edf007bf397648a7f1d6a979f5d559549282e16266ad65392cb5ba92a626348b783b2e991ceb9e31fb908d9bf29621a0aae7b8109396c25134c087d4dc776214b87cb9109d18d76aca9ecaa147536cafc38c6cc30b0c0502f2441f5eefbd515bd41b77a97ee8094701f7bd2748e39db8e97d4a8ba46f482038c6a9f7abd7217bb57c396eaac94dde6d511235630d9a1460feb7dd6fc1a04065e1994c1efc3cd0163d5e25bf79ec04f30211a47bbca84f2ab2d427fb8d331283503a4416911fbb3a47186425320800d00e809efdc1d45872be620d1bdc9893dc8817c549c3c9d2851aeafe12ebe688fd8ae3da5669a7090391125c1090279b70eeed57c3efc1def757eb5e84048e2b997e07d410f53ccee67a390d82567bfa6afe45d784cf953342c5c77f54dd19f01977bce196281dfbeeb310f8aefd690fdf5c32978103769598cc3899e0843d3976b4121115362ea29d6b11a85eb3ffa8a55b441e37450ef6ea9833bc3ec6e87f9a467abc33432f4bd7147015b34c79dea93dbd4013bbc10823b71b59fd85c2acfc62faf7f5c0dfb9120cb7185932eacb1cfa92969bb7cea2d4da78cfe4b714d1b9fd9b0e87a7d261a01ed69c8c99cf44a21d4bf16101e95bd7f969c5accb0796fd57dbd79a127169d3c3d4a26fc3e3f6d845cadbcfd1e9be2c4dae48874bbe32c3344235ccd8fef2c15016a901e74dd6b1f0ade0693a7ef823f373e61ad09c83b425480f2fd8c8003942752fa5c92b17e246c5f1c0d73ac214909398d31f7399c42d20dbc1332a11dbf91612d3fe18c4cb8f787ba9a2e2cfd88002467aaef616844552797c3d348178bf1687f34c5583ae7c5a3df63a5a8743493f3be3459199d6f0f42619193997c20084407ddafb239eda3ee203e0daf13ec7e444b68a151e4c79ef4155fc6d79f4285a24bf26c144691ddd6e25ed84a4357eac2b13e164f0205737c88e9a084e217147295ad91d22c0a268bfdd60b3f91e26f93c52560c156dc90e1294b97832058d525b26d26debd25f934e491dacaa46fd98b39ca16cdf867fbf4ead82a683812674217c4576368a46a3bee240f3c6806d662b9a2f71ebcdc881365b323f88368d620eb6cd3f806de54e9dfddbd50c3788c5e691d814f818e8b5aeaf0c805a52b4f801a66a3c75b89b5bdc9ce901d4d6cfb785c850425bd58d19cafe16a574404381df60a4fc80ee7b44f36504142ea03d0ff425cf7afb774bcd8d3630688d833a888f6784658094cc582a5992c39f1f0b1a8b02cf1a04ca73601e089db418ac37573843cd226cc1fe6705c612815142d15161ea9950b9321fcf913226a4e17f87fbe4f4801c9749d0f081dc2fc6d4ebc0c8af69f4a5fbfd4ba2478a98ce633f4f48739f4db72f6d2ccacc6429671d90326f0c124b5b294339c4c1f43e99da4b1da14319f4e2313e235406a9010dd000e87c9523a28dd5b11cae419498b0e872a28a70b5a7f10bb6ab2cc513e0ef113e025514d9f78e239d90db0d4334038667e42b68fdb47acf87705fced8d7e350c3213f98bd74ba812d3cbff7866d0c38bf900a03086d57c1a1b1638972393deaf09e88bf85119a3aaa3834358f1df63fbbb9486e0480a444fa86b92208294055cbb2621dd3e2a24a0313d551d3c86c9d0243330496184ff5e9f5264cf247b7bbf762862e02ba19b8be835d48294037062497b31dced33facc4e09741566e0a1e89ee71f0e9b2ac1233e5c22963d3b547be62a0630e4379f2b30feadf939196813639d9263d097bcabdf2ca7f0e4fb4217a1451f29c606704bd52e074ceb3ef537df60e7b7e318d83326014ea0b152b028a91317bd510891e1c7da0fb7dad32cea88af3257de230a5ca0ad9c2b1c3914ad73d9166c446f6b1b9f25b12640c669a7e1cf87449a29673f7a79cda42e232881e24ad278f802aebaf5460ba94d87d43f9684dcd6eded9163958aa6eed6433ad53e3bed375a5e3de3d3829b145dd74899fe3d7e45cfa1e4544955e9f56271bb9dc2875f5d4ef6809b77c4fa08aba2642c79324fb4fa584ec47822692f632102f1d6bf7e09d903da1d6a1ab031e89d92d1e321b9b6ba44b543bb1754f52b3a5b5937b764b1c6e9b9d5ec0218f5f493ded2bdc71cb3bc82faf0280a3dae4cbbf7ebb54659ae6e0fae343bedcf507dc6200d9a2fc172ea39d2592fed216ef63c24fffb3772a8826ec45777455a322780cd521977fc48933669ecd938d1818b25e7f482b2546f576c595b3a4916c6bba16a22cda9c223f171ddce4882264e57c49437c85bcc1f91647cbb6e6cd5bbdc3119ace42caa271efa8ea79327b61d6ec4315ac0b5e494658afb1e26b2c0dfa13dd6eeb0e21432546ebc58624c93fa815f09483ac2ec144af75b2df3b124ec3e9a8c538b06c5b3237b8f852b09139441a5950c48fc58deb293e5d7d89fbfe35e89b29edf07f6c26e8307fc1a5e5c6b8fef8b3d4295f9256099134159033c540c975a41da8d005d6c1a221471474817d9dfc637d3b64799ed1d31410b2ba5dc92338332ddb3f723eea76ae5acec79277d583ecc5bec210b168c3309cac267d0e5a19d53c7143ee2ba8ae4a9d6c2c7fb4525809a8aac178b24c35f6b54bf0033f65b6ff4f708e7798b8bbdedf27ed514f008ace3ed9fae782747e1fc466e233ebf9d11b39c4413aa7a1e7e6f24730bae4a3d5adb19618f21df7b82b81620f92fed16fecd543c88389bbd6e0228ad25d59efa93280cfebd19470c1adea3d9125aec0522e92929aaf0e34d181629441e5f1c90c867fa878f843e3583745c20b075bd72ea26d0ac363f9c14283913c35ab67ca2bb58066c98ae40efef56b86a33cca91068420a81dc66dca36b599b668e80ae9d22b88e8224a34aa404fc5dbece4637f902abab1ede6df0275c19534234753e41f4b62b4ba4f7ab301fd039e9b812f0e1f95476685c453a844f1315f6635b49da05cad2161871072b04a0f646ada4bba7dace1275abc33f7229ae058966b86c41b19ae703eff909eb458ef277801c279e357ede4e5b985589ac248e712df4a0d6aa61e9a4d699f591f1ce3091e5e83b24bec3a44279b99d0e4854fde4e339f01e7644270bfb3df94502381f45a6786637aef30e79c625047da779c469ebbff3d96fd2aa948fbab93cb35e1768223dc642626a03a4d33001cf16394fdba566a6e88b663dd826c7dcce9bd0809fc25c035e5246846b00b5f6634de9a24b3d1ffffc0e8a722258b17872747d183c20431d9374ab0044e1e98064d01647401c2e06b58cd1337b1a161b1a4ccb3cc9bce3212a61da639d5b6e2920c00f9128a63cef7eeb2303762c294aad25de0c102b80e2d1b7e4a1176166709a79717808f5b603fc70c4a768560a64f9b6837b30b3b0f1d94083417d6b4188e844d0106c8156f3be94136fd9ee547b841e2fcbda89a22913cf32502e20e05b4c792ed34ff7dc4e9c843b9807043213b73fb92c9fba027cd005ccb696f204522625514d105f25fe8170753936d1a85a6ea044a0f6741be1aece6f0a42367c6daa616322e40101bc0792352835367b63107c101c88547003bba2c77d06772fa1c63c7f3baa682c8ca39196bd73363d20516331b4e73b5cead1c4094f87d2c0beadc2a38f9c9b3172853071782ea6928425dd9e6edcdc0021cb6ff06fa22c6a9d6f87c73421ee7fffa2c0ec1382015ba57ff66bc1f4d99589730cd6875d0e691821a705b47e85fd4737c2313f0385040c6417c6bb2a07b21ebdd17b0c1cb26f269bc371cefbd8873edcb5f5b7be9856a8de9db722d8eb5b6210ce54f311172def7c0f3d0a7c86dc496779221ea7ed9f4b64c8cf7b93336c29165dd3d69a6170dcf7df0e3f4a45d5281275ce771b0816c480f6ecc8c8f663be4e211bbb2d77ea52dde20cdef8f8dfa04c3c1c2535a3c47005900b39c730dfa35e129775a551bb2a8229b8d978270c2fb29a8e53af57dceca77ef826318925e8cfd1f0e4d8fa5ac11e4dc2b23a898d46532ca3a6c3a5923509beb54d63db61673b7b13ae3122f84317489ff8cea18f44759cead8a7d5f8b0cf9adb38ab5c2a47c7dce47128a33a77929d8540e4e59a0d75d156dec2f07cd7ced4eb1e71ec568bef964a62d8972a8e48933e71de20841836e4d72c70660688050b753d84b69edce84c74593ed97a539414523f092866783dbfa7e24b84f910a3335f2a4e091704924da268b0ed3b40af38e462c3f00cd5c98c628c83e605674ef94e740deedbbe4f5547c95311c206c4e34efad4a694545052c9505cffb513d537d9533f9946ddf0c0b4bb9c380a9d47081655b77fbdca769a84244e1614b2687760108cd02c2c37343a39279657571509d8bdbd38777b3532661d8b4d7fcf76d83bcc82a5ede3a85230374621cce6d4cc3c2889b53460b85727b0272a91d9db17d07f74f8d160ba71b27b35837557974fa7ece047f2f9e08a17f8d654542fb2ea8ed3c2045ace81633cfc19a7a21bbf94c80019ee829ad04cabc82d1012ee3bb0d3a806983a5a96dd9c2a374f1007f354e018486e536e0d3e22fc54cfeb7cee8e5c14edc5500c84eedf794353f79e97f95a68a296bc29cdf2917e54a7db1dcbaca72f61949da59329a13e77fadc3ca6e04ab0d17b8fd443731eb2dac622f1014a2e3f3e6835c968e4eefb797c3367fea2fe3d24fdd6cfecc7f9e2193b1bc5e69c944219c3d3b0b014b74a400f18658d1cf3bdddc999d2580fd70d85ff155ff34a6e9a02fb4911737cb96edc4ef29e18e4283f3bd627b9740b54f23928ae6fb1fffc8799a0a6e039927ca6a1923f76e6621ba120b64bf0773f25042e67648bc0ce547bfed24f993254685a6c4b313069e66cafa4d8f90cb40d5b786a618a0062a0bd9bc6601627c9538047ec865b727b8b2fe5e506a848bacf9da8380c495743a9fa1cb5870569d978e6c9f68d16681a178069e5da5b539f83e54056e710ab26a89782ba06b4cae9e34c66d25a04fdb8b9ae4200cb422682789f2ea9e964dd62a9ade512ff49340dca4d0a6687468397df9e89383fba9bff630ee16ab9396db47283e648873ba5f9375aadf93558e3e4a2e3b740d16d29b1ea0070a8957866e1067e25e66a46089869b58ca3e94957b37914ad9d7c5decbb7d26718d561751c22bad64b2b9986748923c15b644d1ae03eb2e60e5bb52fb4eeff9289cd41066f36f748a460a4aca3fd527764d33931fc361530983ba7121deeecc87bfe8a16e08d6c2a6c7f57b2383cfdab65a9a94ef63906bb7c0c82767083a9a3a5e20c5726b3935ce932fca806876d5caf19e3b426f392c47e3f52440c2d8b39dc0a64d03a92f7607882d488600a9040bcd9fc2023fa95574e0dde72c0a8616f5e476d89da2c1ec1feb1c49f07cb54a65afa5e15bb4d4fa551698bc80f0ad42025b266662043a2313114ea184f685a08ae0cf32d6cbaa97239b604b062c69a70a149adcca16526376f19e0172c405793284c5aef64bc6c4b997da8b6884d33c52e843bedb75e90b3ee982de18616be23ba8f19887f1ecc788c1cdb60bd7257d56bf0a3f6aff5586f651f22e5d9abf1c9e8402c8c5eb202f87e93227cf8f42541fd64bc0d87e0930f2ccbca651db3375a609d3385011d1e8ef0258c5fe0a93d5867e91ac066984bd9a0d06dddae17473718fb1e3972083ff4ded80c028b8bcef5771141d74dddfef515414c90fe1ecf2c9536ab20df5449c2cfb3410a8fb9a2abfbc372dffbc0bf7dbf8201a4e0eac25dead31be16224fda091fdc2cc47f25f2debfd18019b27c80f66ffb721699ebcca6e556337f7417d88999b55c84d94ec41de7a4dcbd9b78c41d7f95616aa10d00ac20f092f23c1aa602e010d177199cb24deaad0f72002689c4107f891e40aeb05aaf890e45d11284975dd87c1b22592f1f39897c15f5bb1d3702a2c007800416415ee7cd96df584a8ae48dec993c0900f632e1e16bb8a408643ed41e66d663d06a9255583f71ef090dd395bb626b88fb0000b694cd0e30d24cda2747ef9cf6a20163db50e4d512a5c437f577b0e61c989871bd018083b0b4539bf7d7de15e669081e47fd1889eeee26b97f6ecb0a23837059b0bf3a5bac24b30bfc28ae9837d9e1c7141e7e8e6c833a23bd0a2c3738a91abd501073da55bd6d715b3dc7520c9ab41cbb9622736221530d6ba6d9fd557f700403f2ad0ef51ead2cf4b63b1f77da13500579c05499d9d4f57f4b509d451a8ec081ee13bf5b334e51e1882ca0fdc3b6b8587e7cdc5e71206702e17ba7e9c05ed3cac5afcfb9d195044a425f2d56f6399ee29c66b7338bdbd63595f5941116d58c7c3dd8971afde556a9c8e80c00435a580541cc8322e8521a4f7b7df25dfff958558d630b68a5d974917ed44764b2c74759fc5bdc19934279c7240d746fcccaaf5dccc9334683e441aff65e0b38734cc711b7c609a04ff87dcd3853603d63bc6fe828eb4e9a96d42e9af2210c382e9087a8795682a77349e9ac7cb65e266bdc0a00577056152fabeccb4192106b654a70b7bd950d9b4ed0bdd190b9ab8189ff15c9490c6d1f89f927f13e987138296a7cc7931bb9b2fdf7fab9954f544b88a36459bf8ba54191f58c49ad1190d2e95624320b67a9312cbe70b5f8dcbc9122b8ddac20291f4d0e847b0a3da4629a20ee2e6cbd8a5e97172f9e1fbc11ca6d009f1bf03b6fbe5cefbcf4e103fef75ce266a0796739544798fc71d2b0ab96632cadcb1226ff408c9792665d792d91d60392924ef6561d892eef5ec528000676df46b5276937ae0c8f6f7bdb4fc4c07ca34a0dad719bb942be3d9114002b2b1f9ba175a8cf04d149f865b504b956fc41ab2a70e5a747a91fff3ab3d59283a4d9be71b0a1cb28d7ded168fa55fc16ba17619433213a5fc8f152579044a701f8f6fe08932e63b93b067ec3dd0dfa8a19c0e7439e1d09f0ddd320fcdf57a75428ea28b172cb408ed863b841bbe0961f9b9850ec18e397c1adde4ee3218d7256c4a5ccff89a3332ed53fe252e217131a31e1f6630ae105eff65184b07d0d7bf6a11ee02e6a64760f3348</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Plz enter the password.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>保研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学初步-(2)-快速幂</title>
    <link href="/2021/08/02/Algorithm/Template/20210802-0x70-%E6%95%B0%E5%AD%A6%E5%88%9D%E6%AD%A5-(2)-%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <url>/2021/08/02/Algorithm/Template/20210802-0x70-%E6%95%B0%E5%AD%A6%E5%88%9D%E6%AD%A5-(2)-%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<h2 id="快速幂"><a class="markdownIt-Anchor" href="#快速幂"></a> 快速幂</h2><p>只介绍迭代版，不介绍递归版</p><h3 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h3><ul><li>时间复杂度:<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(log_2N)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">log_2N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>为对N进行二进制拆分的时间复杂度。</li><li>空间复杂度:<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></li></ul><h3 id="double版"><a class="markdownIt-Anchor" href="#double版"></a> double版</h3><pre class="language-c" data-language="c"><code class="language-c">#include &lt;iostream&gt;using namespace std;typedef long long LL;const LL MOD &#x3D; 1e9 + 7;double fast_pow(double x, LL N) &#123;    double res &#x3D; 1.0 % MOD;        while(N) &#123;        if (N &amp; 1) &#123;            &#x2F;&#x2F; 低位为1时贡献            res &#x3D; res * x % MOD;        &#125;        &#x2F;&#x2F; 累积        x &#x3D; x * x % MOD;        N &#x3D; N &gt;&gt; 1;    &#125;        return res;&#125;</code></pre><p><strong>PS:</strong>  函数内只能计算非负次幂(N &gt;= 0)，如果要正负次幂通用，可以如下调用:</p><pre class="language-c" data-language="c"><code class="language-c">double pow(double x, int n) &#123;    long long N &#x3D; n;    return N &gt;&#x3D; 0 ? fast_pow(x, N) : fast_pow(1.0 &#x2F; x, N); &#125;</code></pre><h3 id="long-long版"><a class="markdownIt-Anchor" href="#long-long版"></a> long long版</h3><pre class="language-c" data-language="c"><code class="language-c">#include &lt;iostream&gt;using namespace std;typedef long long LL;const LL MOD &#x3D; 1e9 + 7;LL fast_pow(LL x, LL N) &#123;    LL res &#x3D; 1LL % MOD;        while(N) &#123;        if (N &amp; 1) &#123;            &#x2F;&#x2F; 低位为1时贡献            res &#x3D; res * x % MOD;        &#125;        &#x2F;&#x2F; 累积        x &#x3D; x * x % MOD;        N &#x3D; N &gt;&gt; 1;    &#125;        return res;&#125;</code></pre><h3 id="matrix版矩阵快速幂"><a class="markdownIt-Anchor" href="#matrix版矩阵快速幂"></a> Matrix版(矩阵快速幂)</h3><p>n * n的矩阵支持<strong>乘法</strong>且<strong>满足结合律</strong>，因此也能用快速幂。</p><p><a href="https://www.luogu.com.cn/problem/P1962">洛谷P1962-斐波那契数列</a></p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;iostream&gt;using namespace std;typedef long long LL;const LL MOD  &#x3D; 1e9 + 7;&#x2F;&#x2F; 以2*2的矩阵为例子struct Matrix &#123;    LL a1, a2;    LL b1, b2;        Matrix(LL _a1, LL _a2,           LL _b1, LL _b2) : a1(_a1), a2(_a2), b1(_b1), b2(_b2) &#123;&#125;        &#x2F;&#x2F; 重载乘号    Matrix operator* (const Matrix &amp;rhs) const&#123;        Matrix res((a1 * rhs.a1 + a2 * rhs.b1) % MOD,           (a1 * rhs.a2 + a2 * rhs.b2) % MOD,                   (b1 * rhs.a1 + b2 * rhs.b1) % MOD,                   (b1 * rhs.a2 + b2 * rhs.b2) % MOD);        return res;&#125;&#125;;Matrix fast_pow(Matrix x, LL N) &#123;    Matrix res(1, 0, 0, 1); &#x2F;&#x2F; 单位矩阵        while (N) &#123;        if (N &amp; 1) &#123;            res &#x3D; res * x; &#x2F;&#x2F; 不能用*&#x3D;，没有重载        &#125;        x &#x3D; x * x;&#x2F;&#x2F; 在*的时候已经取MOD了        N &#x3D; N &gt;&gt; 1;    &#125;        return res;&#125;int main() &#123;    Matrix m(0, 1, 1, 1);        LL n;    scanf(&quot;%lld&quot;, &amp;n);    Matrix res &#x3D; fast_pow(m, n - 1);    printf(&quot;%lld\n&quot;, (res.a1 + res.a2) % MOD);        return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学初步-(1)-质数、最大公约数</title>
    <link href="/2021/08/01/Algorithm/Template/20210801-0x70-%E6%95%B0%E5%AD%A6%E5%88%9D%E6%AD%A5-(1)-%E8%B4%A8%E6%95%B0%E4%B8%8E%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0/"/>
    <url>/2021/08/01/Algorithm/Template/20210801-0x70-%E6%95%B0%E5%AD%A6%E5%88%9D%E6%AD%A5-(1)-%E8%B4%A8%E6%95%B0%E4%B8%8E%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="质数"><a class="markdownIt-Anchor" href="#质数"></a> 质数</h2><h2 id="最大公约数"><a class="markdownIt-Anchor" href="#最大公约数"></a> 最大公约数</h2><p>最大公约数即为 Greatest Common Divisor，常缩写为 gcd.</p><pre class="language-c" data-language="c"><code class="language-c">int d &#x3D; gcd(int a, int b);int m &#x3D; lcm(int a, int b);</code></pre><h2 id="最小公倍数"><a class="markdownIt-Anchor" href="#最小公倍数"></a> 最小公倍数</h2><p>C++14 : __gcd(a, b) (Defined in header <code>&lt;algorithm&gt;</code>)</p><p>C++17：<a href="https://en.cppreference.com/w/cpp/numeric/gcd">gcd(a, b)</a> 和 <a href="https://en.cppreference.com/w/cpp/numeric/lcm">lcm(a, b)</a> (Defined in header <code>&lt;numeric&gt;</code>)</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论-(4)-二分图的分配</title>
    <link href="/2021/07/04/Algorithm/Template/20210704-0x60-%E5%9B%BE%E8%AE%BA-(4)-%E4%BA%8C%E5%88%86%E5%9B%BE%E7%9A%84%E5%88%86%E9%85%8D/"/>
    <url>/2021/07/04/Algorithm/Template/20210704-0x60-%E5%9B%BE%E8%AE%BA-(4)-%E4%BA%8C%E5%88%86%E5%9B%BE%E7%9A%84%E5%88%86%E9%85%8D/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论-(3)-最小生成树</title>
    <link href="/2021/07/03/Algorithm/Template/20210703-0x60-%E5%9B%BE%E8%AE%BA-(3)-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <url>/2021/07/03/Algorithm/Template/20210703-0x60-%E5%9B%BE%E8%AE%BA-(3)-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0x60图论-(2)-最短路</title>
    <link href="/2021/07/02/Algorithm/Template/20210702-0x60-%E5%9B%BE%E8%AE%BA-(2)-%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    <url>/2021/07/02/Algorithm/Template/20210702-0x60-%E5%9B%BE%E8%AE%BA-(2)-%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<p><strong>源点</strong>：图中的起点</p><p><strong>汇点</strong>：图中的终点</p><p>需要做到: 输出参数 start, 然后返回参数<code>vector&lt;int&gt;</code>返回每个点到起点的最短路径！然后选用即可。</p><h2 id="单源最短路"><a class="markdownIt-Anchor" href="#单源最短路"></a> 单源最短路</h2><p>单源，顾名思义就是图中只有一个起点。</p><p>单源最短路问题，需要记录额外两个变量:</p><pre class="language-c" data-language="c"><code class="language-c">int dist[N];      &#x2F;&#x2F; 当前结点到源点的最短路径距离bool visited[N];  &#x2F;&#x2F; 当前结点到源点的最短路径是否已经确定</code></pre><h3 id="所有边权都是正数"><a class="markdownIt-Anchor" href="#所有边权都是正数"></a> 所有边权都是正数</h3><p>Dijkstra算法是基于贪心的思想，适用于求所有边权都是正数的最短路径。</p><p><strong>step1</strong>：初始化距离：起点到起点的距离为0，其它点到起点的距离为正无穷。</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;cstring&gt;&#x2F;&#x2F; 初始化距离memset(dist, 0x3f, sizeof dist);dist[1] &#x3D; 0;</code></pre><p><strong>step2</strong>： 循环松弛，每次确定一个点到起点的最短路，在没有确定的点中选取一个距离起点最短的点加入到当前路径。然后用该点去更新其它未确定的点到起点的距离。</p><p>总结一下，Dijkstra算法的流程就是，不断取出<strong>离顶点最近</strong>而<strong>没有被访问过</strong>的点，松弛它和它能到达的所有点。</p><h4 id="朴素版dijkstraon2"><a class="markdownIt-Anchor" href="#朴素版dijkstraon2"></a> 朴素版Dijkstra(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">{O(n^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>))</h4><p>适用于<strong>稠密图</strong>，用邻接矩阵存储。</p><p><a href="https://www.acwing.com/problem/content/851/">AcWing849.Dijkstra求最短路 I</a></p><p>算法模板:</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 500 + 7;int graph[N][N];int dist[N];bool visited[N];int n, m;int Dijkstra() &#123;    &#x2F;&#x2F; 初始化距离    memset(dist, 0x3f, sizeof dist);    dist[1] &#x3D; 0;        for (int i &#x3D; 0; i &lt; n; i ++) &#123;        &#x2F;&#x2F; 初始化t为-1;        int t &#x3D; -1;                &#x2F;&#x2F; 选择t &#x3D; dist[j]最小的边        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++) &#123;            if(!visited[j] &amp;&amp; (t &#x3D;&#x3D; -1 || dist[t] &gt; dist[j])) &#123;                t &#x3D; j;            &#125;        &#125;        &#x2F;&#x2F; t加入已访问集合        visited[t] &#x3D; true;                &#x2F;&#x2F; 用t更新其它点到源点的距离        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++) &#123;            if(!visited[j]) &#123;                dist[j] &#x3D; min(dist[j], dist[t] + graph[t][j]);            &#125;        &#125;    &#125;        &#x2F;&#x2F; 4个0x3f    if (dist[n] &#x3D;&#x3D; 0x3f3f3f3f) return -1;        return dist[n];&#125;int main() &#123;        cin &gt;&gt; n &gt;&gt; m;        memset(graph, 0x3f, sizeof graph);    while (m --) &#123;        int u, v, d;        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;d);        &#x2F;&#x2F; 两点之间如果存在多条重边，只保留距离最短的那条        graph[u][v] &#x3D; min(graph[u][v], d);        &#x2F;&#x2F; 如果存在自环，其距离为正显然不用管    &#125;        int t &#x3D; Dijkstra();    cout &lt;&lt; t &lt;&lt; endl;        return 0;&#125;</code></pre><h4 id="堆优化版dijkstraomlogn"><a class="markdownIt-Anchor" href="#堆优化版dijkstraomlogn"></a> 堆优化版Dijkstra(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(mlog(n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>))</h4><p>适用于稀疏图，用邻接表存储。</p><p><strong>每次选取一个距离起点最短的点</strong>⇔<strong>多次取最小，然后删除当前最小</strong>⇔<strong>小根堆</strong></p><p>可以用手写堆或者优先队列的实现</p><ul><li><p>手写堆的时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(mlog(n))}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p></li><li><p>优先队列的时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(mlog(m))}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span>[但是m和n是同一个数量级，所以没关系]</p><blockquote><p>为什么是优先队列是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(mlog(m))}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span>？</p><pre class="language-c" data-language="c"><code class="language-c">&gt;if (dist[j] &gt; distance + w[i]) &#123;  &#x2F;&#x2F; 每当距离变小则入堆，因此最坏情况是递减的      dist[j] &#x3D; distance + w[i];      heap.push(&#123;dist[j], j&#125;);&gt;&#125;</code></pre></blockquote></li></ul><p><a href="https://www.acwing.com/problem/content/852/">AcWing850.Dijkstra求最短路 II</a></p><p>算法模板:</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;queue&gt;     &#x2F;&#x2F; priority_queue&lt;&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;   &#x2F;&#x2F; memset()#include &lt;algorithm&gt; using namespace std;&#x2F;&#x2F; &lt;距离, 节点编号&gt;typedef pair&lt;int, int&gt; PII;struct Edge&#123;    int to;    int w;    int nxt;&#125;;const int N &#x3D; 150000 + 7;const int M &#x3D; 150000 + 7;&#x2F;&#x2F; 邻接表存储图int head[N];Edge edge[M];int idx;&#x2F;&#x2F; 最短路记录int dist[N];bool visited[N];int n, m;inline void add(int from, int to, int w) &#123;    edge[idx].to &#x3D; to;    edge[idx].w &#x3D; w;    edge[idx].nxt &#x3D; head[from];    head[from] &#x3D; idx ++;&#125;int Heap_Dijkstra() &#123;    &#x2F;&#x2F; step1: 初始化距离    memset(dist, 0x3f, sizeof dist);    dist[1] &#x3D; 0;        &#x2F;&#x2F; 创建小根堆    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;    heap.push(&#123;0, 1&#125;);        while (!heap.empty()) &#123;        &#x2F;&#x2F; 取出队头        auto t &#x3D; heap.top(); heap.pop();                int ind &#x3D; t.second;        int distance &#x3D; t.first;   &#x2F;&#x2F; 其实distance &#x3D;&#x3D; dist[ind]        &#x2F;&#x2F; 跳过        if (visited[ind]) continue;        visited[ind] &#x3D; true;        &#x2F;&#x2F; 遍历队头结点，更新该节点指向的所有结点的dist[]        for (int i &#x3D; head[ind]; i !&#x3D; -1; i &#x3D; edge[i].nxt) &#123;            int j &#x3D; edge[i].to;            if (dist[j] &gt; distance + edge[i].w) &#123;                dist[j] &#x3D; distance + edge[i].w;                    &#x2F;&#x2F; 入堆 &#x2F;&#x2F; 这层if(!visited[j])可以不要                if (!visited[j]) &#123;                    heap.push(&#123;dist[j], j&#125;);                                   &#125;            &#125;        &#125;    &#125;        if (dist[n] &#x3D;&#x3D; 0x3f3f3f3f) return -1;        return dist[n];&#125;int main() &#123;    &#x2F;&#x2F; 初始化    memset(head, -1, sizeof head);        cin &gt;&gt; n &gt;&gt; m;    while (m --) &#123;        int u, v, w;        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);&#x2F;&#x2F; add        add (u, v, w);    &#125;    cout &lt;&lt; Heap_Dijkstra() &lt;&lt; endl;    return 0;&#125;</code></pre><hr /><h3 id="存在边权是负数"><a class="markdownIt-Anchor" href="#存在边权是负数"></a> 存在边权是负数</h3><h4 id="bellman-fordomn"><a class="markdownIt-Anchor" href="#bellman-fordomn"></a> Bellman-Ford(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(mn)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>))</h4><p><a href="https://www.acwing.com/problem/content/855/">AcWing853. 有边数限制的最短路</a></p><p><strong>普通版</strong></p><p>算法模板:</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct Edge&#123;    int u;    int v;    int w;&#125;;const int N &#x3D; 500 + 7;const int M &#x3D; 10000 + 7;&#x2F;&#x2F; 图Edge edge[M];int dist[N];int backup[N];  &#x2F;&#x2F; dist[]备份int n, m, k;int Bellman_Ford(int k) &#123;    &#x2F;&#x2F; 初始化距离    memset(dist, 0x3f, sizeof dist);    dist[1] &#x3D; 0;        for (int i &#x3D; 0; i &lt; k; i ++) &#123;        &#x2F;&#x2F; 备份        memcpy(backup, dist, sizeof dist);        &#x2F;&#x2F; 遍历图中所有边        for (int j &#x3D; 0; j &lt; m; j ++) &#123;            int u &#x3D; edge[j].u;            int v &#x3D; edge[j].v;            int w &#x3D; edge[j].w;                        &#x2F;&#x2F; 使用backup[]更新,而不是使用dist[]            dist[v] &#x3D; min(dist[v], backup[u] + w);        &#125;    &#125;        &#x2F;&#x2F; 存在负权边，使得dist[n]更新为小于INF的某个数    if (dist[n] &gt; 0x3f3f3f3f &#x2F; 2) return -1;        return dist[n];&#125;int main() &#123;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;        for (int i &#x3D; 0; i &lt; m; i ++) &#123;        int u, v, w;        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);        edge[i] &#x3D; &#123;u, v, w&#125;;    &#125;        int res &#x3D; Bellman_Ford(k);        if (dist[n] &gt; 0x3f3f3f3f &#x2F; 2) puts(&quot;impossible&quot;);    else cout &lt;&lt; res &lt;&lt; endl;            return 0;&#125;</code></pre><p><strong>链式前向星版</strong></p><p>我认为虽然该模板图的遍历循环难写一些，但是链式前向星这个结构更有通用性。</p><p>算法模板:</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct Edge&#123;    int to;    int w;    int nxt;&#125;;const int N &#x3D; 500 + 7;const int M &#x3D; 10000 + 7;&#x2F;&#x2F; 图int head[N];Edge edge[M];int idx;&#x2F;&#x2F; 最短路int dist[N];int backup[N];  &#x2F;&#x2F; dist[]备份int n, m, k;inline void add(int from, int to, int w) &#123;    edge[idx].to &#x3D; to;    edge[idx].w &#x3D; w;    edge[idx].nxt &#x3D; head[from];    head[from] &#x3D; idx ++;&#125;int Bellman_Ford(int k) &#123;    &#x2F;&#x2F; 初始化距离    memset(dist, 0x3f, sizeof dist);    dist[1] &#x3D; 0;         for (int e &#x3D; 0; e &lt; k; e ++) &#123;        &#x2F;&#x2F; 备份        memcpy(backup, dist, sizeof dist);        &#x2F;&#x2F; 遍历图中所有边        for (int t &#x3D; 1; t &lt;&#x3D; n; t ++) &#123;            for (int i &#x3D; head[t]; i !&#x3D; -1; i &#x3D; edge[i].nxt) &#123;                int j &#x3D; edge[i].to;                &#x2F;&#x2F; 使用backup[]更新,而不是使用dist[]                dist[j] &#x3D; min(dist[j], backup[t] + edge[i].w);            &#125;        &#125;    &#125;           &#x2F;&#x2F; 存在负权边    if (dist[n] &gt; 0x3f3f3f3f &#x2F; 2) return -1;        return dist[n];&#125;int main() &#123;    memset (head, -1, sizeof head);        cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;        while (m --)&#123;        int u, v, w;        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);        add(u, v, w);    &#125;        int res &#x3D; Bellman_Ford(k);        if (dist[n] &gt; 0x3f3f3f3f &#x2F; 2) puts(&quot;impossible&quot;);    else cout &lt;&lt; res &lt;&lt; endl;        return 0;&#125;</code></pre><h4 id="spfaom"><a class="markdownIt-Anchor" href="#spfaom"></a> SPFA(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(m)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></span>))</h4><p>长得很像Dijkstra，但是是队列优化版的Bellman-Ford</p><p>SPFA不但可以用来求最短路，还可以用来判断图中有无负环。</p><p><strong>SPFA求最短路</strong></p><p><a href="https://www.acwing.com/problem/content/853/">Acwing851. spfa求最短路</a></p><p>算法模板：</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;queue&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;&#x2F;&#x2F; typedef pair&lt;int, int&gt; PII;struct Edge&#123;    int to;    int w;    int nxt;&#125;;const int N &#x3D; 1e5 + 7;const int M &#x3D; 1e5 + 7;&#x2F;&#x2F; 图int head[N];Edge edge[M];int idx;&#x2F;&#x2F; 最短路int dist[N];bool inqueue[N];  &#x2F;&#x2F; visited[概念改变]int n, m;inline void add(int from, int to, int w) &#123;    edge[idx].to &#x3D; to;    edge[idx].w &#x3D; w;    edge[idx].nxt &#x3D; head[from];    head[from] &#x3D; idx ++;&#125;int SPFA() &#123;    memset(dist, 0x3f, sizeof dist);    dist[1] &#x3D; 0;    queue&lt;int&gt; que;    que.push(1);    inqueue[1] &#x3D; true;   &#x2F;&#x2F;存的是当前该点是否在队列当中，防止队列中存重复的点    while (!que.empty()) &#123;        &#x2F;&#x2F; 取出队头        int t &#x3D; que.front(); que.pop();        &#x2F;&#x2F; 标记不在队列中        inqueue[t] &#x3D; false;        for (int i &#x3D; head[t]; i !&#x3D; -1; i &#x3D; edge[i].nxt) &#123;            int j &#x3D; edge[i].to;            if (dist[j] &gt; dist[t] + edge[i].w) &#123;                dist[j] &#x3D; dist[t] + edge[i].w;                &#x2F;&#x2F; 不在队列中才加入                if (!inqueue[j]) &#123;                    que.push(j);                    inqueue[j] &#x3D; true;                &#125;            &#125;        &#125;    &#125;    if (dist[n] &#x3D;&#x3D; 0x3f3f3f3f) return -1;    return dist[n];&#125;int main() &#123;    &#x2F;&#x2F; 初始化head    memset(head, -1, sizeof head);    cin &gt;&gt; n &gt;&gt; m;    while (m --) &#123;        int u, v, w;        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);        add(u, v, w);    &#125;    int res &#x3D; SPFA();    if (dist[n] &#x3D;&#x3D; 0x3f3f3f3f) puts(&quot;impossible&quot;);    else cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;</code></pre><p><strong>SPFA判断负环</strong></p><p><a href="https://www.acwing.com/problem/content/854/">Acwing852. spfa判断负环</a></p><p>算法模板:</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;queue&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct Edge &#123;    int to;    int w;    int nxt;&#125;;const int N &#x3D; 2000 + 7;const int M &#x3D; 10000 + 7;&#x2F;&#x2F; 图int head[N];Edge edge[M];int idx;&#x2F;&#x2F; 最短路int dist[N];int cnt[N];  &#x2F;&#x2F; cnt[]记录dist[]更新次数bool inqueue[N];int n, m;inline void add(int from, int to, int w) &#123;    edge[idx].to &#x3D; to;    edge[idx].w &#x3D; w;    edge[idx].nxt &#x3D; head[from];    head[from] &#x3D; idx ++;&#125;bool SPFA() &#123;    memset(dist, 0x3f, sizeof dist);    dist[1] &#x3D; 0;        queue&lt;int&gt; que;    &#x2F;&#x2F; que.push(1);    &#x2F;&#x2F; inqueue[1] &#x3D; true;    &#x2F;&#x2F; 可能这个负环从源点1是到不了的，因此初始时要把所有点都放进que    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++) &#123;        que.push(i);        inqueue[i] &#x3D; true;    &#125;        while (!que.empty()) &#123;        int t &#x3D; que.front();        que.pop();                inqueue[t] &#x3D; false;                for (int i &#x3D; head[t]; i !&#x3D; -1; i &#x3D; edge[i].nxt) &#123;            int j &#x3D; edge[i].to;            if (dist[j] &gt; dist[t] + edge[i].w) &#123;                dist[j] &#x3D; dist[t] + edge[i].w;                cnt[j] &#x3D; cnt[t] + 1;                &#x2F;&#x2F; dist[]更新次数 &gt;&#x3D; n，说明存在负环                if (cnt [j] &gt;&#x3D; n) return true;                if (!inqueue[j]) &#123;                    que.push(j);                    inqueue[j] &#x3D; true;                &#125;            &#125;        &#125;    &#125;        return false;&#125;int main() &#123;    memset(head, -1, sizeof head);        cin &gt;&gt; n &gt;&gt; m;        while (m --) &#123;        int u, v, w;        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);        add(u, v, w);    &#125;        if(SPFA()) puts(&quot;Yes&quot;);    else puts(&quot;No&quot;);        return 0;&#125;</code></pre><h2 id="多源最短路"><a class="markdownIt-Anchor" href="#多源最短路"></a> 多源最短路</h2><h4 id="floydon3"><a class="markdownIt-Anchor" href="#floydon3"></a> Floyd(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(n^3)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>))</h4><p>Floyd算法本质上是一个<strong>动态规划</strong>的思想，每一次循环更新<strong>经过前k个节点，i到j的最短路径</strong>。</p><p>dist[k, i , j ]表示从点i开始，只经过1~k这些中间点，到点j的最短距离</p><p>这甚至不需要特意存图，因为dist数组本身就可以从邻接矩阵拓展而来。初始化的时候，我们把每个点<strong>到自己的距离</strong>设为0，每新增一条边，就把从这条边的起点到终点的距离设为此边的<strong>边权</strong>（类似于邻接矩阵）。其他距离初始化为<strong>INF</strong>（一个超过边权数据范围的大整数，注意防止溢出）。</p><p><a href="https://www.acwing.com/problem/content/856/">AcWing854.Floyd求最短路</a></p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 200 + 7;const int M &#x3D; 20000 + 7;const int INF &#x3D; 0x3f3f3f3f;int dist[N][N];int n, m;int Q; &#x2F;&#x2F; Q表示询问次数void Floyd() &#123;    for (int k &#x3D; 1; k &lt;&#x3D; n; k ++) &#123;        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++) &#123;            for (int j &#x3D; 1; j &lt;&#x3D; n; j ++) &#123;                dist[i][j] &#x3D; min(dist[i][j], dist[i][k] + dist[k][j]);            &#125;        &#125;    &#125;&#125;int main() &#123;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; Q;        &#x2F;&#x2F; 邻接矩阵初始化    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++) &#123;        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++) &#123;            if(i &#x3D;&#x3D; j) dist[i][j] &#x3D; 0;            else dist[i][j] &#x3D; INF;        &#125;    &#125;        while (m --) &#123;        int u, v, w;        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);        &#x2F;&#x2F; 通常只保留最短边        dist[u][v] &#x3D; min (dist[u][v], w);    &#125;         Floyd();        while (Q --) &#123;        int a, b;        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);        if (dist[a][b] &gt; INF &#x2F; 2) puts(&quot;impossible&quot;);        else printf(&quot;%d\n&quot;, dist[a][b]);    &#125;        return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0x60图论-(1)-图的存储与遍历</title>
    <link href="/2021/07/01/Algorithm/Template/20210701-0x60-%E5%9B%BE%E8%AE%BA-(1)-%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E9%81%8D%E5%8E%86/"/>
    <url>/2021/07/01/Algorithm/Template/20210701-0x60-%E5%9B%BE%E8%AE%BA-(1)-%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p>假设一张图中，n是点的数量， m是边的数量：</p><p>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>≈</mo><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">{m \approx n ^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>  ,可以认为该图是<strong>稠密图</strong>;<br />当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>≈</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">{m \approx n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.48312em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">n</span></span></span></span></span>    ,可以认为该图是<strong>稀疏图</strong>.</p><h4 id="邻接矩阵"><a class="markdownIt-Anchor" href="#邻接矩阵"></a> 邻接矩阵</h4><p>稠密图，适合用邻接矩阵存储。</p><pre class="language-c" data-language="c"><code class="language-c">const int N &#x3D; 1e5 + 7;&#x2F;&#x2F; const int M ;&#x2F;&#x2F; 图的定义(邻接矩阵)int graph[N][N];&#x2F;*add操作: u-&gt;v这条边的权重为w*&#x2F;inline void add (int u, v, w) &#123;    graph[u][v] &#x3D; w;&#125;</code></pre><h4 id="邻接表"><a class="markdownIt-Anchor" href="#邻接表"></a> 邻接表</h4><p>稀疏图，适合用邻接表存储。</p><p>链式前向星：<strong>用数组模拟邻接表</strong></p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;iostream&gt;#include &lt;cstring&gt;   &#x2F;&#x2F; memset()#include &lt;stdlib.h&gt;  &#x2F;&#x2F; rand()#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 1e5 + 7;const int M &#x3D; 1e5 + 7;struct Edge&#123;    int to;    int w;  &#x2F;&#x2F; 无权图，可以没有w或者w置为1    int nxt;&#125;;&#x2F;&#x2F; head节点int head[N];&#x2F;&#x2F; head展开的邻接表Edge edge[M];int idx;&#x2F;*add操作: from-&gt;to这条边的权重为w*&#x2F;inline void add(int from, int to, int w) &#123;    edge[idx].to &#x3D; to;    edge[idx].w &#x3D; w;    edge[idx].nxt &#x3D; head[from];    head[from] &#x3D; idx ++; &#125;int n, m;int main() &#123;&#x2F;&#x2F; 使用时需要初始化head[]为-1，表示head[]的nxt指针为NULL    memset(head, -1, sizeof head);        cin &gt;&gt; n &gt;&gt; m;        &#x2F;&#x2F; add    while (m --) &#123;        int u, v, w;        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);                add(u, v, w);               &#x2F;&#x2F; add(v, u, w) &#x2F;&#x2F; 无向图需要额外反着操作一次    &#125;        &#x2F;&#x2F; 图的遍历    for (int t &#x3D; 1; t &lt;&#x3D; n; t ++) &#123;        if (head[t] !&#x3D; -1) printf(&quot;%d: &quot;, t);        for (int i &#x3D; head[t]; i !&#x3D; -1; i &#x3D; edge[i].nxt) &#123;            printf(&quot;-&gt;%d(%d) &quot;, edge[i].to, edge[i].w);            &#x2F;&#x2F; 取j进行后续操作        int j &#x3D; edge[i].to;        &#125;        if (head[t] !&#x3D; -1) puts(&quot;&quot;);    &#125;        return 0;&#125;</code></pre><h3 id="图的深度优先遍历"><a class="markdownIt-Anchor" href="#图的深度优先遍历"></a> 图的深度优先遍历</h3><ul><li>树的重心</li></ul><h3 id="图的广度优先遍历"><a class="markdownIt-Anchor" href="#图的广度优先遍历"></a> 图的广度优先遍历</h3><ul><li>拓扑排序</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划-(1)-背包九讲</title>
    <link href="/2021/06/01/Algorithm/Template/20210601-0x50-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-(1)-%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/"/>
    <url>/2021/06/01/Algorithm/Template/20210601-0x50-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-(1)-%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<p>是全局最优解一定能够拆成子问题的最优解，并且子问题和全局问题是同一类型的问题，从而递推解决</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>更换GPU——重跑Mask-RCNN Demo</title>
    <link href="/2021/05/20/AI-Learning/20210520-%E4%BD%BF%E7%94%A8GPU%E8%B7%91MaskRCNN/"/>
    <url>/2021/05/20/AI-Learning/20210520-%E4%BD%BF%E7%94%A8GPU%E8%B7%91MaskRCNN/</url>
    
    <content type="html"><![CDATA[<h1 id="使用gpu跑mask-rcnn-demo"><a class="markdownIt-Anchor" href="#使用gpu跑mask-rcnn-demo"></a> 使用GPU跑Mask-RCNN Demo</h1><p>使用CPU跑深度学习当然没问题，但是随着深度学习往CV方向(计算机视觉)发展，需要计算机不断对图像进行处理，由此伴随着网络层数的加深，可能会让你的CPU会越来越力不从心！</p><p>而GPU(Graphics Processing Unit)就是为了处理图像而诞生的，因此这是GPU与生俱来的优势，</p><p>让我们通过以下这个短视频来体会一下CPU与GPU的区别吧</p><p>视频需要使用Dplayer视频插件，日后更新上来</p><p>OK，了解完GPU的强大之处后，就让我们把之前的Mask-RCNN项目换成GPU跑一遍吧！</p><p><strong>注</strong>: 本文以下内容：需要电脑至少有一块NVIDA(英伟达)GPU处理器才能顺利进行</p><p>本文Demo运行的外部环境: Win10(64bits) + Anaconda3(2020.11版) + GTX 1060 Max-Q</p><h2 id="cudacudnn"><a class="markdownIt-Anchor" href="#cudacudnn"></a> CUDA&amp;cuDNN</h2><p>CUDA(Compute Unified Device Architecture)，是显卡厂商NVIDIA推出的运算平台。</p><p>cuDNN(CUDA Deep Neural Network)是基于CUDA运算平台，用于深度神经网络的GPU加速库。</p><p>要想实现使用GPU运行Mask-RCNN Demo，必须先安装CUDA和cuDNN</p><h3 id="查看cuda版本支持"><a class="markdownIt-Anchor" href="#查看cuda版本支持"></a> 查看CUDA版本支持</h3><p>首先，来查看你电脑上能支持的CUDA的最高版本吧!</p><p><strong>Step1</strong>:打开cmd命令行窗口，输入<code>nvidia-smi</code>可以看到如下内容:</p><p><img src="/img/article/2021/05/20/1.png" alt="" /></p><p>圈起来的部分就是你的NVIDIA显卡所支持的CUDA版本，本文所使用的电脑最高支持CUDA11.1。</p><blockquote><p>如果输入<code>nvidia-smi</code>提示未找到命令，需要在环境变量Path中添加:</p><p>``C:\Program Files\NVIDIA Corporation\NVSMI`</p></blockquote><p>在后面的下载安装步骤中，首先需要保证 <strong>选择安装的cuda版本</strong> <strong>&lt;=</strong>  <strong>cmd内显示的支持版本</strong></p><p>并且你需要参考下图版本对应关系，保证CUDA、cuDNN、Python、tensorflow-gpu的版本一致性。</p><p><img src="/img/article/2021/05/20/2.png" alt="" /></p><blockquote><p>本文基于的环境配置版本为:</p><ul><li><p>tensorflow-gpu-1.5.0</p></li><li><p>python3.6</p></li><li><p>CUDA9.0</p></li><li><p>cuDNN7.0.5</p></li></ul></blockquote><h3 id="安装cuda"><a class="markdownIt-Anchor" href="#安装cuda"></a> 安装CUDA</h3><p><strong>CUDA已发布版本</strong> ：<a href="https://developer.nvidia.com/cuda-toolkit-archive">https://developer.nvidia.com/cuda-toolkit-archive</a></p><p>本文选择下载安装CUDA9.0(因为之前跑Demo时已经安装tensorflow-gpu-1.5.0了)</p><p>国内下载速度较慢，需要使用外网，如果你也选择安装CUDA9.0版本，可以选择从我的百度网盘中下载。</p><p><strong>Step1</strong>: 访问NVIDIA官网，选择下载CUDA9.0</p><p><img src="/img/article/2021/05/20/3.png" alt="" /></p><p><img src="/img/article/2021/05/20/4.png" alt="" /></p><p><img src="/img/article/2021/05/20/5.png" alt="" /></p><p><strong>Step2</strong>: 安装CUDA9.0</p><p>运行安装程序：</p><p><img src="/img/article/2021/05/20/6.png" alt="" /></p><p>选择自定义，然后勾选全部安装：</p><p><img src="/img/article/2021/05/20/7.png" alt="" /></p><p>安装位置推荐不要改动，就在C盘就行：</p><p><img src="/img/article/2021/05/20/8.png" alt="" /></p><p>这里还要求电脑安装过Visual Studio (2015/2017)，不然装不上nsight：</p><p>本文电脑已安装VS2017</p><p><img src="/img/article/2021/05/20/10.png" alt="" /></p><p>安装完成：</p><p><img src="/img/article/2021/05/20/9.png" alt="" /></p><h3 id="安装cudnn"><a class="markdownIt-Anchor" href="#安装cudnn"></a> 安装cuDNN</h3><p><strong>CUDNN历史版本</strong> ：<a href="https://developer.nvidia.com/rdp/cudnn-archive">https://developer.nvidia.com/rdp/cudnn-archive</a></p><p>本文选择下载安装cuDNN7.0.5(与CUDA9.0版本对应)</p><p>国内下载速度较慢，需要使用外网，如果你也选择安装cuDNN7.0.5版本，可以选择从我的百度网盘中下载。</p><p><strong>Step1</strong>: 访问NVIDIA官网，选择下载cuDNN9.0</p><p><img src="/img/article/2021/05/20/11.png" alt="" /></p><p>下载好cuDNN，解压，把对应文件夹中的东西复制进去即可。</p><h2 id="tensorflow-gpu"><a class="markdownIt-Anchor" href="#tensorflow-gpu"></a> Tensorflow-gpu</h2><p>如果你有参考我上一篇文章，并成功跑起了Demo，那么已经安装过tensorflow-gpu了</p><p>运行如下程序来简单测试是否正在使用GPU进行运算:</p><pre class="language-python" data-language="python"><code class="language-python">import os# os.environ[&#39;TF_CPP_MIN_LOG_LEVEL&#39;] &#x3D; &#39;2&#39;# 使用编号为0的GPUos.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] &#x3D; &#39;0&#39;import tensorflow as tffrom tensorflow.python.client import device_libprint(device_lib.list_local_devices())print(tf.test.gpu_device_name())sess&#x3D;tf.Session()a&#x3D;tf.constant(1)b&#x3D;tf.constant(3)print(sess.run(a+b))</code></pre><p>可能遇到的问题：</p><p>为什么Tensorflow还是使用的CPU而非GPU？</p><h2 id="demo运行"><a class="markdownIt-Anchor" href="#demo运行"></a> Demo运行</h2><h2 id="碰壁"><a class="markdownIt-Anchor" href="#碰壁"></a> 碰壁</h2><h3 id="为什么tensorflow还是使用的cpu而非gpu"><a class="markdownIt-Anchor" href="#为什么tensorflow还是使用的cpu而非gpu"></a> 为什么Tensorflow还是使用的CPU而非GPU</h3><p>如果你既安装了tensorflow，又安装了tensorflow-gpu，请保证tensorflow-gpu版本&gt;=tensorflow版本</p><p>最保险的方法，是把tensorflow和tensorflow-gpu都卸了，并只重新安装tensorflow-gpu</p><pre class="language-bash" data-language="bash"><code class="language-bash"># 卸载conda uninstall tensorflow&#x3D;&#x3D;1.5.0conda uninstall tensorflow-gpu&#x3D;&#x3D;1.5.0# 重新安装conda install tensorflow-gpu&#x3D;&#x3D;1.5.0</code></pre><p>然后再运行上面的测试.py试试。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>卷积神经网络</tag>
      
      <tag>计算机视觉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从0开始——跑起Mask-RCNN Demo</title>
    <link href="/2021/05/16/AI-Learning/20210516-%E4%BB%8E0%E5%BC%80%E5%A7%8BMaskRCNN/"/>
    <url>/2021/05/16/AI-Learning/20210516-%E4%BB%8E0%E5%BC%80%E5%A7%8BMaskRCNN/</url>
    
    <content type="html"><![CDATA[<h1 id="从0开始跑起mask-rcnn-demo"><a class="markdownIt-Anchor" href="#从0开始跑起mask-rcnn-demo"></a> 从0开始——跑起Mask-RCNN Demo</h1><p>本教程适用于0基础入门机器学习的Coder，阅读完之后你将能在你的电脑上跑起来Mask-RCNN官方的Demo噢！</p><p>俗话说: 再🐮的理论也要首先通过实践，把项目跑起来才是硬道理，代码可以之后慢慢研究！</p><p>基于以上原则，本教程:</p><ul><li>只专注于Demo运行的环境配置</li><li>不带有任何机器学习原理的代码原理讲解</li></ul><p>本文Demo运行的外部环境: Win10(64bits) + Anaconda3(2020.11版)</p><h2 id="maskrcnn"><a class="markdownIt-Anchor" href="#maskrcnn"></a> MaskRCNN</h2><h3 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h3><p>​   大名鼎鼎的 Mask RCNN 一举夺得 ICCV2017 Best Paper，名声大造。Mask RCNN 是何恺明基于以往的 Faster RCNN 架构提出的新的卷积网络，实现高效地检测图中的物体，并同时生成一张高质量的每个个体的分割掩码，即有效地目标的同时完成了高质量的语义分割。</p><p><img src="/img/article/2021/05/16/1.png" alt="" /></p><p><strong>论文地址</strong>:  <em><a href="https://arxiv.org/abs/1703.06870">https://arxiv.org/abs/1703.06870</a></em></p><h3 id="项目下载"><a class="markdownIt-Anchor" href="#项目下载"></a> 项目下载</h3><p><strong>项目开源地址</strong>: <em><a href="https://github.com/matterport/Mask_RCNN">https://github.com/matterport/Mask_RCNN</a></em></p><p>在开源地址的<a href="https://github.com/matterport/Mask_RCNN/releases">项目release发布页</a>内:</p><ul><li>Mask R-CNN 2.1中下载balloon_dataset.zip、mask_rcnn_balloon.h5、 Source code(zip/tar.gz)</li></ul><p><img src="/img/article/2021/05/16/2.png" alt="" /></p><ul><li>Mask R-CNN 2.0中下载mask_rcnn_coco.h5</li></ul><p><img src="/img/article/2021/05/16/3.png" alt="" /></p><p>本次教程需要用到的只有Source code和mask_rcnn_coco.h5，其他下载的文件在进一步学习中会用到。</p><p>下载完成后，解压Source code，然后将mask_rcnn_coco放在主目录下:</p><p><img src="/img/article/2021/05/16/4.png" alt="" /></p><p>完成以上步骤后就做好了项目前期准备，本文的目的就是要__让Demo.ipynb成功运行__</p><p><img src="/img/article/2021/05/16/target.png" alt="" /></p><h2 id="anacondapython环境配置"><a class="markdownIt-Anchor" href="#anacondapython环境配置"></a> Anaconda[Python环境配置]</h2><p><strong>Anaconda官网下载地址</strong>:  <em><a href="https://www.anaconda.com/products/individual#Downloads">https://www.anaconda.com/products/individual#Downloads</a></em></p><p>安装较为简单，这里不花笔墨叙述如何安装Anaconda，不会可以自行百度Anaconda安装教程。</p><blockquote><p><em>Q</em> :我已经安装了python了，安装Anaconda会有冲突么，需要卸载python再安装Anaconda么？</p><p><em>A</em> :不会冲突，放心安装。Anaconda可以与现有的python版本共存,只要二者都配置了环境变量即可。</p></blockquote><p>给Anaconda换国内源，可以解决下载缓慢的问题=&gt;<a href="#jump1">Conda换源</a></p><p><span color=red>[注]:</span>以下安装命令中所有环境和库的版本，最好与本文版本相同，以免出现不必要的麻烦。</p><h3 id="python虚拟环境"><a class="markdownIt-Anchor" href="#python虚拟环境"></a> Python虚拟环境</h3><p>安装好Anaconda，并配置好环境变量后，打开cmd或Anaconda Prompt。</p><p>进行以下操作:</p><p><strong>Step1</strong>:  创建python3.6版本的虚拟环境</p><pre class="language-bash" data-language="bash"><code class="language-bash">conda create -n &#96;[虚拟环境名]&#96; python&#x3D;3.6</code></pre><p>弹出(y/n)时，输入y即可。</p><p><strong>Step2</strong>:  虚拟环境基础操作命令</p><p><code>激活虚拟环境</code>:</p><pre class="language-bash" data-language="bash"><code class="language-bash">activate &#96;[虚拟环境名]&#96;</code></pre><p><code>退出虚拟环境</code>:</p><pre class="language-none"><code class="language-none">deactivate</code></pre><p><code>删除虚拟环境</code>:</p><pre class="language-bash" data-language="bash"><code class="language-bash">conda remove -n &#96;[虚拟环境]&#96;</code></pre><p>激活了虚拟环境后，使用conda/pip的安装命令只会给虚拟环境envs安装；</p><p>如果出现错误，可以选择直接删掉虚拟环境重来。</p><h3 id="jupyter-notebook配置"><a class="markdownIt-Anchor" href="#jupyter-notebook配置"></a> Jupyter Notebook配置</h3><p>一般使用Anaconda创建的python虚拟环境自带Jupyter Notebook，使用以下命令打开:</p><pre class="language-bash" data-language="bash"><code class="language-bash">jupyter notebook</code></pre><p>但自带的会有不完善的地方，这里补全。</p><p><strong>Step1</strong>: 安装nb_conda使Jupyter Notebook能够切换虚拟环境</p><pre class="language-none"><code class="language-none">conda install nb_conda</code></pre><p>安装后打开jupyter notebook 可以看到Conda插件，并显示环境，如下图:</p><p>[笔者的电脑上有root(基础python)、Anaconda2020.11(Anaconda自带)、python3.6(虚拟环境envs))三种环境]</p><p><img src="/img/article/2021/05/16/5.png" alt="" /></p><p>此处可能出现的相关错误:</p><p><a href="#jump2">打开jupyter notebook后，出现Dead Kenel</a></p><p><em>The kernel has died,and the automatic restart has failed.</em></p><p><img src="/img/article/2021/05/16/6.png" alt="" /></p><p>Jupyter NoteBook如果出现问题，一定要看看控制台cmd报了什么错误，根据该错误网上搜索解决</p><h3 id="python库安装"><a class="markdownIt-Anchor" href="#python库安装"></a> Python库安装</h3><p><strong>Step1</strong>: 根据github上Mask-RCNN的ReadMe，要安装requirements.txt中的python库</p><p><img src="/img/article/2021/05/16/7.png" alt="" /></p><p>然而各种库版本不对很容易导致各种问题，四处碰壁。这里推荐按本文的requirements.txt配置</p><p><img src="/img/article/2021/05/16/8.png" alt="" /></p><p>可以点击这里直接下载:<a href="/load/requirements.txt">requirements.txt</a></p><p>编辑好requirements.txt后，然后使用以下命令安装</p><pre class="language-bash" data-language="bash"><code class="language-bash">pip install -r requirements.txt</code></pre><p>如果不按本文中的requirements.txt配置，请注意<a href="https://www.cnblogs.com/carle-09/p/11661261.html">Tensorflow和Keras版本对应</a></p><p><strong>Step2</strong>: <span id="jump6">安装coco库</span></p><p>该步骤需要区分Window系统和Linux系统安装</p><p><strong>Windows</strong> :</p><pre class="language-bash" data-language="bash"><code class="language-bash">pip install pycocotools-windows</code></pre><p><strong>Linux</strong> :</p><p>【需要Linux已安装C语言编译器如cmaker】</p><p>方法1:</p><pre class="language-bash" data-language="bash"><code class="language-bash">pip install git+https:&#x2F;&#x2F;github.com&#x2F;waleedka&#x2F;cocoapi.git#egg&#x3D;pycocotools&amp;subdirectory&#x3D;PythonAPI</code></pre><p>方法2:</p><pre class="language-bash" data-language="bash"><code class="language-bash">git clone https:&#x2F;&#x2F;github.com&#x2F;waleedka&#x2F;coco.gitcd coco&#x2F;PythonAPImakesudo make installsudo python setup.py install</code></pre><h2 id="demo运行"><a class="markdownIt-Anchor" href="#demo运行"></a> Demo运行</h2><p><strong>Step1</strong>: cmd打开jupyter notebook</p><pre class="language-bash" data-language="bash"><code class="language-bash">jupyter notebook</code></pre><p><img src="/img/article/2021/05/16/9.png" alt="" /></p><p><strong>Step2</strong>: 打开项目目录下的demo.ipynb，并切换Kenel为你的python3.6虚拟环境</p><p><img src="/img/article/2021/05/16/10.png" alt="" /></p><p><strong>Step3</strong>: 一路<code>Shift</code>+<code>Enter</code>，即可</p><p>Import库时看到如下图，则说明没问题:</p><p><img src="/img/article/2021/05/16/11.png" alt="" /></p><p>最后Run Object  Detection时，首先会看到数据:</p><p><img src="/img/article/2021/05/16/12.png" alt="" /></p><p>等待一会儿会出现训练测试图片:</p><p><img src="/img/article/2021/05/16/13.png" alt="" /></p><p>如果以上步骤完美运行，那么恭喜你，成功跑起来了Mask-RCNN的Demo！</p><p>此处可能出现的相关错误:</p><ol><li><p><a href="#jump3">ImportError: No module named ‘pycocotools’</a></p></li><li><p><a href="#jump4">AttributeError: ‘str’ object has no attribute ‘decode’</a></p></li><li><p><a href="#jump5">AttributeError:module ‘cipy.misc’ has no attribute ‘imresize’</a></p></li></ol><h2 id="碰壁"><a class="markdownIt-Anchor" href="#碰壁"></a> 碰壁</h2><h3 id="span-idjump1conda-换源span"><a class="markdownIt-Anchor" href="#span-idjump1conda-换源span"></a> <span id="jump1">Conda 换源</span></h3><p><strong>清华源</strong></p><pre class="language-bash" data-language="bash"><code class="language-bash">conda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;free&#x2F;conda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud&#x2F;conda-forge conda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud&#x2F;msys2&#x2F;# 设置搜索时显示通道地址conda config --set show_channel_urls yes</code></pre><p><strong>中科大源</strong></p><pre class="language-bash" data-language="bash"><code class="language-bash">conda config --add channels https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;main&#x2F;conda config --add channels https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;free&#x2F;conda config --add channels https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;anaconda&#x2F;cloud&#x2F;conda-forge&#x2F;conda config --add channels https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;anaconda&#x2F;cloud&#x2F;msys2&#x2F;conda config --add channels https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;anaconda&#x2F;cloud&#x2F;bioconda&#x2F;conda config --add channels https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;anaconda&#x2F;cloud&#x2F;menpo&#x2F;# 设置搜索时显示通道地址conda config --set show_channel_urls yes</code></pre><h3 id="span-idjump2jupyter-notebook配置相关span"><a class="markdownIt-Anchor" href="#span-idjump2jupyter-notebook配置相关span"></a> <span id="jump2">Jupyter Notebook配置相关</span></h3><p><span style="font-weight:bold;">Dead Kenel内核死亡[ImportError: cannot import name ‘generator_to_async_generator’]</span></p><p>该内核死亡原因，查看cmd，抛出以下错误:</p><pre class="language-bash" data-language="bash"><code class="language-bash">ImportError: cannot import name &#39;generator_to_async_generator&#39;</code></pre><p><strong>解决方法</strong>:  <a href="https://github.com/ipython/ipython/issues/11270">参考网页</a></p><p>先执行<code>2</code>次，完全卸载ipython 和 prompt_toolkit</p><pre class="language-bash" data-language="bash"><code class="language-bash">pip uninstall -y ipython prompt_toolkit</code></pre><p>再重新安装ipython prompt_toolkit</p><pre class="language-none"><code class="language-none">pip install ipython prompt_toolkit</code></pre><p><strong>[AttributeError: module ‘<a href="http://dateutil.tz">dateutil.tz</a>’ has no attribute ‘UTC’]</strong></p><p>该错误不容易发现，在jupyer notebook中表现为运行无反应。查看cmd，抛出以下错误:</p><pre class="language-bash" data-language="bash"><code class="language-bash">AttributeError: module &#39;dateutil.tz&#39; has no attribute &#39;UTC&#39;</code></pre><p><strong>解决方法:</strong> <a href="https://stackoverflow.com/questions/60929286/attributeerror-module-dateutil-tz-has-no-attribute-utc-on-zappa-deploy">参考网页</a></p><p>重新强制安装python-dateutil</p><pre class="language-bash" data-language="bash"><code class="language-bash">pip install python-dateutil --upgrade --force</code></pre><h3 id="demo运行相关"><a class="markdownIt-Anchor" href="#demo运行相关"></a> Demo运行相关</h3><p><span id="jump3" style="font-weight:bold;">[ImportError: No module named ‘pycocotools’]</span></p><p>问题原因: coco库没有成功安装</p><p>解决方法: <a href="#jump6">安装coco库</a></p><p><span id="jump4" style="font-weight:bold;">[AttributeError: ‘str’ object has no attribute ‘decode’]</span></p><p>问题原因: h5py的版本过高，大于了3.0</p><p>解决方法: <a href="https://github.com/keras-team/keras/issues/14265">参考网页</a></p><pre class="language-bash" data-language="bash"><code class="language-bash">pip install h5py&#x3D;&#x3D;2.10.0</code></pre><p><img src="/img/article/2021/05/16/14.png" alt="" /></p><p>安装时要关闭jupyter notebook以防止 h5py文件夹被占用，无法写入h5py2.10.0进行覆盖</p><p><span id="jump5" style="font-weight:bold;">[AttributeError:module ‘scipy.misc’ has no attribute ‘imresize’]</span></p><p>问题原因: scipy的版本过高</p><p>解决方法: <a href="https://stackoverflow.com/questions/56204985/how-to-fix-scipy-misc-has-no-attribute-imresize">参考网页</a></p><pre class="language-bash" data-language="bash"><code class="language-bash">pip install scipy&#x3D;&#x3D;1.2.2</code></pre><p><img src="/img/article/2021/05/16/15.png" alt="" /></p><p>安装时要关闭jupyter notebook以防止 scipy文件夹被占用，无法写入scipy1.2.2进行覆盖</p><p>至此，本文结束，感谢阅读！</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>卷积神经网络</tag>
      
      <tag>计算机视觉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进阶数据结构-(7)-Chtholly Tree</title>
    <link href="/2021/05/07/Algorithm/Template/20210507-0x40-%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-(7)-Chtholly%20Tree/"/>
    <url>/2021/05/07/Algorithm/Template/20210507-0x40-%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-(7)-Chtholly%20Tree/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进阶数据结构-(6)-可持久化数据结构</title>
    <link href="/2021/05/06/Algorithm/Template/20210506-0x40-%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-(6)-%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2021/05/06/Algorithm/Template/20210506-0x40-%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-(6)-%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进阶数据结构-(5)-平衡树</title>
    <link href="/2021/05/05/Algorithm/Template/20210505-0x40-%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-(5)-%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    <url>/2021/05/05/Algorithm/Template/20210505-0x40-%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-(5)-%E5%B9%B3%E8%A1%A1%E6%A0%91/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进阶数据结构-(4)-线段树</title>
    <link href="/2021/05/04/Algorithm/Template/20210504-0x40-%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-(4)-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2021/05/04/Algorithm/Template/20210504-0x40-%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-(4)-%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进阶数据结构-(3)-树状数组</title>
    <link href="/2021/05/03/Algorithm/Template/20210503-0x40-%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-(3)-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <url>/2021/05/03/Algorithm/Template/20210503-0x40-%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-(3)-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p>可以参考的资料</p><p>求逆序对</p><p><a href="https://www.acwing.com/solution/content/2266/">https://www.acwing.com/solution/content/2266/</a></p><p><a href="https://blog.csdn.net/bestsort/article/details/80796531">https://blog.csdn.net/bestsort/article/details/80796531</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进阶数据结构-(2)-ST表</title>
    <link href="/2021/05/02/Algorithm/Template/20210502-0x40-%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-(2)-ST%E8%A1%A8/"/>
    <url>/2021/05/02/Algorithm/Template/20210502-0x40-%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-(2)-ST%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进阶数据结构-(1)-并查集</title>
    <link href="/2021/05/01/Algorithm/Template/20210501-0x40-%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-(1)-%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2021/05/01/Algorithm/Template/20210501-0x40-%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-(1)-%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>推荐参考的题目:</p><p><a href="https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths/">https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths/</a></p><p><a href="https://leetcode.cn/problems/maximum-number-of-points-from-grid-queries/">https://leetcode.cn/problems/maximum-number-of-points-from-grid-queries/</a></p><p>iota函数，用于产生连续的值，定义在<code>numeric</code>头文件中。</p><p>个人初步使用的并查集模板，没有加入权重，或者是统计集合的size，等之后做到这类更难的题目再附加</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;numeric&gt;using namespace std;class UnionFind&#123;    vector&lt;int&gt; fa;public:    UnionFind(int n): fa(n) &#123;        &#x2F;&#x2F; iota函数可以把数组初始化为0到n-1        iota(fa.begin(), fa.end(), 0);    &#125;    &#x2F;&#x2F; 查找fa    int find(int x) &#123;        if (x !&#x3D; fa[x]) fa[x] &#x3D; find(fa[x]);        return fa[x];    &#125;    &#x2F;&#x2F; 合并    void unite(int x, int y) &#123;        x &#x3D; find(x);        y &#x3D; find(y);        fa[x] &#x3D; y;    &#125;    &#x2F;&#x2F; 是否连通    bool is_connect(int x, int y) &#123;        x &#x3D; find(x);        y &#x3D; find(y);        return x &#x3D;&#x3D; y;    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搜索-(3)-记忆化搜索</title>
    <link href="/2021/04/03/Algorithm/Template/20210403-0x30-%E6%90%9C%E7%B4%A2-(3)-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    <url>/2021/04/03/Algorithm/Template/20210403-0x30-%E6%90%9C%E7%B4%A2-(3)-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搜索-(2)-广度优先搜索</title>
    <link href="/2021/04/02/Algorithm/Template/20210402-0x30-%E6%90%9C%E7%B4%A2-(2)-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <url>/2021/04/02/Algorithm/Template/20210402-0x30-%E6%90%9C%E7%B4%A2-(2)-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<p>广搜</p><p>广搜变形</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搜索-(1)-深度优先搜索</title>
    <link href="/2021/04/01/Algorithm/Template/20210401-0x30-%E6%90%9C%E7%B4%A2-(1)-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <url>/2021/04/01/Algorithm/Template/20210401-0x30-%E6%90%9C%E7%B4%A2-(1)-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串-(5)-AC自动机</title>
    <link href="/2021/03/05/Algorithm/Template/20210305-0x20-%E5%AD%97%E7%AC%A6%E4%B8%B2-(5)-AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <url>/2021/03/05/Algorithm/Template/20210305-0x20-%E5%AD%97%E7%AC%A6%E4%B8%B2-(5)-AC%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串-(4)-Trie树</title>
    <link href="/2021/03/04/Algorithm/Template/20210304-0x20-%E5%AD%97%E7%AC%A6%E4%B8%B2-(4)-Trie%E6%A0%91/"/>
    <url>/2021/03/04/Algorithm/Template/20210304-0x20-%E5%AD%97%E7%AC%A6%E4%B8%B2-(4)-Trie%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="trie树"><a class="markdownIt-Anchor" href="#trie树"></a> Trie树</h2><h3 id="静态实现"><a class="markdownIt-Anchor" href="#静态实现"></a> 静态实现</h3><pre class="language-c" data-language="c"><code class="language-c">#include &lt;iostream&gt;using namespace std;const int N &#x3D; 1e5 + 10;int son[N][26];int cnt[N];     &#x2F;&#x2F; 以当前结点结尾的单词有多少个int idx &#x3D; 1;    &#x2F;&#x2F; 当前用到了哪个下标， 下标是0的点，既是根结点，又是空结点char str[N];&#x2F;&#x2F; 插入一个字符串void insert(char str[])&#123;    int p &#x3D; 0;    &#x2F;&#x2F; C++ char字符串结尾是\0，所以str[i]可以直接判断有没有到结尾    for (int i &#x3D; 0; str[i]; i ++) &#123;int u &#x3D; str[i] - &#39;a&#39;; &#x2F;&#x2F;把小写字母映射成数字，方便int型Trie存储        if (!son[p][u]) son[p][u] &#x3D; idx ++;        p &#x3D; son[p][u];    &#125;        cnt[p] ++; &#125;&#x2F;&#x2F; 查询当前字符串的个数int query(char str[])&#123;    int p &#x3D; 0;        for (int i &#x3D; 0; str[i]; i ++) &#123;        int u &#x3D; str[i] - &#39;a&#39;;        if(!son[p][u]) return 0;        p &#x3D; son[p][u];    &#125;        return cnt[p];&#125;int main() &#123;    int n;    cin &gt;&gt; n;        while (n --) &#123;        char op[2];        scanf(&quot;%s%s&quot;, op, str); &#x2F;&#x2F; 注意这里不需要地址，因为是头指针        if (op[0] &#x3D;&#x3D; &#39;I&#39;) insert(str);        else if (op[0] &#x3D;&#x3D; &#39;Q&#39;) printf(&quot;%d\n&quot;,query(str));    &#125;        return 0;&#125;</code></pre><h3 id="动态实现"><a class="markdownIt-Anchor" href="#动态实现"></a> 动态实现</h3><pre class="language-c" data-language="c"><code class="language-c">#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct Trie &#123;    vector&lt;Trie*&gt; son;    int cnt;    Trie() &#123;        &#x2F;&#x2F; 初始化只能放在构造函数中        son.resize(26);        cnt &#x3D; 0;    &#125;&#125;;const int N &#x3D; 20000 + 7;Trie* root &#x3D; new Trie();int n;&#x2F;&#x2F; insert操作void insert(string&amp; s) &#123;    Trie*p &#x3D; root;    for (auto&amp; c: s) &#123;        int t &#x3D; c - &#39;a&#39;;        if (!p-&gt;son[t]) &#123;            p-&gt;son[t] &#x3D; new Trie();        &#125;        p &#x3D; p-&gt;son[t];    &#125;        p-&gt;cnt ++;&#125;&#x2F;&#x2F; query操作int query(string&amp; s) &#123;    Trie* p &#x3D; root;    for (auto&amp; c : s) &#123;        int t &#x3D; c - &#39;a&#39;;        if (!p-&gt;son[t]) &#123;            return 0;        &#125;        p &#x3D; p-&gt;son[t];    &#125;        return p-&gt;cnt;&#125;int main() &#123;    cin &gt;&gt; n;        for (int i &#x3D; 0; i &lt; n; i ++) &#123;        char op[2];        string s;                scanf(&quot;%s&quot;, op);        cin &gt;&gt; s;                if (op[0] &#x3D;&#x3D; &#39;I&#39;) insert(s);        else if (op[0] &#x3D;&#x3D; &#39;Q&#39;) printf(&quot;%d\n&quot;, query(s));    &#125;        return 0;&#125;</code></pre><h3 id="应用"><a class="markdownIt-Anchor" href="#应用"></a> 应用</h3><p><a href="https://leetcode.cn/problems/number-of-matching-subsequences/description/">Leetcode-792.匹配子序列的单词数</a></p><pre class="language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; query_dfs&#x2F;&#x2F; 枚举字典树每一层的可行路径 去匹配s, 而非去对s进行dfsvoid query_dfs(Trie* p,string&amp; s,int pos)&#123;    &#x2F;&#x2F; 当前位置存在结尾if (p-&gt;cnt) &#123;        ans +&#x3D; p-&gt;cnt;        p-&gt;cnt &#x3D; 0; &#x2F;&#x2F; 置0十分重要，避免重复计算    &#125;    for (int i &#x3D; 0; i &lt; 26; i ++) &#123;        &#x2F;&#x2F; 存在子节点        if (p-&gt;son[i]) &#123;            &#x2F;&#x2F; 可以看作pos ~ next_pos之间的全失效            int next_pos &#x3D; s.find_first_of(&#39;a&#39; + i, pos);            if (next_pos !&#x3D; string::npos) &#123;                query_dfs(p-&gt;son[i], s, next_pos + 1);            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串-(3)-Manacher</title>
    <link href="/2021/03/03/Algorithm/Template/20210303-0x20-%E5%AD%97%E7%AC%A6%E4%B8%B2-(3)-Manacher/"/>
    <url>/2021/03/03/Algorithm/Template/20210303-0x20-%E5%AD%97%E7%AC%A6%E4%B8%B2-(3)-Manacher/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串-(2)-KMP</title>
    <link href="/2021/03/02/Algorithm/Template/20210302-0x20-%E5%AD%97%E7%AC%A6%E4%B8%B2-(2)-KMP/"/>
    <url>/2021/03/02/Algorithm/Template/20210302-0x20-%E5%AD%97%E7%AC%A6%E4%B8%B2-(2)-KMP/</url>
    
    <content type="html"><![CDATA[<p>KMP算法用于<strong>字符串匹配</strong>优化</p><p>假设主串S长度为n， 模式串P长度为m</p><p>暴力做法，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(n * m)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></span></p><pre class="language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 暴力做法 for (int i &#x3D; 1; i &lt;&#x3D; n; i ++) &#123;bool flag &#x3D; true;for (int j &#x3D; 1; j &lt;&#x3D; m; j ++) &#123;        &#x2F;&#x2F; 匹配if (s[i + j - 1] !&#x3D; p[j]) &#123;flag &#x3D; false;            break;&#125;&#125;&#125; </code></pre><p>kmp算法的思想是去预处理模板串 nxt[i] = j</p><p>nxt[i] = j记录的就是当前以i作为后缀末位时，j对应的前缀末位的位置，有使得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mo>=</mo><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">{p[1, j] == p[i - j + 1, i]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span></span>，这两段前后缀字符串相等，并且不难发现j就是模式串可移动的长度。</p><h3 id="kmp模板"><a class="markdownIt-Anchor" href="#kmp模板"></a> KMP模板</h3><pre class="language-c" data-language="c"><code class="language-c">#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; res;void kmp(string &amp;s, string &amp;p) &#123;    int n &#x3D; s.size(), m &#x3D; p.size();        if (n &lt; m) return;    &#x2F;&#x2F; 对模式串自身求nxt[]数组的过程    vector&lt;int&gt; nxt(m);    nxt[0] &#x3D; -1;    for (int i &#x3D; 1, j &#x3D; -1; i &lt; m; i ++) &#123;        while (~j &amp;&amp; p[i] !&#x3D; p[j + 1]) j &#x3D; nxt[j];        if (p[i] &#x3D;&#x3D; p[j + 1]) j ++;        nxt[i] &#x3D; j;    &#125;    &#x2F;&#x2F; kmp匹配过程    for (int i &#x3D; 0, j &#x3D; -1; i &lt; n; i ++) &#123;        while (~j &amp;&amp; s[i] !&#x3D; p[j + 1]) j &#x3D; nxt[j];        if (s[i] &#x3D;&#x3D; p[j + 1]) j ++;        if (j &#x3D;&#x3D; m - 1) &#123;            &#x2F;&#x2F; 匹配成功            res.emplace_back(i - m + 1);  &#x2F;&#x2F; 匹配成功时，在主串的起始位置            j &#x3D; nxt[j];        &#125;    &#125;    return;&#125;int main() &#123;    string s; &#x2F;&#x2F; 主串    string p; &#x2F;&#x2F; 模式串    cin &gt;&gt; s &gt;&gt; p;    kmp(s, p);    for(auto r : res) printf(&quot;%d &quot;, r);    return 0;&#125;</code></pre><h3 id="时间复杂度"><a class="markdownIt-Anchor" href="#时间复杂度"></a> 时间复杂度</h3><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>2</mn><mi>m</mi><mo>+</mo><mn>2</mn><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2m + 2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> ，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m + n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><p><strong>分析</strong>:</p><p>对于求nxt数组的过程</p><p>外层for循环每当i++，j最多跟着一起++; j最多 + m次;</p><p>内层while循环，j 肯定是 &gt;= 0的，j最大为m，所以也最多要 - m次;   因此while循环整个过程最多执行m次</p><p>对于kmp匹配的过程，同理</p><p>外层for循环每当i++，j最多跟着一起++; j最多 + n次;</p><p>内层while循环，j 肯定是 &gt;= 0的，j最大为n，所以也最多要 - n次;   因此while循环整个过程最多执行n次</p><p>所以总共是2m + 2n</p><p><strong>练习eg:</strong></p><p><a href="https://www.acwing.com/problem/content/description/833/">ACwing-831.KMP字符串</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串-(1)-字符串hash</title>
    <link href="/2021/03/01/Algorithm/Template/20210301-0x20-%E5%AD%97%E7%AC%A6%E4%B8%B2-(1)-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"/>
    <url>/2021/03/01/Algorithm/Template/20210301-0x20-%E5%AD%97%E7%AC%A6%E4%B8%B2-(1)-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础数据结构-(5)-Hash</title>
    <link href="/2021/02/05/Algorithm/Template/20210205-0x10-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-(5)-Hash/"/>
    <url>/2021/02/05/Algorithm/Template/20210205-0x10-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-(5)-Hash/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础数据结构-(4)-二叉堆</title>
    <link href="/2021/02/04/Algorithm/Template/20210204-0x10-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-(4)-%E5%A0%86/"/>
    <url>/2021/02/04/Algorithm/Template/20210204-0x10-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-(4)-%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<p>小根堆和大根堆</p><h4 id="对顶堆求动态中位数"><a class="markdownIt-Anchor" href="#对顶堆求动态中位数"></a> 对顶堆求动态中位数</h4><p><a href="https://www.acwing.com/problem/content/108/">https://www.acwing.com/problem/content/108/</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础数据结构-(3)-队列</title>
    <link href="/2021/02/03/Algorithm/Template/20210203-0x10-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-(3)-%E9%98%9F%E5%88%97/"/>
    <url>/2021/02/03/Algorithm/Template/20210203-0x10-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-(3)-%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>普通队列queue</p><p>双端队列deque</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础数据结构-(2)-栈</title>
    <link href="/2021/02/02/Algorithm/Template/20210202-0x10-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-(2)-%E6%A0%88/"/>
    <url>/2021/02/02/Algorithm/Template/20210202-0x10-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-(2)-%E6%A0%88/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础数据结构-(1)-链表</title>
    <link href="/2021/02/01/Algorithm/Template/20210201-0x10-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-(1)-%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/02/01/Algorithm/Template/20210201-0x10-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-(1)-%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="leetcode上的链表"><a class="markdownIt-Anchor" href="#leetcode上的链表"></a> LeetCode上的链表</h3><p>这种专门考动态链表本身的操作基本上只出现在工作面试和leetcode比赛中，一般在其它比赛中不太常见。</p><h4 id="链表定义"><a class="markdownIt-Anchor" href="#链表定义"></a> 链表定义</h4><pre class="language-c" data-language="c"><code class="language-c">struct ListNode &#123;    int val;    ListNode *next;    ListNode() : val(0), next(nullptr) &#123;&#125;    ListNode(int x) : val(x), next(nullptr) &#123;&#125;    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;&#125;;</code></pre><p>主要要熟练掌握链表的<strong>递归</strong>和<strong>迭代</strong>操作。</p><h4 id="反转链表"><a class="markdownIt-Anchor" href="#反转链表"></a> 反转链表</h4><p><a href="https://leetcode.cn/problems/reverse-linked-list/">反转链表I</a></p><pre class="language-c" data-language="c"><code class="language-c">class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        ListNode* pre &#x3D; NULL;        ListNode* cur &#x3D; head;                while (cur !&#x3D; NULL) &#123;            ListNode* nxt &#x3D; cur-&gt;next;            cur-&gt;next &#x3D; pre;            pre &#x3D; cur;            cur &#x3D; nxt;        &#125;        return pre;    &#125;&#125;;</code></pre><p><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">反转链表II</a></p><pre class="language-c" data-language="c"><code class="language-c">class Solution &#123;public:    ListNode* reverseBetween(ListNode* head, int left, int right) &#123;        ListNode* dummy_head &#x3D; new ListNode(-1, head);        ListNode* p &#x3D; dummy_head;        int i &#x3D; 1;        while (i &lt; left) &#123;            p &#x3D; p-&gt;next;            i ++;        &#125;        ListNode* pre &#x3D; p;        ListNode* cur &#x3D; p-&gt;next;        while (left &lt;&#x3D; i &amp;&amp; i &lt;&#x3D; right) &#123;            ListNode* nxt &#x3D; cur-&gt;next;            cur-&gt;next &#x3D; pre;            pre &#x3D; cur;            cur &#x3D; nxt;            i ++;        &#125;                p-&gt;next-&gt;next &#x3D; cur;        p-&gt;next &#x3D; pre;        return dummy_head-&gt;next;    &#125;&#125;;</code></pre><p>邻接表主要应用于</p><ol><li>树与图的存储</li><li>hash表的拉链法存储</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0x00-基础算法-(5)-贪心</title>
    <link href="/2021/01/05/Algorithm/Template/20210105-0x00-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95(5)-%E8%B4%AA%E5%BF%83/"/>
    <url>/2021/01/05/Algorithm/Template/20210105-0x00-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95(5)-%E8%B4%AA%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h2 id="贪心算法"><a class="markdownIt-Anchor" href="#贪心算法"></a> 贪心算法</h2><p>贪心算法（greedy algorithm），是用计算机来模拟一个「贪心」的人做出决策的过程。这个人十分贪婪，每一步行动总是按某种指标选取最优的操作。而且他目光短浅，总是只看眼前，并不考虑以后可能造成的影响。</p><p>可想而知，并不是任何时候贪心法都能获得最优解，所以一般使用贪心法的时候，都要确保自己能证明其正确性（通常用反证法或数学归纳法证明）。</p><blockquote><p>贪心类问题无疑是基础算法中难度最大的，难点在于思维的跳跃性，没有固定的解题模式，往往是一类题一种解法或结论。</p></blockquote><p>总而言之：贪心是指每次找局部最优解，就可以找到全局最优解，所以贪心一般要求函数是单峰的。动态规划的限制会少一些，一般是枚举了空间中的所有值，找出了最优解。这两个算法一般是从经验出发来判断，所以要多做题。</p><p>下面介绍一些常见的贪心问题以及其对应的启发式策略。</p><h3 id="区间问题"><a class="markdownIt-Anchor" href="#区间问题"></a> 区间问题</h3><p>区间问题最重要的其实不是选择按左端点还是右端点排序【因为按左端点排序和按右端点排序的解法可以相互转换】，而是排序后，应该优先考虑包含区间还是被包含区间，这才是本质问题。</p><p>最少覆盖区间点数和最大不相交区间数，要优先考虑被包含区间。</p><p>区间合并、区间分组、区间覆盖，要优先考虑可以包含区间。</p><h4 id="最少覆盖区间点数"><a class="markdownIt-Anchor" href="#最少覆盖区间点数"></a> 最少覆盖区间点数</h4><p>数轴上有若干区间，在数轴上选点，使得每个区间内至少包含一个点，求选择的点的最小数量。</p><blockquote><p>贪心策略：</p><p>Step1: 区间按左端点从小到大排序</p><p>Step2: 按倒序依次枚举每个区间：<br />如果当前区间已经包含该点，则直接continue；<br />否则，选择当前区间左端点</p></blockquote><p><a href="https://www.acwing.com/problem/content/907/">AcWing-905.区间选点</a></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int INF &#x3D; 0x3f3f3f3f;int n;vector&lt;PII&gt; segs;int main() &#123;    cin &gt;&gt; n;    for (int i &#x3D; 0; i &lt; n; i ++) &#123;        int l, r;        scanf(&quot;%d %d&quot;, &amp;l, &amp;r);        segs.push_back(&#123;l, r&#125;);    &#125;        &#x2F;&#x2F; step1: 按左端点排序    sort(segs.begin(), segs.end());        int res &#x3D; 0;    int st &#x3D; INF;    &#x2F;&#x2F; step2: 倒序枚举    for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i --) &#123;        &#x2F;&#x2F; 无交集        if (segs[i].second &lt; st) &#123;            res ++;            st &#x3D; segs[i].first;        &#125;    &#125;        cout &lt;&lt; res &lt;&lt; endl;        return 0;&#125;</code></pre><h4 id="最大不相交区间数"><a class="markdownIt-Anchor" href="#最大不相交区间数"></a> 最大不相交区间数</h4><p>数轴上有若干区间，选择其中尽可能多的区间，使得选中的区间之间互不相交。</p><blockquote><p>贪心策略：</p><p>Step1: 区间按左端点从小到大排序</p><p>Step2: 按倒序依次枚举每个区间：<br />如果两个区间相交，则直接continue；<br />否则，选择当前区间(res ++)，并把比较区间更新为当前区间</p></blockquote><p><a href="https://www.acwing.com/problem/content/910/">AcWing-908.最大不相交区间数量</a></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int INF &#x3D; 0x3f3f3f3f;int n;vector&lt;PII&gt; segs;int main() &#123;    cin &gt;&gt; n;    for (int i &#x3D; 0; i &lt; n; i ++)  &#123;        int l, r;        scanf(&quot;%d %d&quot;, &amp;l, &amp;r);        segs.push_back(&#123;l, r&#125;);    &#125;    &#x2F;&#x2F; step1: 按左端点排序    sort(segs.begin(), segs.end());        int res &#x3D; 0;    int st &#x3D; INF;    &#x2F;&#x2F; step2: 倒序枚举    for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i --) &#123;        &#x2F;&#x2F; 无交集        if (segs[i].second &lt; st) &#123;            res ++;            st &#x3D; segs[i].first;        &#125;    &#125;    cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;</code></pre><blockquote><p>综上，可得结论：<strong>最少覆盖区间点数 == 最大不相交区间数</strong></p><p>因为如果几个区间能被同一个点覆盖 ，说明它们相交了，所以有几个点就是有几个不相交区间</p></blockquote><hr /><h4 id="区间合并"><a class="markdownIt-Anchor" href="#区间合并"></a> 区间合并</h4><p>数轴上有若干区间，要求合并所有有交集的区间，求合并后的区间个数。</p><blockquote><p>贪心策略：</p><p>Step1: 区间按左端点从小到大排序</p><p>Step2: 按顺序依次枚举区间：<br />如果当前区间与上一个区间没有交集，则把上一个区间放入合并数组内，当前区间更新为上一个区间;<br />否则，把当前区间与上一个区间合并，更新上一个区间的右端点的最大值</p></blockquote><p><a href="https://www.acwing.com/problem/content/805/">AcWing-803.区间合并</a></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int INF &#x3D; 0x3f3f3f3f;int n;vector&lt;PII&gt; segs;void merge(vector&lt;PII&gt; &amp;segs) &#123;    vector&lt;PII&gt; res;        &#x2F;&#x2F; step1: 按左端点对区间排序    sort(segs.begin(), segs.end());        &#x2F;&#x2F; step2: 按顺序依次枚举区间    int st &#x3D; -INF, ed &#x3D; -INF;    for (int i &#x3D; 0; i &lt; segs.size(); i ++) &#123;        &#x2F;&#x2F; 无交集        if (ed &lt; segs[i].first) &#123;            if(st !&#x3D; -INF) res.push_back(&#123;st, ed&#125;);            st &#x3D; segs[i].first, ed &#x3D; segs[i].second;        &#125;        &#x2F;&#x2F; 有交集        else ed &#x3D; max(ed, segs[i].second);    &#125;    if(st !&#x3D; -INF) res.push_back(&#123;st, ed&#125;);    segs &#x3D; res;&#125;int main() &#123;    cin &gt;&gt; n;        for (int i &#x3D; 0; i &lt; n; i ++) &#123;        int l, r;        scanf(&quot;%d %d&quot;, &amp;l, &amp;r);        segs.push_back(&#123;l, r&#125;);    &#125;        merge(segs);        cout &lt;&lt; segs.size() &lt;&lt; endl;        return 0;&#125;</code></pre><h4 id="区间分组"><a class="markdownIt-Anchor" href="#区间分组"></a> 区间分组</h4><p>数轴上有若干区间，给这些区间分组，使得每组内的区间互不相交，求最小分组数量。</p><blockquote><p>贪心策略：</p><p>Step1: 区间按左端点从小到大排序</p><p>Step2: 用一个小根堆维护当前分组(<code>pair&lt;右端点, 分组id&gt;</code>)，按顺序依次枚举每个区间:<br />每次取出堆顶的组，如果组内区间与当前区间无交集，则让当前区间加入该组，并更新区间右端点;<br />否则，以当前区间右端点新建一个分组，加入到小根堆中</p></blockquote><p><a href="https://www.acwing.com/problem/content/907/">AcWing-905.区间选点</a></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII;vector&lt;PII&gt; seg;int n;int main() &#123;    cin &gt;&gt; n;    seg.resize(n);    for (int i &#x3D; 0; i &lt; n; i ++) &#123;        scanf(&quot;%d %d&quot;, &amp;seg[i].first, &amp;seg[i].second);    &#125;    sort(seg.begin(), seg.end());    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; pq;    for (int i &#x3D; 0; i &lt; n; i ++) &#123;        &#x2F;&#x2F; 组数不为空，并且组内区间与当前区间无交集        if (!pq.empty() &amp;&amp; pq.top().first &lt; seg[i].first) &#123;            auto t &#x3D; pq.top(); pq.pop();            t.first &#x3D; seg[i].second;            pq.push(t);        &#125;        &#x2F;&#x2F; 有交集        else &#123;            pq.push(&#123;seg[i].second, pq.size() + 1&#125;);        &#125;    &#125;    cout &lt;&lt; pq.size() &lt;&lt; endl;    return 0;&#125;</code></pre><p>区间分组也是最大区间厚度(最多区间重叠部分)，这里有一种<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的解法:</p><p>思路：我们可以把所有开始时间和结束时间排序，遇到开始时间就把需要的教室加1，遇到结束时间就把需要的教室减1,在一系列需要的教室个数变化的过程中，峰值就是多同时进行的活动数，也是我们至少需要的教室数。</p><p><a href="https://www.acwing.com/solution/content/8902/">https://www.acwing.com/solution/content/8902/</a></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 100100;int n;int b[2 * N], idx;int main() &#123;    scanf (&quot;%d&quot;, &amp;n);    for(int i &#x3D; 0; i &lt; n; i ++) &#123;        int l, r;        scanf(&quot;%d %d&quot;, &amp;l, &amp;r);        b[idx ++] &#x3D; l * 2;&#x2F;&#x2F;标记左端点为偶数。        b[idx ++] &#x3D; r * 2 + 1;&#x2F;&#x2F; 标记右端点为奇数。    &#125;    sort(b, b + idx);    int res &#x3D; 1, t &#x3D; 0;    for(int i &#x3D; 0; i &lt; idx; i ++) &#123;        if(b[i] % 2 &#x3D;&#x3D; 0) t ++;        else t --;        res &#x3D; max(res, t);    &#125;    printf (&quot;%d\n&quot;, res);    return 0;&#125;</code></pre><h4 id="区间覆盖"><a class="markdownIt-Anchor" href="#区间覆盖"></a> 区间覆盖</h4><p>数轴上有若干区间，选择其中尽可能少的区间，覆盖一个题给指定线段。</p><blockquote><p>贪心策略：</p><p>Step1: 区间按左端点从小到大排序, 初始赋值 <code>st = tar.first, ed = tar.second</code></p><p>Step2: 按顺序依次枚举区间:<br />首先在这些segs中挑出满足左端点 &lt;=  st的线段，<br />然后在这些线段中 ，选择second最大的那个作为覆盖区间，并把st更新为该区间的second<br />重复Step2，直到<code>r &gt;= ed</code></p><p>首先在这些segs中挑出满足左端点 &lt;=  st的线段，</p><p>注意，会有无解情况，因此需要设置flag来判断:<br />① 找不到满足first &lt;=  st的线段，或者这些区间全与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>s</mi><mi>t</mi><mo separator="true">,</mo><mi>e</mi><mi>d</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[st,ed]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span>不相交(<code>r &lt; st</code>)<br />② 遍历完整个区间后r仍然 &lt; ed</p></blockquote><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int INF &#x3D; 0x3f3f3f3f;int n;PII tar;vector&lt;PII&gt; segs;int main() &#123;    cin &gt;&gt; tar.first &gt;&gt; tar.second;    cin &gt;&gt; n;    for (int i &#x3D; 0; i &lt; n; i ++) &#123;        int l, r;        scanf(&quot;%d %d&quot;, &amp;l, &amp;r);        segs.push_back(&#123;l, r&#125;);    &#125;    sort(segs.begin(), segs.end());    int res &#x3D; 0;    bool flag &#x3D; false;    int st &#x3D; tar.first, ed &#x3D; tar.second;    for (int i &#x3D; 0; i &lt; n; i ++) &#123;        int j &#x3D; i, r &#x3D; -INF;        while  (j &lt; n &amp;&amp; segs[j].first &lt;&#x3D; st) &#123;            r &#x3D; max(r, segs[j].second);            j ++;        &#125;        if (r &lt; st) &#123;            res &#x3D; -1;            break;        &#125;        res ++;        if (r &gt;&#x3D; ed)  &#123;            flag &#x3D; true;            break;        &#125;        st  &#x3D; r;        i &#x3D; j - 1;    &#125;    if (!flag) res &#x3D; -1;    cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;</code></pre><h3 id="其它经典贪心"><a class="markdownIt-Anchor" href="#其它经典贪心"></a> 其它经典贪心</h3><h4 id="合并果子"><a class="markdownIt-Anchor" href="#合并果子"></a> 合并果子</h4><p>有n堆果子，需要两两合并，经过n-1次合并成 1堆果子 ，求合并最少需要花费的体力。[把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和]</p><blockquote><p><strong>贪心策略</strong></p><p>每次选择最小重量的两堆进行合并，即为最小花费体力。</p><p><strong>ps</strong>:整个合并过程就是一个二叉树，每个结点的<strong>贡献次数</strong>就是结点到根结点的距离。</p></blockquote><p>题目链接:<a href="https://www.acwing.com/problem/content/150/">https://www.acwing.com/problem/content/150/</a></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;iostream&gt;using namespace std;int n;int main() &#123;    cin &gt;&gt; n;    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;    for (int i &#x3D; 0; i &lt; n; i ++) &#123;        int x;        scanf(&quot;%d&quot;, &amp;x);        pq.push(x);    &#125;        long long res &#x3D; 0;    while(pq.size() !&#x3D; 1) &#123;        int t1 &#x3D; pq.top(); pq.pop();        int t2 &#x3D; pq.top(); pq.pop();                int t &#x3D; t1 + t2;        res +&#x3D; t;        pq.push(t);    &#125;        cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;</code></pre><h4 id="排队打水"><a class="markdownIt-Anchor" href="#排队打水"></a> 排队打水</h4><p>有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个人排队到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个水龙头处打水，第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个人装满水桶所需的时间是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">t_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，请问如何安排他们的打水顺序才能使所有人的等待时间之和最小？</p><blockquote><p><strong>贪心策略</strong></p><p>由<code>i</code>的任意性，打水的时间总和为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><msub><mi>i</mi><mn>1</mn></msub></msub><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><msub><mi>t</mi><msub><mi>i</mi><mn>2</mn></msub></msub><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>t</mi><msub><mi>i</mi><mi>n</mi></msub></msub><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{t_{i_1}*(n-1) + t_{i_2}*(n-2) + ...t_{i_n}*(n-n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0001em;vertical-align:-0.2501em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>，也就是<strong>前缀和之和</strong></p><p>要想让前缀和之和最小，显然从小到大排序即可</p></blockquote><p>题目链接: <a href="https://www.acwing.com/problem/content/915/">https://www.acwing.com/problem/content/915/</a></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N &#x3D; 1e5 + 7;int n;int arr[N];LL sum[N];int main() &#123;    cin &gt;&gt; n;    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++) &#123;        scanf(&quot;%d&quot;, &amp;arr[i]);    &#125;        sort(arr + 1, arr + n + 1);        sum[0] &#x3D; 0;    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++) &#123;        sum[i] &#x3D; sum[i - 1] + arr[i];    &#125;        LL res &#x3D; 0;    &#x2F;&#x2F; 最后一个人的时间不用等    for (int i &#x3D; 1; i &lt; n; i ++) &#123;        res +&#x3D; sum[i];    &#125;        cout &lt;&lt; res &lt;&lt; endl;        return 0;&#125;</code></pre><h4 id="货仓选址"><a class="markdownIt-Anchor" href="#货仓选址"></a> 货仓选址</h4><blockquote><p><strong>贪心策略</strong></p><p>显然，如果</p></blockquote><pre class="language-none"><code class="language-none"></code></pre><h4 id="耍杂技的牛国王游戏"><a class="markdownIt-Anchor" href="#耍杂技的牛国王游戏"></a> 耍杂技的牛/国王游戏</h4><blockquote><p><strong>贪心策略</strong></p><p>按照<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub><mo>+</mo><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">{w_{i} +  s_{i}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>从小到大的顺序，来从高往低叠罗汉</p></blockquote><p><a href="https://www.acwing.com/problem/content/127/">https://www.acwing.com/problem/content/127/</a></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int INF &#x3D; 0x3f3f3f3f;int n;vector&lt;PII&gt; cows;int main() &#123;    cin &gt;&gt; n;    for (int i &#x3D; 0; i &lt; n; i ++) &#123;        int w, s;        scanf(&quot;%d %d&quot;, &amp;w, &amp;s);        cows.push_back(&#123;w, s&#125;);    &#125;        sort(cows.begin(),cows.end(), [&amp;](const PII&amp;a,  const PII&amp; b) -&gt; bool&#123;       return a.first + a.second &lt; b.first + b.second;    &#125;);        int res &#x3D; -INF, sum &#x3D; 0;    for (int i &#x3D; 0; i &lt; n; i ++) &#123;        res &#x3D; max(res, sum - cows[i].second);        sum +&#x3D; cows[i].first;    &#125;        cout &lt;&lt; res &lt;&lt; endl;        return 0;&#125;</code></pre><h4 id="else"><a class="markdownIt-Anchor" href="#else"></a> Else</h4><ul><li>一个序列中任意两个值绝对值之差的最小值，就是把该序列排序后，相邻元素之差的最小值</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0x00-基础算法-(4)-前缀和&amp;差分</title>
    <link href="/2021/01/04/Algorithm/Template/20210104-0x00-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95(4)-%E5%89%8D%E7%BC%80%E5%92%8C&amp;%E5%B7%AE%E5%88%86/"/>
    <url>/2021/01/04/Algorithm/Template/20210104-0x00-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95(4)-%E5%89%8D%E7%BC%80%E5%92%8C&amp;%E5%B7%AE%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h2 id="前缀和"><a class="markdownIt-Anchor" href="#前缀和"></a> 前缀和</h2><p>前缀和主要起优化作用，它可以快速的求出原数组某一段的子数组和 。</p><h3 id="一维前缀和"><a class="markdownIt-Anchor" href="#一维前缀和"></a> 一维前缀和</h3><p><strong>定义</strong></p><p>原数组: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>3</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{a_1 , a_2, a_3, ... ,a_n \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></p><p>前缀和数组: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><msub><mi>S</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>S</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>S</mi><mn>3</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>S</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{S_1 , S_2, S_3, ... ,S_n \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub><mo>=</mo><msub><mi>a</mi><mn>1</mn></msub><mo>+</mo><mi>a</mi><mn>2</mn><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_i = a_1 + a2 + ... + a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 边界<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">S_0 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p><p><strong>实现</strong></p><p><strong>存储时循环一定要下标从1开始，让<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">S_0 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>好处理边界</strong></p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const int N &#x3D; 1e6 + 10;vector&lt;int&gt; arr(N);vector&lt;int&gt; sum(N);int main() &#123;    int n, m;cin &gt;&gt; n &gt;&gt; m;       for (int i &#x3D; 1; i &lt;&#x3D; n; i ++) scanf(&quot;%d&quot;, &amp;arr[i]);        &#x2F;&#x2F; 预处理前缀和    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++) sum[i] &#x3D; sum[i - 1] + arr[i];        &#x2F;&#x2F; m次询问    while (m --) &#123;        int l, r;        scanf(&quot;%d%d&quot;, &amp;l, &amp;r);        printf(&quot;%d\n&quot;, sum[r] - sum[l - 1]);    &#125;&#125;</code></pre><h4 id="时间复杂度分析"><a class="markdownIt-Anchor" href="#时间复杂度分析"></a> 时间复杂度分析</h4><p>以一维前缀和为例，当你要多次(假设m次)求原数组(长度为n)中某一段子数组和的时候:</p><ul><li>如果没有前缀和，每求一段需要循环遍历一次数组, 1次时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>,  n次时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>;</li><li>当你存储了前缀和(预处理花费时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>, 求其中某一段<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>的子数组和, 只要用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>r</mi></msub><mo>−</mo><msub><mi>S</mi><mrow><mi>l</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">S_r-S_{l-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>即可, 1次时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，m次时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，共<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>.</li></ul><h3 id="leetcode上的前缀和后缀和"><a class="markdownIt-Anchor" href="#leetcode上的前缀和后缀和"></a> LeetCode上的前缀和&amp;后缀和</h3><p>做法：统一把前缀和和后缀和，往后偏移1位， 用下标[1-n]的位置 存储</p><p>这样做的好处，就是不用特殊判断数组越界。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 一般传入参数会给一个 vector&lt;int&gt; arr; 那么应该怎么求前&#x2F;后缀和呢？class Solution &#123;public:    vector&lt;int&gt; preAndsuf(int arr) &#123;        int n &#x3D; arr.size();                &#x2F;&#x2F; 前缀和pre        vector&lt;int&gt; pre(n + 1);        &#x2F;&#x2F; 后缀和suf        vector&lt;int&gt; suf(n + 2);        &#x2F;&#x2F; pre        for (int i &#x3D; 1, c &#x3D; 0; i &lt;&#x3D; n; i ++) &#123;pre[i] &#x3D; pre[i - 1] + arr[i - 1];        &#125;        &#x2F;&#x2F; suf        for (int i &#x3D; n, c &#x3D; 0; i &gt;&#x3D; 1; i --) &#123;            suf[i] &#x3D; suf[i + 1] + arr[i - 1];        &#125;        &#x2F;&#x2F; 使用1: 利用前缀和&#x2F;后缀和，求arr中区间[l, r]的区间和        int l &#x3D; 0, r &#x3D; n - 1;        int sum_lr &#x3D; pre[r + 1] - pre[(l + 1) - 1]; &#x2F;&#x2F; 利用前缀和求        int sum_lr &#x3D; suf[l + 1] - suf[(r + 1) + 1]; &#x2F;&#x2F; 利用后缀和求        &#x2F;&#x2F; 使用2: 求对应位置的前后缀和之和        vector&lt;int&gt; res;        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++) &#123;            res.emplace_back(pre[i] + suf[i]);        &#125;        return res;    &#125;&#125;;</code></pre><h3 id="二维前缀和"><a class="markdownIt-Anchor" href="#二维前缀和"></a> 二维前缀和</h3><h4 id="时间复杂度分析-2"><a class="markdownIt-Anchor" href="#时间复杂度分析-2"></a> 时间复杂度分析</h4><hr /><h2 id="差分"><a class="markdownIt-Anchor" href="#差分"></a> 差分</h2><h3 id="一维差分"><a class="markdownIt-Anchor" href="#一维差分"></a> 一维差分</h3><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>=</mo><msub><mi>a</mi><mi>i</mi></msub><mo>−</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">{b_{i} = a_{i} - a_{i-1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span></span>  ,   <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mn>1</mn></msub><mo>=</mo><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">{b_1 = a_1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>的时间给原数组中间的某一段<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">{[l,r]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span></span>子数组加上一个固定的常数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span></span></p><p>构造差分数组时，也可以看作是在初始所有值为0的一段区间中，在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">{[i, i]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span></span>区间插入了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">{arr[i]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span></span>。</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const int N &#x3D; 1e6 + 10;vector&lt;int&gt; arr(N);vector&lt;int&gt; dif(N);&#x2F;&#x2F; 差分数组核心: dif操作void insert(int l, int r, int c) &#123;    dif[l] +&#x3D; c;    dif[r + 1] -&#x3D; c;&#125;int main() &#123;    int n, m;    cin &gt;&gt; n &gt;&gt; m;        for (int i &#x3D; 1; i &lt;&#x3D; n ; i ++) &#123;        scanf(&quot;%d&quot;, &amp;arr[i]);    &#125;        &#x2F;&#x2F; 构建差分数组本身，也可以用insert操作完成    for (int i &#x3D; 1; i &lt;&#x3D; n ; i ++) &#123;        insert(i, i, arr[i]);     &#125;        while (m --) &#123;int l, r, c;        scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;c);        &#x2F;&#x2F; 对dif数组操作，就能用O(1)的时间给区间[l,r]加上常数c        insert(l, r, c);     &#125;        &#x2F;&#x2F; 对dif求前缀和，还原成arr    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++) &#123;        dif[i] +&#x3D; dif[i - 1];     &#125;        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++) &#123;printf(&quot;%d &quot;, dif[i]);    &#125;            return 0;&#125;</code></pre><h4 id="时间复杂度分析-3"><a class="markdownIt-Anchor" href="#时间复杂度分析-3"></a> 时间复杂度分析</h4><p>同理于一维前缀和，预处理需要花费<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，此后单次<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">{insert}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span></span></span></span></span>操作时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span></span></span>次时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，总共<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m + n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><h3 id="二维差分"><a class="markdownIt-Anchor" href="#二维差分"></a> 二维差分</h3><h4 id="时间复杂度分析-4"><a class="markdownIt-Anchor" href="#时间复杂度分析-4"></a> 时间复杂度分析</h4><h3 id="leetcode上的差分数组"><a class="markdownIt-Anchor" href="#leetcode上的差分数组"></a> LeetCode上的差分数组</h3><p><a href="https://leetcode.cn/problems/increment-submatrices-by-one/submissions/">https://leetcode.cn/problems/increment-submatrices-by-one/submissions/</a></p><pre class="language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; rangeAddQueries(int n, vector&lt;vector&lt;int&gt;&gt;&amp; queries) &#123;        &#x2F;&#x2F; 差分矩阵        vector&lt;vector&lt;int&gt;&gt; b(n + 2, vector&lt;int&gt; (n + 2, 0));                for (auto q : queries) &#123;            int x1 &#x3D; q[0] + 1, y1 &#x3D; q[1] + 1;            int x2 &#x3D; q[2] + 1, y2 &#x3D; q[3] + 1;                        b[x1][y1] +&#x3D; 1;            b[x2 + 1][y1] -&#x3D; 1;            b[x1][y2 + 1] -&#x3D; 1;            b[x2 + 1][y2 + 1] +&#x3D; 1;        &#125;                for (int i &#x3D; 1; i &lt;&#x3D; n; i ++) &#123;            for (int j &#x3D; 1; j &lt;&#x3D; n; j ++) &#123;                b[i][j] &#x3D; b[i][j] + b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];            &#125;        &#125;                     vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt; (n, 0));        for (int i &#x3D; 0; i &lt; n; i ++) &#123;            for (int j &#x3D; 0; j &lt; n; j ++) &#123;                res[i][j] &#x3D; b[i + 1][j + 1];            &#125;        &#125;                return res;    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0x00-基础算法-(3)-高精度</title>
    <link href="/2021/01/03/Algorithm/Template/20210103-0x00-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95(3)-%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    <url>/2021/01/03/Algorithm/Template/20210103-0x00-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95(3)-%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="高精度运算"><a class="markdownIt-Anchor" href="#高精度运算"></a> 高精度运算</h2><p><strong>todo:</strong> 国王游戏的高精度跟这里的不一样，看看国王游戏的题解视频</p><p>高精度运算是<strong>位运算</strong>中一种比较广泛应用，其中的<strong>进位/借位机制</strong>很容易拓展到<strong>N进制计算</strong>。</p><p>只有C++需要注意高精度的问题，Java有大整数类<code>BigInteger</code>，Python的范围默认无限大。</p><p><strong>Step1</strong>:大整数存储 (用vector)</p><p><strong>Step2</strong>:代码模拟人工计算</p><h3 id="大整数存储"><a class="markdownIt-Anchor" href="#大整数存储"></a> 大整数存储</h3><blockquote><p>倒着表示：[0]下标存储个位=&gt;方便需要进位时，push_back()直接移位覆盖</p></blockquote><pre class="language-c" data-language="c"><code class="language-c">int main() &#123;    string a, b;    vector&lt;int&gt; A, B;        cin &gt;&gt; a &gt;&gt; b;         &#x2F;&#x2F; a &#x3D; &quot;123456&quot;    &#x2F;&#x2F; A[6, 5, 4, 3, 2, 1]     for (int i &#x3D; a.size() - 1; i &gt;&#x3D; 0; i --) A.push_back(a[i] - &#39;0&#39;);     for (int i &#x3D; b.size() - 1; i &gt;&#x3D; 0; i --) B.push_back(b[i] - &#39;0&#39;);        return 0;&#125;</code></pre><h3 id="模拟人工运算"><a class="markdownIt-Anchor" href="#模拟人工运算"></a> 模拟人工运算</h3><p>注意以下默认传入参数A和B都是正整数(不带±号)，也可以理解为绝对值的运算。</p><p><code>|A| + |B|</code>、 <code>|A| - |B|</code>、<code>|A| * |b|</code>、<code>|A| / |b|</code></p><p>模拟运算过程中最主要的是理解<strong>进位/借位机制</strong>的模拟写法。</p><h4 id="a-b"><a class="markdownIt-Anchor" href="#a-b"></a> A + B</h4><p>高精度正整数A + 高精度正整数B，返回和C</p><p>加法的位运算结果范围<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>20</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t\in[0,20)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65418em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mclose">)</span></span></span></span></p><p>再用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>来表示位运算的<strong>进位</strong>:</p><ul><li>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t \in [0,10)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65418em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，<code>t / 10</code>为0，不进位，当位运算结果<code>t</code>(也可以写成(<code>t % 10</code>))；</li><li>当  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>10</mn><mo separator="true">,</mo><mn>20</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t \in [10,20)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65418em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，<code>t / 10</code>为1，进位，当位运算结果<code>t % 10</code>.</li></ul><pre class="language-c" data-language="c"><code class="language-c">#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;&#x2F;&#x2F; A + Bvector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B) &#123;vector&lt;int&gt; C;        int t &#x3D; 0; &#x2F;&#x2F; 进位    for (int i &#x3D; 0; i &lt; A.size() || i &lt; B.size(); i ++) &#123;        if (i &lt; A.size()) t +&#x3D; A[i];        if (i &lt; B.size()) t +&#x3D; B[i];                C.push_back(t % 10);        &#x2F;&#x2F; 标记本次运算是否进位，用于下一位运算        t &#x2F;&#x3D; 10;    &#125;        &#x2F;&#x2F; 最高位进位, 如:11 + 99 &#x3D; 110    if(t) C.push_back(t);         return C;&#125;int main() &#123;    string a, b;    vector&lt;int&gt; A, B;        cin &gt;&gt; a &gt;&gt; b;        for (int i &#x3D; a.size() - 1; i &gt;&#x3D; 0; i --) A.push_back(a[i] - &#39;0&#39;);     for (int i &#x3D; b.size() - 1; i &gt;&#x3D; 0; i --) B.push_back(b[i] - &#39;0&#39;);        auto C &#x3D; add(A, B);        for (int i &#x3D; C.size() - 1; i &gt;&#x3D; 0; i --) printf(&quot;%d&quot;, C[i]);        return 0;&#125;</code></pre><h4 id="a-b-2"><a class="markdownIt-Anchor" href="#a-b-2"></a> A - B</h4><p>高精度正整数A - 高精度正整数B，返回差C</p><p>减法的位运算结果范围<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>∈</mo><mo stretchy="false">(</mo><mo>−</mo><mn>10</mn><mo separator="true">,</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t\in(-10,10)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65418em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mclose">)</span></span></span></span></p><p>再用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>来表示位运算的<strong>借位</strong>:</p><ul><li>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t \in [0,10)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65418em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，<code>t &gt; 0</code>，无需借位，当位运算结果<code>t</code>(也可以写成<code>(t + 10) % 10</code>);</li><li>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>∈</mo><mo stretchy="false">(</mo><mo>−</mo><mn>10</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t \in (-10, 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65418em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，<code>t &lt; 0</code>，需要借位，当位运算结果<code>(t + 10) % 10</code>.</li></ul><pre class="language-c" data-language="c"><code class="language-c">#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;&#x2F;&#x2F; 判断是否有 A &gt;&#x3D; Bbool cmp(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B) &#123;    if (A.size() !&#x3D; B.size()) return A.size() &gt; B.size();    for (int i &#x3D; A.size() - 1; i &gt;&#x3D; 0; i --) &#123;        if(A[i] !&#x3D; B[i]) &#123;            return A[i] &gt; B[i];        &#125;    &#125;        return true; &#125;&#x2F;&#x2F; A - B : 默认传入的A &gt;&#x3D; B, 如果A &lt; B，算 -(sub(B, A))vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B) &#123;    vector&lt;int&gt; C;        int t &#x3D; 0; &#x2F;&#x2F; 借位    for (int i &#x3D; 0; i &lt; A.size() || i &lt; B.size(); i ++) &#123;        if (i &lt; A.size()) t &#x3D; A[i] - t;        if (i &lt; B.size()) t -&#x3D; B[i];                &#x2F;&#x2F; C.push_back((t + 10) % 10); &#x2F;&#x2F; 可以从if-else中提出来        &#x2F;&#x2F; 标记本次运算是否借位，用于下一位运算        if (t &gt; 0) &#123;            C.push_back((t + 10) % 10);            t &#x3D; 1;        &#125;        else &#123;            C.push_back(t); &#x2F;&#x2F; 也可以写成C.push_back((t + 10) % 10);            t &#x3D; 0;        &#125;    &#125;        &#x2F;&#x2F; 去掉高位的多个0[只保留个位的0], 如:123 - 120 &#x3D; 003    while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();        return C;&#125;int main() &#123;    string a, b;    vector&lt;int&gt; A, B;        cin &gt;&gt; a &gt;&gt; b;        for (int i &#x3D; a.size() - 1; i &gt;&#x3D; 0; i --) A.push_back(a[i] - &#39;0&#39;);     for (int i &#x3D; b.size() - 1; i &gt;&#x3D; 0; i --) B.push_back(b[i] - &#39;0&#39;);        if (cmp(A, B)) &#123;        &#x2F;&#x2F; A &gt; B        auto C &#x3D; sub(A, B);        for (int i &#x3D; C.size() - 1; i &gt;&#x3D; 0; i --) printf(&quot;%d&quot;, C[i]);&#125;     else &#123;        &#x2F;&#x2F; B &gt; A        auto C &#x3D; sub(B, A);        printf(&quot;-&quot;);        for (int i &#x3D; C.size() - 1; i &gt;&#x3D; 0; i --) printf(&quot;%d&quot;, C[i]);&#125;        return 0;&#125;</code></pre><h4 id="a-b-3"><a class="markdownIt-Anchor" href="#a-b-3"></a> A * b</h4><p>高精度正整数A * 低精度正整数b，返回乘积C</p><p>思路和A + B差不多</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;&#x2F;&#x2F; A * bvector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b) &#123;    vector&lt;int&gt; C;        int t &#x3D; 0;    &#x2F;&#x2F; 当进位t为0时停止循环，可以省去后面的[最高位进位]和[去掉高位的多个0]的操作    &#x2F;&#x2F; for(int i &#x3D; 0; i &lt; A.size() || t; i ++) ，    for(int i &#x3D; 0; i &lt; A.size(); i ++) &#123;        t +&#x3D; A[i] * b;        C.push_back(t % 10);        t &#x2F;&#x3D; 10;&#125;        &#x2F;&#x2F; 最高位进位    if(t) C.push_back(t);    &#x2F;&#x2F; 去掉高位的多个0[只保留个位的0], 如:12345 * 0 &#x3D; 00000;    while(C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();        return C;&#125;int main() &#123;    string a;    int b;        cin &gt;&gt; a &gt;&gt; b;        vector&lt;int&gt; A;    for (int i &#x3D; a.size() - 1; i &gt;&#x3D; 0; i --) A.push_back(a[i] - &#39;0&#39;);        auto C &#x3D; mul(A, b);            for (int i &#x3D; C.size() - 1; i &gt;&#x3D; 0; i --) printf(&quot;%d&quot;, C[i]);        return 0;&#125;</code></pre><h4 id="a-b-4"><a class="markdownIt-Anchor" href="#a-b-4"></a> A / b</h4><p>高精度正整数A / 低精度正整数b， 返回商C和余数r</p><p>注意人工算除法是从最高位开始除的:<br />因此模拟时for循环要从后往前，并且结束后为了保持大整数存储的一致性，要reverse()反转C</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;&#x2F;&#x2F; A &#x2F; b, 商是C, 余数是rvector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r) &#123;    vector&lt;int&gt; C;        r &#x3D; 0;&#x2F;&#x2F; 因为C++函数只能返回一个值，所以使用传引用&amp;r来影响r的值    for (int i &#x3D; A.size() - 1; i &gt;&#x3D; 0; i --) &#123;        r &#x3D; r * 10 + A[i];        C.push_back(r &#x2F; b);        r %&#x3D; b;    &#125;        reverse(C.begin(), C.end());    &#x2F;&#x2F; 去掉高位的多个0[只保留个位的0], 如:100 &#x2F; 19 &#x3D; 005...5    while(C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();        return C;&#125;int main() &#123;    string a;    int b;        cin &gt;&gt; a &gt;&gt; b;        vector&lt;int&gt; A;    for (int i &#x3D; a.size() - 1; i &gt;&#x3D; 0; i --) A.push_back(a[i] - &#39;0&#39;);        int r;&#x2F;&#x2F;余数     auto C &#x3D; div(A, b, r);        &#x2F;&#x2F; 商    for (int i &#x3D; C.size() - 1; i &gt;&#x3D; 0; i --) printf(&quot;%d&quot;, C[i]);        cout &lt;&lt; endl;    cout &lt;&lt; r &lt;&lt; endl;        return 0;&#125;</code></pre><h4 id="时间复杂度分析"><a class="markdownIt-Anchor" href="#时间复杂度分析"></a> 时间复杂度分析</h4><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span></span>取<code>max(A.size(), B.size())</code></p><p><strong>A + B</strong>  : <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><p><strong>A - B</strong>   : <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><p><strong>A * b</strong>   : <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><p><strong>A / b</strong>   : <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>， 尽管有reverse()函数，但是reverse也是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的。</p><h3 id="扩充一个string去除前导零的操作"><a class="markdownIt-Anchor" href="#扩充一个string去除前导零的操作"></a> 扩充一个:string去除前导零的操作</h3><p>如果给你一个用string从高位到低位存储的大数，怎么去把字符串中多余的前导零去掉。</p><p>主要是<code>0000000000102</code> 和<code>00102</code>去除掉前导零后，是相同的数102。</p><pre class="language-c" data-language="c"><code class="language-c">string trim(string s) &#123;    &#x2F;&#x2F; 由于是前导0， 因此最后一位不判断int i &#x3D; 0;    while (i &lt; s.size() - 1 &amp;&amp; s[i] &#x3D;&#x3D; &#39;0&#39;) &#123;        i ++;    &#125;        return s.substr(i);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0x00-基础算法-(2)-二分搜索</title>
    <link href="/2021/01/02/Algorithm/Template/20210102-0x00-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-(2)-%E4%BA%8C%E5%88%86/"/>
    <url>/2021/01/02/Algorithm/Template/20210102-0x00-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-(2)-%E4%BA%8C%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p>二分的本质是划分两个区间，使得满足某种条件处于左left区间，满足另外一种条件的处于right区间。</p><p><strong>有单调性的题目一定可以二分， 可以二分的题目不一定非要有单调性(可以先sort构造出单调性)</strong></p><p>每次更新区间l,r时，都要保证target在区间内</p><h2 id="二分答案"><a class="markdownIt-Anchor" href="#二分答案"></a> 二分答案</h2><p>二分答案值域， 然后check(mid)是否在定义域内，一步步收缩值域两端lr，最终得到答案</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;algorithm&gt;&#x2F;&#x2F; check函数可以用lambda匿名函数写auto check &#x3D; [&amp;](int x) -&gt; bool &#123;    if (&#x2F;* 满足题目条件 *&#x2F;) return true;    else return false;&#125;&#x2F;&#x2F; 假设值域范围为闭区间[left, right]int l &#x3D; left, r &#x3D; right;while (l !&#x3D; r + 1) &#123;    int mid &#x3D; l + (r - l) &#x2F; 2;    if (check(mid)) &#123;        l &#x3D; mid + 1;    &#125;    else &#123;        r &#x3D; mid - 1;    &#125;&#125;return r;</code></pre><p><a href="https://www.acwing.com/problem/content/104/">102.最佳牛围栏</a></p><h2 id="整数二分"><a class="markdownIt-Anchor" href="#整数二分"></a> 整数二分</h2><h3 id="相错终止模板"><a class="markdownIt-Anchor" href="#相错终止模板"></a> 相错终止模板</h3><blockquote><ul><li>l 与 r是数组的左右闭区间 ，即 <code>l = 0</code>且<code>r = arr.size() - 1</code></li><li>while()括号内的条件:  <code>while (l &lt;= r)</code>或<code>while (l != r + 1)</code></li><li>arr[mid]与tar，或者说是check(mid):<ul><li>check(mid)函数该怎么写，什么时候返回true，什么时候返回false，并对应修改哪个区间</li></ul></li></ul></blockquote><p><code>..., idx_upper] target [idx_lower, ...</code></p><p>其中 : idx_lower = r + 1(l)    idx_upper = l - 1®</p><p>以lower_bound举例:</p><ul><li>循环结束后一定满足: l == r + 1</li></ul><p><img src="/img/algorithm/binary_search_lower_bound.png" alt="" /></p><p>更新l, r的思路:</p><p>因为arr[mid] <code>&lt;</code> / <code>&lt;=</code>target ，所以 target必定在<code>mid ~ r</code>之间，因此更新l；<br />因为arr[mid] <code>&gt;</code> / <code>&gt;=</code> target，所以 target必定在<code>l ~ mid</code>之间，因此更新r.</p><h4 id="lower_bound模板"><a class="markdownIt-Anchor" href="#lower_bound模板"></a> lower_bound模板</h4><p>lower_bound(以target为下界: <code>target [lower, ...</code>:<br />返回<strong>第一个</strong>[插入target后，arr仍然保持有序]的下标</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int binary_search1(vector&lt;int&gt; &amp;arr, int target) &#123;    int l &#x3D; 0, r &#x3D; arr.size() - 1;        while (l !&#x3D; r + 1) &#123;        int mid &#x3D; l + (r - l) &#x2F; 2;        if (arr[mid] &lt; target) &#123;            &#x2F;&#x2F; l的左边(不包括l)全小于target            l &#x3D; mid + 1;        &#125; else &#123;            &#x2F;&#x2F; r的右边(不包括r)全大于等于target            r &#x3D; mid - 1;        &#125;    &#125;         return l; &#x2F;&#x2F; return r + 1; &#x2F;&#x2F; lower_bound&#125;</code></pre><p><strong>应用</strong>: 在数组arr中找到大于等于target的最小值</p><p>使用binary_search1():</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;vector&gt;#include &lt;algorithm&gt;   &#x2F;&#x2F; sort()using namespace std;vector&lt;int&gt; arr;sort(arr.begin(), arr.end());int idx_lower &#x3D; binary_search1(arr, target);int lower &#x3D; idx_lower &#x3D;&#x3D; arr.size() ? -1 : arr[idx_lower];</code></pre><p>使用lower_bound()函数达到相同目的:</p><p><a href="https://en.cppreference.com/w/cpp/algorithm/lower_bound">C++: lower_bound函数</a>(Defined in header <code>&lt;algorithm&gt;</code>)</p><p>返回第一个大于等于target的下标迭代器</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;vector&gt;#include &lt;algorithm&gt;   &#x2F;&#x2F; sort() &amp; lower_bound() &amp; upper_boundusing namespace std;vector&lt;int&gt; arr;sort(arr.begin(), arr.end());auto it_lower &#x3D; lower_bound(arr.begin(), arr.end(), target);&#x2F;&#x2F; int idx_lower &#x3D; it_lower - arr.begin(); &#x2F;&#x2F; 下标可以求但没必要int lower &#x3D; it_lower &#x3D;&#x3D; arr.end() ? -1 : *it_lower;</code></pre><hr /><h4 id="upper_bound模板"><a class="markdownIt-Anchor" href="#upper_bound模板"></a> upper_bound模板</h4><p>upper_bound(以target为上界: <code>... upper] target</code>):<br />返回<strong>最后一个</strong>[插入target后，arr仍然保持有序]的下标</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int binary_search2(vector&lt;int&gt; &amp;arr, int target) &#123;    int l &#x3D; 0, r &#x3D; arr.size() - 1;        while (l !&#x3D; r + 1) &#123;        int mid &#x3D; l + (r - l) &#x2F; 2;        if (arr[mid] &lt;&#x3D; target) &#123;            &#x2F;&#x2F; l的左边(不包括l)全小于等于target            l &#x3D; mid + 1;        &#125; else &#123;            &#x2F;&#x2F; r的右边(不包括r)全大于target            r &#x3D; mid - 1;        &#125;    &#125;         return r; &#x2F;&#x2F; return l - 1;    &#x2F;&#x2F; return l;    &#x2F;&#x2F; upper_bound&#125;</code></pre><p><strong>应用</strong>: 在数组arr中找到小于等于target的最大值</p><p>使用binary_search2():</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;vector&gt;#include &lt;algorithm&gt;   &#x2F;&#x2F; sort()using namespace std;vector&lt;int&gt; arr;sort(arr.begin(),arr.end());int idx_upper &#x3D; binary_search2(arr, target);int upper &#x3D; idx_upper() &#x3D;&#x3D; -1 ? -1 : arr[idx_upper];</code></pre><p>使用upper_bound函数达到相同目的:</p><p><a href="https://en.cppreference.com/w/cpp/algorithm/upper_bound">C++: upper_bound函数</a>(Defined in header <code>&lt;algorithm&gt;</code>)</p><p>返回第一个大于target的下标迭代器，那么小于等于就是prev(it)</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;vector&gt;#include &lt;algorithm&gt;   &#x2F;&#x2F; sort() &amp; lower_bound() &amp; upper_boundusing namespace std;vector&lt;int&gt; arr;sort(arr.begin(), arr.end());auto it_upper &#x3D; upper_bound(arr.begin(), arr.end(), target);&#x2F;&#x2F; int idx_upper &#x3D; it_upper - arr.begin(); &#x2F;&#x2F; 下标可以求但没必要int upper &#x3D; it_upper &#x3D;&#x3D; arr.begin() ? -1 : *prev(it_upper);  &#x2F;&#x2F; 注意这里是it_upper的前一个迭代器**练习eg:**</code></pre><p><a href="https://www.acwing.com/problem/content/791/">Acwing-789.数的范围</a></p><h2 id="浮点数二分"><a class="markdownIt-Anchor" href="#浮点数二分"></a> 浮点数二分</h2><p>浮点数二分， 由于/号不会有向下取整的问题， 因此不需要考虑边界问题</p><p>l 与 r同样是数组的左右闭区间</p><p>while()  括号内是 r - l &gt; 题给精度1e5</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;iostream&gt;using namespace std;int main() &#123;    double x;    cin &gt;&gt; x;    double l &#x3D; 0, r &#x3D; x;    while (r - l &gt; 1e-6) &#123;        double mid &#x3D; l + (r - l) &#x2F; 2; &#x2F;&#x2F; 浮点数二分 &#x2F;号不会有向下取整的问题        &#x2F;&#x2F; eg:找几何平均数        if (mid * mid &gt;&#x3D; x) &#123;            r &#x3D; mid;        &#125;        else &#123;            l &#x3D; mid;        &#125;    &#125;    return l; &#x2F;&#x2F;return r也可以    &#125;</code></pre><p><strong>练习eg:</strong></p><p><a href="https://www.acwing.com/problem/content/792/">Acwing-790.数的三次方根</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0x00-基础算法-(1)-排序</title>
    <link href="/2021/01/01/Algorithm/Template/20210101-0x00-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-(1)-%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/01/01/Algorithm/Template/20210101-0x00-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-(1)-%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h2><p>快排基于分治思想</p><p><strong>Step1</strong>: 确定分界点: 可选arr[l], arr[(l + r)/ 2] , arr[r];</p><p><strong>Step2</strong>: 调整区间，使得：左区间的数≤分界点 ， 右区间的数≥分界点; ⭐️</p><p><strong>Step3</strong>: 递归处理左右两个区间。</p><h3 id="算法实现"><a class="markdownIt-Anchor" href="#算法实现"></a> 算法实现</h3><p><strong>Step2</strong>双指针实现：</p><p>第一个指针最初指向最左端， 第二个指针最初指向最右端。</p><p>将左右两个指针不断往中间移动移动，</p><p>当左边的指针第一次遇到&gt;边界值的数，右边的指针第一次遇到&lt;边界值的数，交换指针指向两个元素。</p><p>直到两指针相遇，完成当轮次快排。</p><p>可以发现这个算法有许多边界问题需要注意，因此还是建议背模板的!</p><p>快速排序模板:</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;void quick_sort(vector&lt;int&gt; &amp;arr, int l, int r) &#123;&#x2F;&#x2F; 递归边界：区间里没有数了或者只有一个数if (l &gt;&#x3D; r) return;    &#x2F;&#x2F; step1int x &#x3D; arr[l + (r - l) &#x2F; 2];        &#x2F;&#x2F; step2int i &#x3D; l - 1, j &#x3D; r + 1;while (i &lt; j) &#123;do i ++; while (arr[i] &lt; x);do j --; while (arr[j] &gt; x);if (i &lt; j) swap(arr[i], arr[j]);&#125;        &#x2F;&#x2F; step3quick_sort(arr, l , j);quick_sort(arr, j + 1, r); &#125;int main() &#123;int n;cin &gt;&gt; n;vector&lt;int&gt;arr(n);for (int i &#x3D; 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;arr[i]);quick_sort(arr, 0, n - 1);for (int i &#x3D; 0; i &lt; n; i ++) printf(&quot;%d &quot;, arr[i]);return 0;&#125;</code></pre><h4 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h4><p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，最坏时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>  空间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(logn)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span> 不稳定</p><p><a href="https://zhuanlan.zhihu.com/p/341201904">https://zhuanlan.zhihu.com/p/341201904</a></p><p><strong>时间复杂度</strong>:</p><p><strong>空间复杂度</strong>: 递归深度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">{log_2n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span></span>，即函数栈开销<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">{log_2n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span></span></p><blockquote><p>细节1： 必须要同时使用 <code>i - 1, i</code> 或 <code>j , j + 1</code></p><p>当使用<code>i - 1, i</code>， x不能取左边界[l]， 当使用<code>j, j + 1</code>时, x不能取右边界arr[r]<br />否则就会出现边界问题，陷入无限递归死循环</p><p>细节2:    <code>l + (r - l) / 2</code>和 <code>l + (r - l + 1) / 2</code></p><p>C++的/是向下取整的，因此<code>l + (r - l) / 2</code>偏向左边界[l]  =&gt;用<code>j , j + 1</code>;<br />人为+1/2进行四舍五入，因此<code>l + (r - l + 1) / 2</code>偏向右边界[r] =&gt; <code>用 i - 1, i</code></p><p>细节3:   <code>while (arr[i] &lt; x);</code> <code>while (arr[j] &gt; x);</code>就连等于边界值x时都要交换</p><p>细节4:  <code>int i = l - 1, j = r + 1;</code>初始化时i, j在两边界外</p></blockquote><p><strong>练习eg:</strong></p><p><a href="https://www.acwing.com/problem/content/787/">ACwing-785.快速排序</a></p><p>注意灵活应用，根据step1中<strong>x的选择的不同</strong>,快排也可以衍生出很多变种,如：</p><p><a href="https://leetcode.cn/problems/custom-sort-string/description/">LeetCode-791.自定义字符串排序</a></p><h2 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h2><p>归并排序基于分治思想</p><p><strong>Step1</strong>: 以中间点为分界点: mid = l + (r - l) / 2;</p><p><strong>Step2</strong>: 递归排序left, right区间;</p><p><strong>Step3</strong>: 归并—把两个有序子数组合二为一 。⭐️</p><h3 id="算法实现-2"><a class="markdownIt-Anchor" href="#算法实现-2"></a> 算法实现</h3><p><strong>Step3</strong>双指针实现：</p><p>第一个指针最初指向第一个有序子数组(从小到大)的开头，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">min_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>第二个指针最初指向第一个有序子数组(从小到大)的开头，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">min_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>对两个指针指向的数循环比较，将较小的数归并回原数组，然后其指针右移，继续比较；</p><p>直到两个指针都指向其数组的末端，完成当轮此归并。</p><p>归并排序模板：</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;vector&lt;int&gt; tmp;&#x2F;&#x2F;要开辟一个数组做归并时的临时存储void merge_sort(vector&lt;int&gt; &amp;arr, int l, int r) &#123;    &#x2F;&#x2F; 递归边界if (l &gt;&#x3D; r) return;        &#x2F;&#x2F; step1    int mid &#x3D; l + (r - l) &#x2F; 2;        &#x2F;&#x2F; step2    merge_sort(arr, l, mid);    merge_sort(, mid + 1, r);        &#x2F;&#x2F; step3    int k &#x3D; 0;&#x2F;&#x2F; tmp数组中已经归并的元素数量    int i &#x3D; l, j &#x3D; mid + 1;    while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r) &#123;        if (arr[i] &lt;&#x3D; arr[j]) tmp[k ++ ] &#x3D; arr[i ++];        else tmp[k ++] &#x3D; arr[j ++];    &#125;    &#x2F;&#x2F;复制末尾    while (i &lt;&#x3D; mid) tmp[k ++] &#x3D; arr[i ++];    while (j &lt;&#x3D; r) tmp[k ++] &#x3D; arr[j ++];    &#x2F;&#x2F;复制回原数组进行覆盖    for (int i &#x3D; l, j &#x3D; 0; j &lt; k; i ++, j ++) arr[i] &#x3D; tmp[j];&#125;int main() &#123;int n;cin &gt;&gt; n;vector&lt;int&gt;arr(n);    tmp.resize(n);    for (int i &#x3D; 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;arr[i]);merge_sort(arr, 0, n - 1);for (int i &#x3D; 0; i &lt; n; i ++) printf(&quot;%d &quot;, arr[i]);return 0;&#125;</code></pre><h4 id="复杂度分析-2"><a class="markdownIt-Anchor" href="#复杂度分析-2"></a> 复杂度分析</h4><p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(nlog_2n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span> (妥妥的)   空间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>（有额外数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>m</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">tmp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span></span></span></span>）稳定</p><p><strong>时间复杂度</strong>: 比较和赋值的时间复杂度都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>，每次递归数组规模减半，即递归深度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">{log_2n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span></span> ，也即总共需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">{log_2n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span></span>次<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>的比较和赋值，因此总时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(nlog_2n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span> 。</p><p><strong>空间复杂度</strong>: 递归深度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">{log_2n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span></span>，即函数栈开销<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">{log_2n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span></span>，额外数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>m</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">tmp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span></span></span></span>为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>，因此总空间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>。</p><p><strong>练习eg:</strong></p><p><a href="https://www.acwing.com/problem/content/789/">ACwing-787.归并排序</a></p><h3 id="应用求逆序对"><a class="markdownIt-Anchor" href="#应用求逆序对"></a> 应用:求逆序对</h3><p>使用归并排序可以在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(nlog_2n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>，求一个长度为n的序列的逆序对的个数。</p><ol><li><p>递归对左右两半排序时，可以把左右两半各自内部的逆序对数作为子问题，在合并时只需要考虑“左边一半里一个较大的数”与“右边一半里一个较小的数”构成逆序对的情形:</p><blockquote><p><code>res = merge_sort(arr, l, mid) + merge_sort(arr, mid + 1, r)</code></p></blockquote></li><li><p>合并两个有序子序列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>l</mi><mo>∼</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">{arr[l \sim mid]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span></span>与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>+</mo><mn>1</mn><mo>∼</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">{arr[mid + 1 \sim r]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span></span>，采用两个指针<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi mathvariant="normal">，</mi><mi>j</mi></mrow><annotation encoding="application/x-tex">i，j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>分别扫描，当出现<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>&gt;</mo><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[i] &gt; arr[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>时，说明<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>i</mi><mo>∼</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">{arr[i \sim mid]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span></span>中所有元素都与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>满足逆序对，数量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">mid - i + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p><blockquote><p><code>if(arr[i] &gt; arr[j]) res += mid - i + 1;</code></p></blockquote></li></ol><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N &#x3D; 5e5 + 7;int n;vector&lt;int&gt; tmp;LL merge_sort(vector&lt;int&gt; &amp;arr, int l, int r) &#123;    if (l &gt;&#x3D; r) return 0;    int mid &#x3D; l + (r - l) &#x2F; 2;    LL res &#x3D; merge_sort(arr, l, mid) + merge_sort(arr, mid + 1, r);    int k &#x3D; 0;    int i &#x3D; l, j &#x3D; mid + 1;    while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r) &#123;        if (arr[i] &lt;&#x3D; arr[j]) tmp[k ++] &#x3D; arr[i ++];        else &#123;            tmp[k ++] &#x3D; arr[j ++];            res +&#x3D; mid - i + 1; &#x2F;&#x2F; 从i到mid全是满足的逆序对        &#125;    &#125;    while (i &lt;&#x3D; mid) tmp[k ++] &#x3D; arr[i ++];    while (j &lt;&#x3D; r) tmp[k ++] &#x3D; arr[j ++];    for (int i &#x3D; l, j &#x3D; 0; j &lt; k; i ++, j ++) arr[i] &#x3D; tmp[j];    return res;&#125;</code></pre><p><strong>练习eg:</strong></p><p><a href="https://www.acwing.com/problem/content/109/">107.超快速排序</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机VMware搭建Hadoop3.2.2</title>
    <link href="/2020/12/01/Programing/20210331-VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%90%AD%E5%BB%BAHadoop3/"/>
    <url>/2020/12/01/Programing/20210331-VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%90%AD%E5%BB%BAHadoop3/</url>
    
    <content type="html"><![CDATA[<h2 id="1准备linux主机环境"><a class="markdownIt-Anchor" href="#1准备linux主机环境"></a> 1.准备Linux主机环境</h2><p>VMware:  VMware Workstation 15Pro    <a href="https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html">VMware下载地址</a></p><p>CenOS:  CentOS-8.3.2011-x86_64-dvd1.iso    <a href="http://isoredirect.centos.org/centos/8/isos/x86_64/">CenOS下载地址</a></p><p>免密登录 可以帮助解决Permission denied（publickey,gssapi-keyex,gssapi-with-mic)）</p><p><strong>Step1</strong>: 安装Vmware Workstation 15Pro</p><p>​       该步骤不是实验内容核心，具体省略跳过。</p><p><strong>Step2</strong>: 安装3台CenOS8虚拟机</p><p>由于不是实验内容核心，这里只放我所参照的教程:</p><p>Vmware安装CenOS8: <a href="https://www.cnblogs.com/Dear-XiaoLe/articles/12201099.html">https://www.cnblogs.com/Dear-XiaoLe/articles/12201099.html</a></p><p>​       按照教程配置，成功创建3台CenOS虚拟机</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>密码文章测试</title>
    <link href="/2020/11/04/Diary/20210504-%E9%9A%8F%E6%84%8F%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/11/04/Diary/20210504-%E9%9A%8F%E6%84%8F%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="4396f566be317e10a2ddeb6e5e3e3b2e6f62aa575437c3c19957bfc521e100f6">10d79030e8222445804370796b90fca137368a758ff1e0290f9ccb56396bdfee34be4d9e4d03c00b6264c747a4adf98d329fedd9bf054613f907fd75d03ee87d7fae7080e8d49bc5ba7bb12120897cbff51eccd0c1f00178af7206883381cff22567c35a6c156f19e5ecd7ea83e73718255980ed0cd7e01e11c62b8f8581a110b72d7d3d270503158fcc56ec6fa47d9e5ca2856f757866abe33ac8cefc0bb3d024e86c13620f6aa22ad10791953f505c6b87f84adccf483cd128127f6c018dde589ba4ef48267aa16d0f793e034d6443f8e8042fe39504e45fc8a86105a6d0087ea516573b8b40406f8aee38d763b945add8341c5a40a9861068e9666d05a699051cc7bebfd7ed9ce59bb07d5c13c1a6ac76b451f866090f3be89351351cc13d8932fd56ca345713e0f418d7830ac0252ce6b17662076513d12037980d3149339d785ccdc3a2b29b95ebaa3d2f58860c47edb480ca09d6901d1539bb0a4f4e9b4a53a44a3fcf98061bf515a4c764c7e568ce6e3ca5e3eca7ec56b451409b6360510933c0b7ce694061629dadb3c5301d0a39bb180f024926979fa682d7da170023e4f7ae6c34faa89e256c8ba20fec21</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Plz enter the password.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git命令推送简记</title>
    <link href="/2020/07/29/Programing/20200729-Git%E5%91%BD%E4%BB%A4%E7%AE%80%E8%AE%B0/"/>
    <url>/2020/07/29/Programing/20200729-Git%E5%91%BD%E4%BB%A4%E7%AE%80%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="git-help"><a class="markdownIt-Anchor" href="#git-help"></a> Git-Help</h1><p>Git命令基础操作=&gt;自用</p><h2 id="本地推送流程"><a class="markdownIt-Anchor" href="#本地推送流程"></a> 本地推送流程</h2><ul><li><p><strong>Step1</strong>: 右键=&gt; git bash here,弹出git命令行窗口</p></li><li><p><strong>Step2</strong>: 初始化本地仓库</p><pre class="language-bash" data-language="bash"><code class="language-bash">git init</code></pre><blockquote><p>本地默认创建主分支master</p></blockquote></li><li><p><strong>Step3</strong>: 本地仓库链接远程仓库</p><pre class="language-bash" data-language="bash"><code class="language-bash">git remote add [&#96;远程仓库名&#96;] [&#96;远程仓库地址&#96;]</code></pre><blockquote><p>这里的远程仓库名，习惯上一般使用 origin</p></blockquote></li><li><p><strong>Step4</strong>: 查看本地仓库状态</p><pre class="language-bash" data-language="bash"><code class="language-bash">git status  </code></pre><blockquote><p>该命令显示已修改但未同步的文件</p></blockquote></li><li><p><strong>Step5</strong>: 将文件同步添加到暂存区</p><pre class="language-bash" data-language="bash"><code class="language-bash">git add [&#96;状态里的新文件&#96;]  </code></pre><blockquote><p>可用git add -A一键添加</p></blockquote></li><li><p><strong>Step6</strong>: 将文件添加到仓库</p><pre class="language-bash" data-language="bash"><code class="language-bash">git commit -m &#39;[&#96;相关注释文字&#96;]&#39; </code></pre><blockquote><p>注意-m后的 注释文字要用引号</p></blockquote></li><li><p><strong>Step7</strong>: 将本地某分支推送到远程仓库，如果远程没有此分支会自动创建该分支，默认为master</p><pre class="language-bash" data-language="bash"><code class="language-bash">git push origin [&#96;本地分支名&#96;]</code></pre><blockquote><p>origin 为上面提到的默认远程仓库名</p></blockquote></li></ul><hr /><h2 id="tips额外需求"><a class="markdownIt-Anchor" href="#tips额外需求"></a> Tips[额外需求]</h2><h3 id="git-add"><a class="markdownIt-Anchor" href="#git-add"></a> git add</h3><ol><li>一键添加</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">git add -A</code></pre><p><em># Changes to be committed:</em></p><p><em>#   new file:   add-me</em></p><p><em>#   modified:   change-me</em></p><p><em>#   deleted:    delete-me</em></p><blockquote><p>​可以一键添加所有未跟踪(new)、修改(modified)、被删除(deleted)文件，修改本地仓库再次提交很方便</p></blockquote><h3 id="git-push-origin"><a class="markdownIt-Anchor" href="#git-push-origin"></a> git push origin</h3><ol><li>删除远程仓库的指定远程分支</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">git push origin --delete [&#96;远程分支名&#96;]</code></pre><ol start="2"><li>强制推送</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">git push -f </code></pre><blockquote><p>用于解决一些本地和远程始终不能同步[当前git pull无效]的问题，比如</p><p>Updates were rejected because the tip of your current branch is behind  its remote counterpart. Integrate the remote changes(e.g.‘git pull …’) before pushing again.</p></blockquote><h3 id="git-remote"><a class="markdownIt-Anchor" href="#git-remote"></a> git remote</h3><ol><li>查看远程仓库</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">git remote</code></pre><blockquote><p>显示当前已链接的<code>[远程仓库名]</code>  (但不显示远程仓库地址)</p></blockquote><ol start="2"><li>取消指定链接的远程仓库</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">git remote remove [&#96;远程仓库名&#96;]   </code></pre><ol start="3"><li>链接的远程仓库端口不是默认的port:22</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">git remote origin ssh:&#x2F;&#x2F;[&#96;用户名&#96;]@xx.xx.xx.xx:[&#96;端口号&#96;]&#x2F;..&#x2F;..&#x2F;xxx.git</code></pre><blockquote><p>当远程开放的ssh不是port:22时，使用2、3命令重写绑定链接远程仓库</p><p><strong>PS</strong>:一般github的.git开放ssh端口都是port:22，不用管这个;</p><p>git远程推送你自己的云服务器时，需要查看你自己设定的ssh端口,当然一般也是port:22，但可自主修改</p></blockquote><h2 id="常见问题"><a class="markdownIt-Anchor" href="#常见问题"></a> 常见问题</h2><ul><li><p>Step7推送时: error: src refspec <code>[branchName]</code> does not match any</p><p>修改本地分支名称</p><pre class="language-bash" data-language="bash"><code class="language-bash">git branch -m [oldBranchName] [newBranchName]</code></pre></li></ul><hr />]]></content>
    
    
    <categories>
      
      <category>常用命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>置顶文章测试</title>
    <link href="/2019/10/10/20191010-Test/"/>
    <url>/2019/10/10/20191010-Test/</url>
    
    <content type="html"><![CDATA[<p>你好，有任何问题欢迎在该置顶文章下留言。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
